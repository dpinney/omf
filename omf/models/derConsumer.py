''' Performs cost-benefit analysis for a member-consumer with distributed 
energy resource (DER) technologies. '''

## Python imports
import warnings
#warnings.filterwarnings("ignore")
import shutil, datetime
from os.path import join as pJoin
import numpy as np
import pandas as pd
import plotly.graph_objs as go
import plotly.utils
import requests
import matplotlib.pyplot as plt
from numpy_financial import npv

## OMF imports
from omf.models import __neoMetaModel__
from omf.models.__neoMetaModel__ import *
from omf.models import vbatDispatch as vb
from omf.solvers import reopt_jl
from omf.models import derUtilityCost

## Model metadata:
tooltip = ('The derConsumer model evaluates the financial costs of controlling behind-the-meter \
           distributed energy resources (DERs) at the residential level using the National Renewable Energy \
		   Laboratory (NREL) Renewable Energy Optimization Tool (REopt) and the OMF virtual battery dispatch \
		   module (vbatDispatch).')
modelName, template = __neoMetaModel__.metadata(__file__)
hidden = True ## Keep the model hidden=True during active development

def work(modelDir, inputDict):
	''' Run the model in its directory. '''

	## Delete output file every run if it exists
	outData = {}

	## Convert user provided demand and temp data from str to float
	## NOTE: assumes the input temperature curve is in degrees Fahrenheit. The degrees Celsius conversion is used later for vbatDispatch, which expects deg C. 
	temperatures_degF = [float(value) for value in inputDict['temperatureCurve'].split('\n') if value.strip()]
	temperatures_degC = [float(value)-32.0 * 5/9 for value in inputDict['temperatureCurve'].split('\n') if value.strip()]
	demand = [float(value) for value in inputDict['demandCurve'].split('\n') if value.strip()]
	
	## Gather input variables to pass to the omf.solvers.reopt_jl model
	latitude = float(inputDict['latitude'])
	longitude = float(inputDict['longitude'])
	projectionLength = int(inputDict['projectionLength'])
	year = int(inputDict['year'])
	timestamps = pd.date_range(start=f'{year}-01-01', end=f'{year}-12-31 23:59', freq='h')

	## Make an API call if the URDB Label is selected, then build the energy rate array from the API response information
	if inputDict.get('urdbLabelBool'): ## Checkbox to use the urdb label is True by default
		## Use the URDB label to obtain the energy rate structure .json information via REopt API in order to construct an energy rate array that is used in the analysis.
		## This functionality is for cases where the user only has the URDB label but no .csv or .json describing the energy rate structure from their coop. 
		api_url = 'https://api.openei.org/utility_rates?parameters'
		api_key = '5dFShfSVRt2XJpPYCbzBeLM6nHrOXc0VFPTWxfJJ' ## API key generated by following this website: https://openei.org/services/

		params = {
			'version': '3',
			'format': 'json',
			'getpage': inputDict['urdbLabel'],
			'detail': 'full', ## returns every variable
			'limit': 500, 
			'api_key': api_key
			}
		
		response = requests.get(api_url, params=params)
		if response.status_code == 200:
			try:
				response.raise_for_status()  ## Raise an exception for HTTP errors
				
				## Gather relevant info from the API response
				data = response.json()
				response_file = data['items'][0] ## This response_file is a dictionary containing the utility rate structure information
				#print(response_file)
			except requests.exceptions.RequestException as e:
				print('Error:', e)
				return None
		else:
			print(f"Request failed with status code: {response.status_code}")
	else: ## If the Residential Response File (.json) is chosen and provided, use the user-provided .json response file
		try:
			## Try to normally parse the JSON file
			response_file = json.loads(inputDict['residentialRateStructureFile'])
		except json.JSONDecodeError:
			## Convert single quotes to double quotes for proper JSON formatting
			fixed = inputDict['residentialRateStructureFile'].replace("'", '"')
			response_file = json.loads(fixed)
		except TypeError:
			## Use the residential_rate_curve if it is already a Python dictionary
			if isinstance(inputDict['residentialRateStructureFile'], dict):
				response_file = inputDict['residentialRateStructureFile']

	## TODO: Add functionality to use the Residential Rate Curve (.csv) file. Probably requires a dropdown menu input to select between (.csv) vs. (.json) vs. urdb label.
	#energy_rate_array = [float(value) for value in inputDict['energyRateStructureFile'].split('\n') if value.strip()]
	
	## Construct the energy rate array with the appropriate response_file
	energy_rate_array = derUtilityCost.construct_energy_rate_array(response_file, timestamps)

	########################################################################################################################
	## Run REopt.jl solver
	########################################################################################################################

	## Create a REopt input dictionary called 'scenario' (required input for omf.solvers.reopt_jl)
	scenario = {
		'Site': {
			'latitude': latitude,
			'longitude': longitude
		},
		'ElectricTariff': {
			#'urdb_label': urdbLabel,
			#'add_tou_energy_rates_to_urdb_rate': True
		},
		'ElectricLoad': {
			'loads_kw': demand,
			'year': year
		},
		'Financial': {
			"analysis_years": projectionLength
		}
	}

	## Add either the URDB Label or URDB Response File
	#scenario['ElectricTariff']['tou_energy_rates_per_kwh'] = energy_rate_array
	## TODO: Test the urdb_label against the urdb_response inputs for the same data input. Results are expected to be the same.
	if inputDict.get('urdbLabelBool'):
		scenario['ElectricTariff']['urdb_label'] = inputDict['urdbLabel']
	else:
		scenario['ElectricTariff']['urdb_response'] = inputDict['residentialRateStructureFile']

	## Add a Battery Energy Storage System (BESS) section if enabled 
	if inputDict['enableBESS'] == 'Yes':
		BESScheck = 'enabled'
		scenario['ElectricStorage'] = {
			'min_kw': float(inputDict['BESS_kw']), 
			'max_kw': float(inputDict['BESS_kw']), 
			'min_kwh': float(inputDict['BESS_kwh']), 
			'max_kwh': float(inputDict['BESS_kwh']), 
			'can_grid_charge': True,
			'total_rebate_per_kw': 0.0,
			'macrs_option_years': 0,
			'replace_cost_per_kw': float(inputDict['replace_cost_per_kw']),
			'replace_cost_per_kwh': float(inputDict['replace_cost_per_kwh']),
			'total_itc_fraction': 0.0,
			'inverter_replacement_year': int(inputDict['inverter_replacement_year']),
			'battery_replacement_year': int(inputDict['battery_replacement_year']),
			'soc_min_fraction': 1.0 - float(inputDict['utility_BESS_portion'])/100,
			}
	else:
		BESScheck = 'disabled'
	
	## Add fossil fuel (diesel) generator to input scenario (if enabled)
	if inputDict['fossilGenerator'] == 'Yes':
		GENcheck = 'enabled'
		scenario['Generator'] = {
			'existing_kw': float(inputDict['existing_gen_kw']), ## Existing generator
			'max_kw': 0.0, ## New generator minumum
			'min_kw': 0.0, ## New generator maximum
			'only_runs_during_grid_outage': False,
			'replacement_year': int(inputDict['generator_replacement_year']),
			'replace_cost_per_kw': float(inputDict['replace_cost_generator_per_kw']),
			'fuel_avail_gal': float(inputDict['fuel_avail']),
			'fuel_cost_per_gallon': float(inputDict['fuel_cost']),
		}

	else:
		GENcheck = 'disabled'

	## Save the scenario file
	## NOTE: reopt_jl currently requires a path for the input file, so the file must be saved to a location
	## preferrably in the modelDir directory
	with open(pJoin(modelDir, 'reopt_input_scenario.json'), 'w') as jsonFile:
		json.dump(scenario, jsonFile)
	
	## Read in a static REopt test file
	## NOTE: The single commented code below is used temporarily if reopt_jl is not working or for other debugging purposes.
	## Also NOTE: If this is used, you typically have to add a ['outputs'] key before the variable of interest.
	## For example, instead of reoptResults['ElectricStorage']['storage_to_load_series_kw'], it would have to be
	## reoptResults['outputs']['ElectricStorage']['storage_to_load_series_kw'] when using the static reopt file below.
	#with open(pJoin(__neoMetaModel__._omfDir,"static","testFiles","residential_reopt_results.json")) as f:
	#	reoptResults = pd.json_normalize(json.load(f))
	#	print('Successfully loaded REopt test file. \n')

	reopt_jl.run_reopt_jl(modelDir, 'reopt_input_scenario.json')
	with open(pJoin(modelDir, 'results.json')) as jsonFile:
		reoptResults = json.load(jsonFile)
	outData.update(reoptResults) ## Update output file outData with REopt results data

	########################################################################################################################
	## Run vbatDispatch model
	########################################################################################################################

	## Set up base input dictionary for vbatDispatch runs
	inputDict_vbatDispatch = {
		'load_type': '', ## 1=AirConditioner, 2=HeatPump, 3=Refrigerator, 4=WaterHeater (These conventions are from OMF model vbatDispatch.html)
		'number_devices': '1',
		'power': '',
		'capacitance': '',
		'resistance': '',
		'cop': '',
		'setpoint':  '',
		'deadband': '',
		'unitDeviceCost': '', 
		'unitUpkeepCost':  '', 
		'demandChargeCost': '0.0',
		'projectionLength': inputDict['projectionLength'],
		'discountRate': inputDict['discountRate'],
		'fileName': inputDict['demandFileName'],
		'tempFileName': inputDict['temperatureFileName'],
		'demandCurve': inputDict['demandCurve'],
		'tempCurve': '\n'.join(f"{temp:.2f}" for temp in temperatures_degC), ## Convert temperatures_degC into the expected format for vbatDispatch
		'energyRateCurve': '\n'.join(f"{rate:.2f}" for rate in energy_rate_array), ## Convert energy_rate_array into the expected format for vbatDispatch
	}
	
	## Define thermal variables that change depending on the thermal technology(ies) enabled by the user
	thermal_suffixes = ['_hp', '_ac', '_wh'] ## heat pump, air conditioner, water heater - (Add more suffixes here after establishing inputs in the defaultInputs and derUtilityCost.html)
	thermal_variables=['load_type','power','capacitance','resistance','cop','setpoint','deadband','TESS_subsidy_ongoing','TESS_subsidy_onetime','unitDeviceCost','unitUpkeepCost']

	all_device_suffixes = []
	single_device_results = {} 
	for suffix in thermal_suffixes:
		## Include only the thermal devices specified by the user
		if float(inputDict['load_type'+suffix]) > 0: ## NOTE: If thermal tech is not enabled by the user, the load_type_X variable will be set to 0 in derConsumer.html
			all_device_suffixes.append(suffix)

			## Add the appropriate thermal device variables to the inputDict_vbatDispatch
			for i in thermal_variables:
				inputDict_vbatDispatch[i] = inputDict[i+suffix]

			## Create a model subdirectory for each thermal device and store the vbatDispatch results
			newDir = pJoin(modelDir,'vbatDispatch_results'+suffix)
			os.makedirs(newDir, exist_ok=True)
			os.chdir(newDir) ##jump into the newly created subdirectory

			## Run vbatDispatch for the thermal device
			vbatResults = vb.work(modelDir,inputDict_vbatDispatch)
			with open(pJoin(newDir, 'vbatResults.json'), 'w') as jsonFile:
				json.dump(vbatResults, jsonFile)
			
			## Update the vbatResults to include subsidies (for easier usage later)
			vbatResults['TESS_subsidy_onetime'] = float(inputDict_vbatDispatch['TESS_subsidy_onetime'])#*float(inputDict['number_devices'+suffix])
			vbatResults['TESS_subsidy_ongoing'] = float(inputDict_vbatDispatch['TESS_subsidy_ongoing'])#*float(inputDict['number_devices'+suffix])

			## Store the results in all_device_results dictionary
			single_device_results['vbatResults'+suffix] = vbatResults

			## Go back to the main derUtilityCost model directory and continue on
			os.chdir(modelDir)

	## Initialize an empty dictionary to hold all thermal device results added together
	## Length 8760 represents hourly data for one year, length 12 is monthly data for a year
	combined_device_results = {
		'vbatPower_series': [0]*8760,
		'vbat_charge': [0]*8760,
		'vbat_discharge': [0]*8760,
		'vbat_charge_flipsign': [0]*8760,
		'vbatMinEnergyCapacity': [0]*8760,
		'vbatMaxEnergyCapacity':[0]*8760,
		'vbatEnergy':[0]*8760,
		'vbatMinPowerCapacity': [0]*8760,
		'vbatMaxPowerCapacity': [0]*8760,
		'vbatPower': [0]*8760,
		'savingsTESS': [0]*12,
		'energyAdjustedMonthlyTESS': [0]*12,
		'demandAdjustedTESS': [0]*8760,
		'peakAdjustedDemandTESS': [0]*12,
		'totalCostAdjustedTESS': [0]*12,
		'demandChargeAdjustedTESS': [0]*12,
		'monthlyEnergyConsumptionCost_Adjusted_TESS':[0]*12,
		'combinedTESS_subsidy_ongoing': 0,
		'combinedTESS_subsidy_onetime': 0,
	}

	monthHours = [(0, 744), (744, 1416), (1416, 2160), (2160, 2880), 
		(2880, 3624), (3624, 4344), (4344, 5088), (5088, 5832), 
		(5832, 6552), (6552, 7296), (7296, 8016), (8016, 8760)]

	demandCost = 0.0
	rateCompensation = float(inputDict['rateCompensation'])

	## Combine all thermal device variable data for plotting
	for device_result in single_device_results:
		single_device_vbatPower = single_device_results[device_result]['VBpower']
		single_device_vbatPower_series = pd.Series(single_device_vbatPower)

		combined_device_results['vbatPower'] = [sum(x) for x in zip(combined_device_results['vbatPower'], single_device_vbatPower)]
		combined_device_results['vbatPower_series'] = single_device_vbatPower_series
		vbatPower_series_discharge = single_device_vbatPower_series.where(single_device_vbatPower_series > 0, 0) ##positive values = discharging
		vbatPower_series_charge = single_device_vbatPower_series.where(single_device_vbatPower_series < 0, 0) ##negative values = charging
		combined_device_results['vbat_discharge'] = [sum(x) for x in zip(combined_device_results['vbat_discharge'], vbatPower_series_discharge)]
		combined_device_results['vbat_charge'] = [sum(x) for x in zip(combined_device_results['vbat_charge'], vbatPower_series_charge)]
		combined_device_results['vbat_charge_flipsign'] = pd.Series(combined_device_results['vbat_charge']).mul(-1) ## flip sign of vbat charge to positive values for plotting purposes
		combined_device_results['vbatMinEnergyCapacity'] = [sum(x) for x in zip(combined_device_results['vbatMinEnergyCapacity'], single_device_results[device_result]['minEnergySeries'])]
		combined_device_results['vbatMaxEnergyCapacity'] = [sum(x) for x in zip(combined_device_results['vbatMaxEnergyCapacity'], single_device_results[device_result]['maxEnergySeries'])]
		combined_device_results['vbatEnergy'] = [sum(x) for x in zip(combined_device_results['vbatEnergy'], single_device_results[device_result]['VBenergy'])]
		combined_device_results['vbatMinPowerCapacity'] = [sum(x) for x in zip(combined_device_results['vbatMinPowerCapacity'], single_device_results[device_result]['minPowerSeries'])]
		combined_device_results['vbatMaxPowerCapacity'] = [sum(x) for x in zip(combined_device_results['vbatMaxPowerCapacity'], single_device_results[device_result]['maxPowerSeries'])]
		combined_device_results['savingsTESS'] = [sum(x) for x in zip(combined_device_results['savingsTESS'], single_device_results[device_result]['savings'])]
		combined_device_results['energyAdjustedMonthlyTESS'] = [sum(x) for x in zip(combined_device_results['energyAdjustedMonthlyTESS'], single_device_results[device_result]['energyAdjustedMonthly'])]
		combined_device_results['demandAdjustedTESS'] = [sum(x) for x in zip(combined_device_results['demandAdjustedTESS'], single_device_results[device_result]['demandAdjusted'])]
		combined_device_results['peakAdjustedDemandTESS'] = [sum(x) for x in zip(combined_device_results['peakAdjustedDemandTESS'], single_device_results[device_result]['peakAdjustedDemand'])]
		combined_device_results['totalCostAdjustedTESS'] = [sum(x) for x in zip(combined_device_results['totalCostAdjustedTESS'], single_device_results[device_result]['totalCostAdjusted'])]
		combined_device_results['demandChargeAdjustedTESS'] = [sum(x) for x in zip(combined_device_results['demandChargeAdjustedTESS'], single_device_results[device_result]['demandChargeAdjusted'])]
		combined_device_results['monthlyEnergyConsumptionCost_Adjusted_TESS'] = [sum(x) for x in zip(combined_device_results['monthlyEnergyConsumptionCost_Adjusted_TESS'], single_device_results[device_result]['energyCostAdjusted'])]
		combined_device_results['combinedTESS_subsidy_ongoing'] += float(single_device_results[device_result]['TESS_subsidy_ongoing'])
		combined_device_results['combinedTESS_subsidy_onetime'] += float(single_device_results[device_result]['TESS_subsidy_onetime'])

		single_device_vbat_discharge_component = np.array(single_device_vbatPower_series.where(single_device_vbatPower_series > 0, 0)) ##positive values = discharging
		single_device_vbat_charge_component =  np.array(single_device_vbatPower_series.where(single_device_vbatPower_series < 0, 0)) ##negative values = charging
		single_device_vbat_charge_component_flipsign = pd.Series(single_device_vbat_charge_component).mul(-1) ## flip sign of vbat charge to positive values for plotting purposes

		single_device_subsidy_ongoing = float(single_device_results[device_result]['TESS_subsidy_ongoing'])
		single_device_subsidy_onetime = float(single_device_results[device_result]['TESS_subsidy_onetime'])
		single_device_subsidy_year1_array = np.full(12, single_device_subsidy_ongoing)
		single_device_subsidy_year1_array[0] += single_device_subsidy_onetime
		single_device_subsidy_allyears_array = np.full(projectionLength, single_device_subsidy_ongoing*12.0)
		single_device_subsidy_allyears_array[0] += single_device_subsidy_onetime

		single_device_compensation_year1_array = np.array([sum(single_device_vbat_discharge_component[s:f])*rateCompensation for s, f in monthHours])
		single_device_compensation_year1_total = np.sum(single_device_compensation_year1_array)
		single_device_compensation_allyears_array = np.full(projectionLength, single_device_compensation_year1_total)

		single_device_demand = np.array(single_device_vbat_discharge_component)-np.array(single_device_vbat_charge_component_flipsign)
		single_device_monthlyTESS_consumption_total = [sum(single_device_demand[s:f]) for s, f in monthHours]

		## Calculate the consumption cost saved by each DER tech using the input rate structure (hourly data for the whole year)
		single_device_consumption_cost_year1_array = [float(a) * float(b) for a, b in zip(single_device_demand, energy_rate_array)]

		## Calculate the consumption cost saved by each DER tech using the input rate structure
		single_device_consumption_cost_monthly_array = [sum(single_device_consumption_cost_year1_array[s:f]) for s, f in monthHours]
		single_device_consumption_cost_allyears_array = np.full(projectionLength, sum(single_device_consumption_cost_year1_array))

		savings_year1_monthly_single_device = single_device_subsidy_year1_array + single_device_compensation_year1_array + single_device_consumption_cost_monthly_array
		savings_allyears_single_device = single_device_subsidy_allyears_array + single_device_compensation_allyears_array + single_device_consumption_cost_allyears_array

		## Savings Breakdown Per Thermal Technology savings variables
		## NOTE: This is where the html variables outData['vbatResults_wh_savings_allyears'], outData['vbatResults_hp_savings_allyears'], and outData['vbatResults_ac_savings_allyears'] are saved.
		outData[device_result+'_savings_allyears'] = list(savings_allyears_single_device)
		outData[device_result+'_check'] = 'enabled'
	
	########################################################################################################################################################
	## DER Serving Load Overview plot 
	########################################################################################################################################################

	## If REopt outputs any Electric Storage (BESS) that also does not contain all zeros:
	if 'Generator' in reoptResults:
		generator = np.array(reoptResults['Generator']['electric_to_load_series_kw'])
		generator = np.where(generator == -0.0, 0.0, generator) ## convert negative zero values to positive zero values
		generator_W = generator * 1000. ## convert from kW to W for plotting
	else:
		generator = np.zeros_like(demand)
		generator_W = generator * 1000. ## convert from kW to W for plotting
	
	## TODO: Potentially clean up this ElectricStorage code to make it more sensible and flow better
	if 'ElectricStorage' in reoptResults: 
		if any(value != 0 for value in reoptResults['ElectricStorage']['storage_to_load_series_kw']):
			BESS = np.array(reoptResults['ElectricStorage']['storage_to_load_series_kw'])
			BESS = np.where(BESS == -0.0, 0.0, BESS) ## convert negative zero values to positive zero values
			BESS_W = BESS * 1000. ## convert from kW to W for plotting
			grid_charging_BESS = np.array(reoptResults['ElectricUtility']['electric_to_storage_series_kw'])
			grid_charging_BESS = np.where(grid_charging_BESS == -0.0, 0.0, grid_charging_BESS) ## convert negative zero values to positive zero values
			grid_charging_BESS_W = grid_charging_BESS * 1000. ## convert from kW to W for plotting
			outData['chargeLevelBattery'] = list(np.array(reoptResults['ElectricStorage']['soc_series_fraction']) * 100.)
		else:
			#raise ValueError('The BESS was not built by the REopt model. "storage_to_load_series_kw" contains all zeros.')
			BESS = np.zeros_like(demand)
			BESS_W = BESS * 1000. ## convert from kW to W for plotting
			grid_charging_BESS = np.zeros_like(demand)
			grid_charging_BESS_W = grid_charging_BESS * 1000. ## convert from kW to W for plotting
			outData['chargeLevelBattery'] = list(np.zeros_like(demand))
	else:
		print('No BESS was specified in REopt. Setting BESS variables to zero for plotting purposes.')
		BESS = np.zeros_like(demand)
		BESS_W = BESS * 1000. ## convert from kW to W for plotting
		grid_charging_BESS = np.zeros_like(demand)
		grid_charging_BESS_W = grid_charging_BESS * 1000. ## convert from kW to W for plotting
		outData['chargeLevelBattery'] = list(np.zeros_like(demand))

	## vbatDispatch variables
	vbat_discharge_component = np.array(combined_device_results['vbat_discharge'])
	vbat_charge_component = np.array(combined_device_results['vbat_charge_flipsign'])
	vbat_discharge_component = np.where(vbat_discharge_component == -0.0, 0.0, vbat_discharge_component) ## convert negative zero values to positive zero values
	vbat_charge_component = np.where(vbat_charge_component == -0.0, 0.0, vbat_charge_component) ## convert negative zero values to positive zero values
	vbat_discharge_component_W = vbat_discharge_component * 1000. ## convert from kW to W for plotting
	vbat_charge_component_W = vbat_charge_component * 1000. ## convert from kW to W for plotting
	
	## Calculate all other plot variables from kW to W for plotting
	demand_W = np.array(demand) * 1000. ## convert from kW to W for plotting
	grid_to_load = np.array(reoptResults['ElectricUtility']['electric_to_load_series_kw'])
	grid_to_load = np.where(grid_to_load == -0.0, 0.0, grid_to_load) ## convert negative zero values to positive zero values
	grid_to_load_W = grid_to_load * 1000. ## convert from kW to W for plotting
	grid_serving_new_load_W = grid_to_load_W + grid_charging_BESS_W + vbat_charge_component_W - vbat_discharge_component_W

	## Put all DER plot variables into a dataFrame for plotting
	df = pd.DataFrame({
		'timestamp': timestamps,
		'Home BESS Serving Load': BESS_W,
		'Home TESS Serving Load': vbat_discharge_component_W,
		'Grid Serving Load': grid_to_load_W, #grid_serving_new_load_W,
		'Home Generator Serving Load': generator_W,
		'Grid Charging Home BESS': grid_charging_BESS_W,
		'Grid Charging Home TESS': vbat_charge_component_W
	})

	## Define colors for each plot series
	colors = {
		'Grid Serving Load': 'rgba(128, 128, 128, 0.8)',  ## Gray
		'Home BESS Serving Load': 'rgba(0, 128, 0, 0.8)',  ## Green
		'Home Generator Serving Load': 'rgba(139, 0, 0, 0.8)',  ## Dark red
		'Home TESS Serving Load': 'rgba(128, 0, 128, 0.8)',  ## Purple
		'Grid Charging Home BESS': 'rgba(0, 128, 0, 0.4)',  ## Green w/ half opacity
		'Grid Charging Home TESS': 'rgba(128, 0, 128, 0.4)'  ## Purple w/ half opacity
	}

	## Plot options
	showlegend = True ## either enable or disable the legend toggle in the plot
	lineshape = 'hv'
	fig = go.Figure()

	## Discharging DERs to plot
	for col in ["Grid Serving Load", "Home BESS Serving Load", "Home Generator Serving Load", "Home TESS Serving Load","Grid Charging Home BESS", "Grid Charging Home TESS"]:
		fig.add_trace(go.Scatter(
			x=df["timestamp"],
			y=df[col],
			fill="tonexty",
			mode="none",
			name=col,
			fillcolor=colors[col],
			line_shape=lineshape,			
			stackgroup="discharge"  ## Stack all the discharging DERs together
		))

	## Temperature line on a secondary y-axis (defined in the plot layout)
	fig.add_trace(go.Scatter(x=timestamps,
						y=temperatures_degF,
						yaxis='y2',
						#mode='lines',
						line=dict(color='red',width=1),
						name='Average Air Temperature',
						showlegend=showlegend 
						))
	
	## Make temperature and its legend name hidden in the plot by default
	fig.update_traces(legendgroup='Average Air Temperature', visible='legendonly', selector=dict(name='Average Air Temperature')) 
	fig.update_layout(
		xaxis_title="Timestamp",yaxis_title="Power (W)",
		yaxis2=dict(title='degrees Fahrenheit',overlaying='y',side='right'),
    	legend=dict(orientation='h',yanchor='bottom', xanchor='right',y=1.02,x=1,)
	)

	## NOTE: This opens a window that displays the correct figure with the appropriate patterns.
	## NOTE (cont.): For some reason, the slash-mark patterns are not showing up on the OMF page otherwise. Eventually we will delete this part.
	#fig.show()
	#outData['derOverviewHtml'] = fig.to_html(full_html=False)
	fig.write_html(pJoin(modelDir, "Plot_DerServingLoadOverview.html"))

	## Encode plot data as JSON for showing in the HTML 
	outData['derOverviewData'] = json.dumps(fig.data, cls=plotly.utils.PlotlyJSONEncoder)
	outData['derOverviewLayout'] = json.dumps(fig.layout, cls=plotly.utils.PlotlyJSONEncoder)

	###################################################################################################################################
	## Impact to Demand plot 
	###################################################################################################################################
	showlegend = True ## either enable or disable the legend toggle in the plot
	lineshape = 'hv'

	new_demand = demand_W + vbat_charge_component_W + grid_charging_BESS_W - BESS_W - vbat_discharge_component_W - generator_W

	fig = go.Figure()

	## Original load piece (minus any vbat or BESS charging aka 'new/additional loads')
	fig.add_trace(go.Scatter(x=timestamps,
						y = demand_W,
						yaxis='y1',
						mode='none',
						name='Original Demand',
						fill='tozeroy',
						fillcolor='rgba(81,40,136,1)',
						showlegend=showlegend))
	## Make original load and its legend name hidden in the plot by default
	#fig.update_traces(legendgroup='Original Demand', visible='legendonly', selector=dict(name='Original Demand')) 

	## New demand piece (minus any vbat or BESS charging aka 'new/additional loads')
	fig.add_trace(go.Scatter(x=timestamps,
						y = new_demand,
						yaxis='y1',
						mode='none',
						name='New Demand',
						fill='tozeroy',
						fillcolor='rgba(235,97,35,0.5)',
						showlegend=showlegend))

	## Temperature line on a secondary y-axis (defined in the plot layout)
	fig.add_trace(go.Scatter(x=timestamps,
						y=temperatures_degF,
						yaxis='y2',
						#mode='lines',
						line=dict(color='red',width=1),
						name='Average Air Temperature',
						showlegend=showlegend 
						))
	
	## Make temperature and its legend name hidden in the plot by default
	fig.update_traces(legendgroup='Average Air Temperature', visible='legendonly', selector=dict(name='Average Air Temperature')) 

	## Plot layout
	fig.update_layout(
    	xaxis=dict(title='Timestamp'),
    	#yaxis=dict(title='Power (W)',type='log'),
		yaxis=dict(title='Power (W)'),
    	yaxis2=dict(title='degrees Fahrenheit',overlaying='y',side='right'),
		legend=dict(orientation='h',yanchor='bottom',y=1.02,xanchor='right',x=1)
	)

	## NOTE: This opens a window that displays the correct figure with the appropriate patterns.
	## For some reason, the slash-mark patterns are not showing up on the OMF page otherwise.
	## Eventually we will delete this part.
	#fig.show()
	#outData['derOverviewHtml'] = fig.to_html(full_html=False)
	fig.write_html(pJoin(modelDir, "Plot_NewDemand.html"))

	## Encode plot data as JSON for showing in the HTML 
	outData['newDemandData'] = json.dumps(fig.data, cls=plotly.utils.PlotlyJSONEncoder)
	outData['newDemandLayout'] = json.dumps(fig.layout, cls=plotly.utils.PlotlyJSONEncoder)

	################################################################################################################################################
	## Create Thermal Battery Power plot object 
	################################################################################################################################################
	fig = go.Figure()

	data_names = ['vbatMinPowerCapacity', 'vbatMaxPowerCapacity', 'vbatPower']
	colors = ['green', 'blue', 'black']
	titles = ['Minimum Calculated Power Capacity', 'Maximum Calculated Power Capacity', 'Actual Power Utilized']

	thermalDataCheckList = []
	for data_name, color, title in zip(data_names, colors, titles):
		thermalDataCheck = np.sum(combined_device_results[data_name])
		thermalDataCheckList.append(thermalDataCheck)
		fig.add_trace(go.Scatter(
			x=timestamps, 
			y=np.array(combined_device_results[data_name])*1000., ## convert from kW to W
			yaxis='y1',
			mode='lines',
			line=dict(color=color, width=1),
			name=title,
			showlegend=True
		))

	fig.update_layout(xaxis=dict(title='Timestamp'), yaxis=dict(title='Power (W)'),
		legend=dict(orientation='h',yanchor='bottom',y=1.02,xanchor='right',x=1))
	
	## Add a thermal battery variable that signals to the HTML plot if all of the thermal series contain no data
	outData['thermalDataCheck'] = float(sum(np.array(thermalDataCheckList)))
	
	## Encode plot data as JSON for showing in the HTML side
	outData['thermalBatPowerPlot'] = json.dumps(fig.data, cls=plotly.utils.PlotlyJSONEncoder)
	outData['thermalBatPowerPlotLayout'] = json.dumps(fig.layout, cls=plotly.utils.PlotlyJSONEncoder)

	################################################################################################################################################
	## Create Chemical BESS State of Charge plot object 
	################################################################################################################################################
	fig = go.Figure()
	fig.add_trace(go.Scatter(x=timestamps, y=outData['chargeLevelBattery'],
						mode='lines',
						line=dict(color='purple', width=1),
						name='Battery SOC',
						showlegend=True))
	
	fig.update_layout(xaxis=dict(title='Timestamp'), yaxis=dict(title='Charge (%)'), legend=dict(orientation='h', yanchor='bottom', y=1.02, xanchor='right',x=1))

	outData['batteryChargeData'] = json.dumps(fig.data, cls=plotly.utils.PlotlyJSONEncoder)
	outData['batteryChargeLayout'] = json.dumps(fig.layout, cls=plotly.utils.PlotlyJSONEncoder)

	#########################################################################################################################################################
	### Calculate the monthly consumption and peak demand costs and savings
	#########################################################################################################################################################

	## Calculate the monthly demand and energy consumption (for the demand curve without DERs)
	outData['monthlyPeakDemand'] = [max(demand[s:f]) for s, f in monthHours] ## The maximum peak kW for each month
	outData['monthlyPeakDemandCost'] = [peak*demandCost for peak in outData['monthlyPeakDemand']] ## peak demand charge before including DERs
	demand_cost_array = [float(a) * float(b) for a, b in zip(demand, energy_rate_array)]
	monthlyEnergyConsumption = [sum(demand[s:f]) for s, f in monthHours] ## The total energy in kWh for each month
	monthlyEnergyConsumptionCost = [sum(demand_cost_array[s:f]) for s, f in monthHours] ## The total energy cost in $$ for each month	

	## Calculate the monthly adjusted demand ("adjusted" = the demand curve including DERs)
	adjusted_demand = demand - BESS - vbat_discharge_component - generator + grid_charging_BESS + vbat_charge_component
	outData['adjustedDemand'] = list(adjusted_demand)
	monthlyAdjustedEnergyConsumption = [sum(adjusted_demand[s:f]) for s, f in monthHours] ## The total adjusted energy in kWh for each month
	adjusted_demand_cost_array = [float(a) * float(b) for a, b in zip(adjusted_demand, energy_rate_array)]
	monthlyAdjustedEnergyConsumptionCost = [sum(adjusted_demand_cost_array[s:f]) for s, f in monthHours] ## The total adjusted energy cost in $$ for each month	

	## Calculate the individual costs and savings from the adjusted energy and adjusted demand charges
	monthlyEnergyConsumptionSavings = np.array(monthlyEnergyConsumptionCost) - np.array(monthlyAdjustedEnergyConsumptionCost)

	## Calculate the combined costs and savings from the adjusted energy and adjusted demand charges
	outData['monthlyTotalCostService'] = [ec+dcm for ec, dcm in zip(monthlyEnergyConsumptionCost, outData['monthlyPeakDemandCost'])] ## total cost of energy and demand charge prior to DERs

	## Calculate the individual DER consumption costs using the TOU rate schedule
	## BESS
	demand_cost_array_BESS = [float(a) * float(b) if float(a) != 0 else 0 for a, b in zip(grid_charging_BESS, energy_rate_array)]
	costs_year1_BESS_consumption = sum(demand_cost_array_BESS)
	costs_allyears_BESS_consumption = np.full(projectionLength, costs_year1_BESS_consumption)
	## TESS
	demand_cost_array_TESS = [float(a) * float(b) if float(a) != 0 else 0 for a, b in zip(vbat_charge_component, energy_rate_array)]
	costs_year1_TESS_consumption = sum(demand_cost_array_TESS)
	costs_allyears_TESS_consumption = np.full(projectionLength, costs_year1_TESS_consumption)
	## GEN
	#demand_cost_array_GEN = [float(a) * float(b) if float(a) != 0 else 0 for a, b in zip(generator, energy_rate_array)]
	#costs_year1_GEN_consumption = sum(demand_cost_array_GEN)
	#costs_allyears_GEN_consumption = np.full(projectionLength, costs_year1_GEN_consumption)

	#########################################################################################################################################################
	### Calculate the individual (BESS, TESS, and GEN) contributions to the consumption cost/savings
	#########################################################################################################################################################
	BESSdemand = np.array(BESS)-np.array(grid_charging_BESS)
	TESSdemand = np.array(vbat_discharge_component)-np.array(vbat_charge_component)
	GENdemand = np.array(generator)
	monthly_BESS_consumption_total = [sum(BESSdemand[s:f]) for s, f in monthHours]
	monthly_TESS_consumption_total = [sum(TESSdemand[s:f]) for s, f in monthHours]
	monthly_GEN_consumption_total = [sum(GENdemand[s:f]) for s, f in monthHours]

	## Calculate the consumption cost saved by each DER tech using the input rate structure (hourly data for the whole year)
	BESS_consumption_cost_year1_array = [float(a) * float(b) for a, b in zip(BESSdemand, energy_rate_array)]
	TESS_consumption_cost_year1_array = [float(a) * float(b) for a, b in zip(TESSdemand, energy_rate_array)]
	GEN_consumption_cost_year1_array = [float(a) * float(b) for a, b in zip(GENdemand, energy_rate_array)]

	## Calculate the consumption cost saved by each DER tech using the input rate structure (monthly data for the whole year)
	BESS_consumption_cost_monthly_array = [sum(BESS_consumption_cost_year1_array[s:f]) for s, f in monthHours]
	TESS_consumption_cost_monthly_array = [sum(TESS_consumption_cost_year1_array[s:f]) for s, f in monthHours]
	GEN_consumption_cost_monthly_array = [sum(GEN_consumption_cost_year1_array[s:f]) for s, f in monthHours]

	## Calculate the consumption cost saved by each DER tech using the input rate structure (yearly data for the entire projection length)
	BESS_consumption_cost_allyears_array = np.full(projectionLength, sum(BESS_consumption_cost_year1_array))
	TESS_consumption_cost_allyears_array = np.full(projectionLength, sum(TESS_consumption_cost_year1_array))
	GEN_consumption_cost_allyears_array = np.full(projectionLength, sum(GEN_consumption_cost_year1_array))

	######################################################################################################################################################
	## COSTS
	## Calculate the financial costs of enrolling member-consumer DERs into a utility DER-sharing program
	## e.g. Initial Investment = retrofit costs
	## Total consumer costs = generator fuel cost + BESS replacement cost + BESS inverter replacement cost + BESS retrofit costs +  TESS unit cost + TESS upkeep cost
	######################################################################################################################################################
	## Initialize cost arrays for the Cash Flow Projection and Savings Breakdown Per Technology plots
	costs_allyears_BESS = np.zeros(projectionLength)
	costs_allyears_GEN = np.zeros(projectionLength)
	costs_allyears_TESS = np.zeros(projectionLength)
	costs_allyears_wh = np.zeros(projectionLength)
	costs_allyears_hp = np.zeros(projectionLength)
	costs_allyears_ac = np.zeros(projectionLength)
	costs_allyears_array = np.zeros(projectionLength) ## includes all costs for all tech
	costs_year1_array = np.zeros(12)
	retrofit_cost_total = 0.
	monthly_fuel_cost = np.zeros(12)

	if GENcheck == 'enabled':
		## GEN fuel cost
		gen_annual_fuel_consumption_gal = reoptResults['Generator']['annual_fuel_consumption_gal']
		gen_fuel_cost = float(inputDict['fuel_cost'])
		btu_per_kwh = 3412.0 ## constant
		thermal_efficiency = float(inputDict['thermal_efficiency'])/100.
		monthly_GEN_consumption_total = np.array(monthly_GEN_consumption_total)
		fuel_type = int(inputDict['fuel_type'])

		if fuel_type == 1: ## Natural Gas
			## Assume the fuel cost input is given in units of $/cubic foot
			price_per_cubic_foot = gen_fuel_cost
			btu_per_cubic_ft = 1030.0

			## Convert the monthly GEN energy consumption from kWh to BTU
			monthly_GEN_consumption_total_btu = monthly_GEN_consumption_total * btu_per_kwh 

			## Calculate the amount of natural gas needed per cubic foot
			## = BTUs required / (BTUs per cubic foot * thermal efficiency)
			monthly_gas_needed_cubic_ft = monthly_GEN_consumption_total_btu / (btu_per_cubic_ft * thermal_efficiency)

			## Total monthly fuel cost
			monthly_fuel_cost += monthly_gas_needed_cubic_ft * gen_fuel_cost
			annual_fuel_cost = np.sum(monthly_fuel_cost)

		if fuel_type == 2: ## Propane
			btu_per_gal = 92000 ## Number chosen from https://portfoliomanager.energystar.gov/pdf/reference/Thermal%20Conversions.pdf
			monthly_gallons_used = (monthly_GEN_consumption_total * btu_per_kwh) / (thermal_efficiency * btu_per_gal)
			monthly_fuel_cost += monthly_gallons_used * gen_fuel_cost

		if fuel_type == 3:  # Diesel
			btu_per_gal = 138000 ## Number chosen from https://portfoliomanager.energystar.gov/pdf/reference/Thermal%20Conversions.pdf
			monthly_gallons_used = (monthly_GEN_consumption_total * btu_per_kwh) / (thermal_efficiency * btu_per_gal)
			monthly_fuel_cost += monthly_gallons_used * gen_fuel_cost

		if fuel_type == 4: ## Gasoline
			btu_per_gal = 120214 ## Number chosen from https://www.eia.gov/energyexplained/units-and-calculators/energy-conversion-calculators.php
			monthly_gallons_used = (monthly_GEN_consumption_total * btu_per_kwh) / (thermal_efficiency * btu_per_gal)
			monthly_fuel_cost += monthly_gallons_used * gen_fuel_cost

		costs_year1_gen_fuel = gen_fuel_cost * gen_annual_fuel_consumption_gal
		costs_year1_array += monthly_fuel_cost
		costs_allyears_gen_fuel = np.full(projectionLength, costs_year1_gen_fuel)
		costs_allyears_GEN += costs_allyears_gen_fuel
		costs_allyears_array += costs_allyears_gen_fuel

		## GEN replacement cost
		replacement_cost_GEN = float(inputDict['replace_cost_generator_per_kw']) * float(inputDict['existing_gen_kw']) ## units: $
		replacement_year_GEN = int(inputDict['generator_replacement_year'])
		for year in range(0, projectionLength): ## Apply the replacement costs for the specified replacement years
			if year % replacement_year_GEN == 0 and year != 0:
				costs_allyears_array[year] += replacement_cost_GEN
				costs_allyears_GEN[year] += replacement_cost_GEN

		## GEN retrofit cost
		retrofit_cost_GEN = float(inputDict['gen_retrofit_cost'])
		costs_allyears_GEN[0] += retrofit_cost_GEN
		retrofit_cost_total += retrofit_cost_GEN

	## Thermal retrofit costs (TODO: Add replacement costs later?)
	retrofit_cost_total = 0

	if float(inputDict['load_type_wh']) > 0:  ## Check if water heater is enabled
		retrofit_cost_wh = float(inputDict['unitDeviceCost_wh'])
		costs_allyears_wh[0] += retrofit_cost_wh
		retrofit_cost_total += retrofit_cost_wh

	if float(inputDict['load_type_ac']) > 0:  ## Check if air conditioner is enabled
		retrofit_cost_ac = float(inputDict['unitDeviceCost_ac'])
		costs_allyears_ac[0] += retrofit_cost_ac
		retrofit_cost_total += retrofit_cost_ac

	if float(inputDict['load_type_hp']) > 0:  ## Check if heat pump is enabled
		retrofit_cost_hp = float(inputDict['unitDeviceCost_hp'])
		costs_allyears_hp[0] += retrofit_cost_hp
		retrofit_cost_total += retrofit_cost_hp

	## Calculate total retrofit cost for TESS only if at least one technology is enabled
	if retrofit_cost_total > 0:
		costs_allyears_TESS[0] += retrofit_cost_total

	## BESS retrofit and replacement costs
	if BESScheck == 'enabled':
		## BESS retrofit cost
		retrofit_cost_BESS = float(inputDict['BESS_retrofit_cost'])
		costs_allyears_BESS[0] += retrofit_cost_BESS

		## BESS replacement cost
		replacement_cost_BESS_kw = float(inputDict['replace_cost_per_kw']) ## units: $
		replacement_cost_BESS_kwh = float(inputDict['replace_cost_per_kwh']) ## units: $
		BESS_kw = float(inputDict['BESS_kw'])
		BESS_kwh = float(inputDict['BESS_kwh'])
		replacement_cost_BESS = BESS_kw * replacement_cost_BESS_kw + BESS_kwh * replacement_cost_BESS_kwh
		replacement_cost_inverter = float(inputDict['replace_cost_inverter'])
		replacement_year_BESS = int(inputDict['battery_replacement_year'])
		replacement_year_inverter = int(inputDict['inverter_replacement_year'])
		for year in range(0, projectionLength): ## Apply the replacement costs for the specified replacement years
			if year % replacement_year_BESS == 0 and year != 0:
				costs_allyears_array[year] += replacement_cost_BESS
				costs_allyears_BESS[year] += replacement_cost_BESS
			if year % replacement_year_inverter == 0 and year != 0:
				costs_allyears_array[year] += replacement_cost_inverter
				costs_allyears_BESS[year] += replacement_cost_inverter

	## Initial Investment
	initialInvestment = retrofit_cost_total
	costs_allyears_array[0] += initialInvestment
	
	## Calculate cost array for year 1 only
	## TODO: potentially add electricity cost for electricity bought from utility here
	#costs_year1_adjustedEnergyConsumption = np.sum(outData['monthlyAdjustedEnergyConsumptionCost'])
	#costs_allyears_energyConsumption = np.full(projectionLength,costs_year1_adjustedEnergyConsumption)
	#costs_allyears_array += costs_allyears_energyConsumption
	costs_allyears_total = sum(costs_allyears_array)
	costs_year1_array[0] += initialInvestment
	costs_year1_total = sum(costs_year1_array)
	#costs_allyears_total_minus_initial_investment = costs_allyears_total - initialInvestment


	######################################################################################################################################################
	## SAVINGS
	## Calculate the financial savings of enrolling member-consumer DERs into a utility DER-sharing program
	## Total consumer savings = upfront subsidy + ongoing subsidy + compensation for all DERs 
	######################################################################################################################################################

	## If BESS is enabled
	if BESScheck == 'enabled':
		## Calculate the BESS subsidy for year 1 and the projection length (all years)
		## Year 1 includes the onetime subsidy, but subsequent years only include the ongoing subsidies.
		BESS_subsidy_ongoing = float(inputDict['BESS_subsidy_ongoing'])
		BESS_subsidy_onetime = float(inputDict['BESS_subsidy_onetime'])
		BESS_subsidy_year1_total =  BESS_subsidy_onetime + (BESS_subsidy_ongoing*12.0)
		BESS_subsidy_year1_array =  np.full(12, BESS_subsidy_ongoing)
		BESS_subsidy_year1_array[0] += BESS_subsidy_onetime
		BESS_subsidy_allyears_array = np.full(projectionLength, BESS_subsidy_ongoing*12.0)
		BESS_subsidy_allyears_array[0] += BESS_subsidy_onetime

		## Calculate BESS compensation 
		BESS_compensation_year1_array = np.array([sum(BESS[s:f])*rateCompensation for s, f in monthHours])
		BESS_compensation_year1_total = np.sum(BESS_compensation_year1_array)
		BESS_compensation_allyears_array = np.full(projectionLength, BESS_compensation_year1_total)

		## Calculate total BESS savings
		savings_year1_monthly_BESS = BESS_subsidy_year1_array + BESS_compensation_year1_array + BESS_consumption_cost_monthly_array
		savings_allyears_BESS = BESS_subsidy_allyears_array + BESS_compensation_allyears_array + BESS_consumption_cost_allyears_array
	else: ## If the DER tech is disabled, then set all of the corresponding subsidies and compensation rates equal to zero.
		BESS_subsidy_ongoing = 0
		BESS_subsidy_onetime = 0
		BESS_subsidy_year1_array = np.full(12, 0.0)
		BESS_subsidy_allyears_array = np.full(projectionLength, 0.0)
		BESS_compensation_year1_array = np.full(12, 0.)
		BESS_compensation_year1_total = 0.
		BESS_compensation_allyears_array = np.full(projectionLength, 0)
		savings_year1_monthly_BESS = np.zeros(12)
		savings_allyears_BESS = np.zeros(projectionLength)

	## If generator is enabled
	if GENcheck == 'enabled':
		## Calculate Generator Subsidy for year 1 and the projection length (all years)
		## Year 1 includes the onetime subsidy, but subsequent years do not.
		GEN_subsidy_ongoing = float(inputDict['GEN_subsidy_ongoing'])
		GEN_subsidy_onetime = float(inputDict['GEN_subsidy_onetime'])
		GEN_subsidy_year1_total =  GEN_subsidy_onetime + (GEN_subsidy_ongoing*12.0)
		GEN_subsidy_year1_array =  np.full(12, GEN_subsidy_ongoing)
		GEN_subsidy_year1_array[0] += GEN_subsidy_onetime
		GEN_subsidy_allyears_array = np.full(projectionLength, GEN_subsidy_ongoing*12.0)
		GEN_subsidy_allyears_array[0] += GEN_subsidy_onetime
		
		## Calculate GEN compensation
		GEN_compensation_year1_array = np.array([sum(generator[s:f])*rateCompensation for s, f in monthHours])
		GEN_compensation_year1_total = np.sum(GEN_compensation_year1_array)
		GEN_compensation_allyears_array = np.full(projectionLength, GEN_compensation_year1_total)
		
		## Calculate total GEN savings
		savings_year1_monthly_GEN = GEN_subsidy_year1_array + GEN_compensation_year1_array + GEN_consumption_cost_monthly_array
		savings_allyears_GEN = GEN_subsidy_allyears_array + GEN_compensation_allyears_array + GEN_consumption_cost_allyears_array
	else:
		GEN_subsidy_ongoing = 0
		GEN_subsidy_onetime = 0
		GEN_subsidy_year1_array = np.full(12, 0.0)
		GEN_subsidy_allyears_array = np.full(projectionLength, 0.0)
		GEN_compensation_year1_array = np.full(12, 0.)
		GEN_compensation_year1_total = 0.
		GEN_compensation_allyears_array = np.full(projectionLength, 0)
		savings_year1_monthly_GEN = np.zeros(12)
		savings_allyears_GEN = np.zeros(projectionLength)

	## Initialize variables for TESS subsidies and compensation
	TESS_subsidy_ongoing = 0
	TESS_subsidy_onetime = 0
	TESS_compensation_year1_total = 0.0

	## Check if any thermal technology is enabled
	if (float(inputDict['load_type_wh']) > 0 or 
		float(inputDict['load_type_ac']) > 0 or 
		float(inputDict['load_type_hp']) > 0):
		
		## Calculate the total TESS subsidies for year 1 and the projection length (all years)
		TESS_subsidy_ongoing = combined_device_results['combinedTESS_subsidy_ongoing']
		TESS_subsidy_onetime = combined_device_results['combinedTESS_subsidy_onetime']
		TESS_subsidy_year1_total = TESS_subsidy_onetime + (TESS_subsidy_ongoing * 12.0)
		
		TESS_subsidy_year1_array = np.full(12, TESS_subsidy_ongoing)
		TESS_subsidy_year1_array[0] += TESS_subsidy_onetime
		
		TESS_subsidy_allyears_array = np.full(projectionLength, TESS_subsidy_ongoing * 12.0)
		TESS_subsidy_allyears_array[0] += TESS_subsidy_onetime
		
		## Calculate TESS compensation
		TESS_compensation_year1_array = np.array([sum(vbat_discharge_component[s:f]) * rateCompensation for s, f in monthHours])
		TESS_compensation_year1_total = np.sum(TESS_compensation_year1_array)
		TESS_compensation_allyears_array = np.full(projectionLength, TESS_compensation_year1_total)
		
		## Calculate total TESS savings
		savings_year1_monthly_TESS = TESS_subsidy_year1_array + TESS_compensation_year1_array + TESS_consumption_cost_monthly_array
		savings_allyears_TESS = TESS_subsidy_allyears_array + TESS_compensation_allyears_array + TESS_consumption_cost_allyears_array
	else:
		## If no thermal technology is enabled, then initialize all arrays with zeros
		GEN_subsidy_year1_array = np.full(12, 0.0)
		GEN_subsidy_allyears_array = np.full(projectionLength, 0.0)
		TESS_compensation_year1_array = np.full(12, 0.0)
		TESS_compensation_year1_total = 0.0
		TESS_compensation_allyears_array = np.full(projectionLength, 0.0)
		savings_year1_monthly_TESS = np.zeros(12)
		savings_allyears_TESS = np.zeros(projectionLength)

	## Combine all tech device compensations
	allDevices_compensation_year1_array = BESS_compensation_year1_array + GEN_compensation_year1_array + TESS_compensation_year1_array
	allDevices_compensation_year1_total = np.sum(allDevices_compensation_year1_array)
	allDevices_compensation_allyears_array = BESS_compensation_allyears_array + GEN_compensation_allyears_array + TESS_compensation_allyears_array

	## Calculate the total TESS+BESS+generator subsidies for year 1 and the projection length (all years)
	## The first month of Year 1 includes the onetime subsidy, but subsequent months and years only include the ongoing subsidies.
	allDevices_subsidy_ongoing = GEN_subsidy_ongoing + BESS_subsidy_ongoing + TESS_subsidy_ongoing
	allDevices_subsidy_onetime = GEN_subsidy_onetime + BESS_subsidy_onetime + TESS_subsidy_onetime
	allDevices_subsidy_year1_total = allDevices_subsidy_onetime + (allDevices_subsidy_ongoing*12.0)
	allDevices_subsidy_ongoing_year1_array = np.full(12, allDevices_subsidy_ongoing)
	allDevices_subsidy_year1_array = allDevices_subsidy_ongoing_year1_array.copy()
	allDevices_subsidy_year1_array[0] += allDevices_subsidy_onetime
	allDevices_subsidy_ongoing_allyears_array = np.full(projectionLength, sum(allDevices_subsidy_ongoing_year1_array))
	allDevices_subsidy_allyears_array = allDevices_subsidy_ongoing_allyears_array
	allDevices_subsidy_allyears_array[0] += allDevices_subsidy_onetime

	## Calculate total savings
	savings_year1_monthly_array = np.array(monthlyEnergyConsumptionSavings) + allDevices_subsidy_year1_array + allDevices_compensation_year1_array
	savings_year1_total = sum(savings_year1_monthly_array)
	savings_consumption_allyears_array = np.full(projectionLength, sum(monthlyEnergyConsumptionSavings))
	savings_allyears_array = savings_consumption_allyears_array + allDevices_subsidy_allyears_array + allDevices_compensation_allyears_array
	savings_allyears_total = sum(savings_allyears_array)

	## Calculate net savings = savings - costs
	net_savings_year1_total = savings_year1_total - costs_year1_total
	net_savings_year1_array = savings_year1_monthly_array - costs_year1_array
	net_savings_allyears_array = savings_allyears_array - costs_allyears_array
	net_savings_allyears_total = savings_allyears_total - costs_allyears_total

	######################################################################################################################################################
	## MONTHLY COST COMPARISON PLOT VARIABLES
	######################################################################################################################################################
	outData['monthlyEnergyConsumption'] = list(monthlyEnergyConsumption)
	outData['monthlyAdjustedEnergyConsumption'] = list(monthlyAdjustedEnergyConsumption)
	outData['monthlyEnergyConsumptionCost'] = list(monthlyEnergyConsumptionCost)
	outData['monthlyAdjustedEnergyConsumptionCost'] = list(monthlyAdjustedEnergyConsumptionCost)
	outData['monthlyEnergyConsumptionSavings'] = list(monthlyEnergyConsumptionSavings)
	outData['monthly_gen_fuel_cost'] = list(monthly_fuel_cost)
	outData['allDevices_subsidy_year1'] = list(allDevices_subsidy_year1_array)
	outData['allDevices_compensation_year1'] = list(allDevices_compensation_year1_array)
	outData['savings_year1_monthly_array'] = list(savings_year1_monthly_array)
	outData['costs_year1_array'] = list(costs_year1_array)
	outData['net_savings_year1_array'] = list(net_savings_year1_array)


	######################################################################################################################################################
	## CashFlow Projection Plot variables
	## NOTE: Costs are converted to a negative value for plotting purposes
	######################################################################################################################################################
	## Calculate Net Present Value (NPV) and Simple Payback Period (SPP)
	outData['NPV'] = npv(float(inputDict['discountRate'])/100., net_savings_allyears_array)
	SPP = initialInvestment/savings_year1_total
	outData['SPP'] = SPP
	outData['savings_allyears_array'] = list(savings_allyears_array)
	outData['costs_allyears_array'] = list(costs_allyears_array*-1.0) ## negative for plotting purposes
	outData['cumulativeCashflow_total'] = list(np.cumsum(net_savings_allyears_array))
	
	######################################################################################################################################################
	## Savings Breakdown Per Technology Plot variables
	## NOTE: Costs are converted to a negative value for plotting purposes
	######################################################################################################################################################
	outData['savings_allyears_BESS'] = list(savings_allyears_BESS)
	outData['savings_allyears_TESS'] = list(savings_allyears_TESS)
	outData['savings_allyears_GEN'] = list(savings_allyears_GEN)
	outData['costs_allyears_BESS'] = list(-1.0*(costs_allyears_BESS)) 
	outData['costs_allyears_TESS'] = list(-1.0*(costs_allyears_TESS))
	outData['costs_allyears_GEN'] = list(-1.0*(costs_allyears_GEN))
	outData['cumulativeSavings_total'] = list(np.cumsum(savings_allyears_array))

	outData['costs_allyears_wh'] = list(-1.0*(costs_allyears_wh))
	outData['costs_allyears_hp'] = list(-1.0*(costs_allyears_hp))
	outData['costs_allyears_ac'] = list(-1.0*(costs_allyears_ac))

	## Add a flag for the case when no DER technology is specified. The Savings Breakdown plot will then display a placeholder plot with no available data.
	outData['techCheck'] = float(sum(BESS) + sum(vbat_discharge_component) + sum(generator))

	# Stdout/stderr.
	outData['stdout'] = 'Success'
	outData['stderr'] = ''

	return outData

def new(modelDir):
	''' Create a new instance of this model. Returns true on success, false on failure. '''
	
	with open(pJoin(__neoMetaModel__._omfDir,'static','testFiles','derConsumer','residential_PV_load_tenX.csv')) as f:
		demand_curve = f.read()
	with open(pJoin(__neoMetaModel__._omfDir,'static','testFiles','derConsumer','open-meteo-denverCO-noheaders.csv')) as f:
		temperature_curve = f.read()
	with open(pJoin(__neoMetaModel__._omfDir,'static','testFiles','derUtilityCost','TODrate66a13566e90ecdb7d40581d2.json')) as jsonFile:
		residential_rate_curve = json.load(jsonFile)
	#with open(pJoin(__neoMetaModel__._omfDir,'static','testFiles','derConsumer','TOU_rate_schedule.csv')) as f:
	#	energy_rates_per_kwh = f.read()
	
	defaultInputs = {
		## OMF inputs:
		'user' : 'admin',
		'modelType': modelName,
		'created': str(datetime.datetime.now()),

		## REopt inputs:
		## NOTE: Variables are strings as dictated by the html input options

		#'latitude':  '38.353673', ## Charleston, WV
		#'longitude': '-81.640283', ## Charleston, WV
		# 'urdbLabel': '5a95a9a45457a36540a199a0', ## Charleston, WV - Appalachian Power Co Residential Time of Day https://apps.openei.org/USURDB/rate/view/5a95a9a45457a36540a199a0#3__Energy
		'urdbLabel' : '66a13566e90ecdb7d40581d2', # Brighton, CO Residential Time of Day residential rate https://apps.openei.org/USURDB/rate/view/66a13566e90ecdb7d40581d2#3__Energy
		#'urdbLabel' : '612ff9c15457a3ec18a5f7d3', # Brighton, CO standard residential rate https://apps.openei.org/USURDB/rate/view/612ff9c15457a3ec18a5f7d3#3__Energy
		#'urdbLabel' : '5b311c595457a3496d8367be', # Brighton, CO Residential Time of Use rate https://apps.openei.org/USURDB/rate/view/5b311c595457a3496d8367be#3__Energy
		'latitude' : '39.969753', ## Brighton, CO
		'longitude' : '-104.812599', ## Brighton, CO
		'year' : '2018',
		'demandFileName': 'residential_PV_load_tenX.csv',
		'demandCurve': demand_curve,
		'temperatureFileName': 'open-meteo-denverCO-noheaders.csv',
		'temperatureCurve': temperature_curve,
		'urdbLabelBool': True,
		'residentialRateStructureFileName': 'TODrate66a13566e90ecdb7d40581d2.json',
		'residentialRateStructureFile': residential_rate_curve,
		#'residentialRateCurveFileName': 'TOU_rate_schedule.csv',
		#'residentialRateCurveFile': energy_rates_per_kwh,

		## Financial Inputs
		'projectionLength': '25',
		'discountRate': '1',
		'rateCompensation': '0.1', ## unit: $/kWh
		'subsidyUpfront': '50',
		'subsidyOngoing': '10',
		'TESS_subsidy_onetime_ac': '25.0',
		'TESS_subsidy_ongoing_ac': '5.0',
		'TESS_subsidy_onetime_hp': '25.0',
		'TESS_subsidy_ongoing_hp': '5.0',
		'TESS_subsidy_onetime_wh': '25.0',
		'TESS_subsidy_ongoing_wh': '5.0',
		'BESS_subsidy_onetime': '100.0',
		'BESS_subsidy_ongoing': '55.0',
		'GEN_subsidy_onetime': '25.0',
		'GEN_subsidy_ongoing': '5.0',

		## Chemical Battery Inputs
		## Modeled after residential Tesla Powerwall 3 battery specs
		'enableBESS': 'Yes',
		'BESS_kw': '5',
		'BESS_kwh': '13.5',
		'BESS_retrofit_cost': '0.0',
		'utility_BESS_portion': '20',
		'total_govt_rebate': '0.0', ## No incentives considered
		'replace_cost_per_kw': '324.0', 
		'replace_cost_per_kwh': '351.0', 
		'battery_replacement_year': '10',  
		'BESS_installed_cost': '0.0', 
		'total_itc_fraction': '0.0', ## No ITC
		'inverter_replacement_year': '10',
		'replace_cost_inverter': '2400',

		## Fossil Fuel Generator
		## NOTE: Generac Guardian models range from 10-26 kW
		'fossilGenerator': 'Yes',
		'fuel_type': '3', 
		'existing_gen_kw': '5',
		'thermal_efficiency': '35',
		'gen_retrofit_cost': '0.0',
		'fuel_avail': '1000', 
		'fuel_cost': '3.80',
		'replace_cost_generator_per_kw': '450',
		'generator_replacement_year': '15',

		## Home Air Conditioner inputs (vbatDispatch):
		'load_type_ac': '1',
		'unitDeviceCost_ac': '13', #a cheap wifi-enabled smart outlet to plug the AC into is about $13 (see https://www.lowes.com/pd/Enbrighten-125-Volt-1-Outlet-Indoor-Smart-Plug/1003202046)
		'unitUpkeepCost_ac': '0', ## NOTE: Input is currently hidden in HTML
		'power_ac': '0.5', ## In-window air unit power
		'capacitance_ac': '2',
		'resistance_ac': '2',
		'cop_ac': '2.5',
		'setpoint_ac': '22.5',
		'deadband_ac': '0.625',

		## Home Heat Pump inputs (vbatDispatch):
		'load_type_hp': '2', 
		'unitDeviceCost_hp': '150',
		'unitUpkeepCost_hp': '0', ## NOTE: Input is currently hidden in HTML
		'power_hp': '5.6',
		'capacitance_hp': '2',
		'resistance_hp': '2',
		'cop_hp': '3.5',
		'setpoint_hp': '19.5',
		'deadband_hp': '0.625',

		## Home Water Heater inputs (vbatDispatch):
		'load_type_wh': '4', 
		'unitDeviceCost_wh': '175',
		'unitUpkeepCost_wh': '0', ## NOTE: Input is currently hidden in HTML
		'power_wh': '4.5',
		'capacitance_wh': '0.4',
		'resistance_wh': '120',
		'cop_wh': '1',
		'setpoint_wh': '48.5',
		'deadband_wh': '3',
	}
	return __neoMetaModel__.new(modelDir, defaultInputs)

@neoMetaModel_test_setup
def _tests_disabled():
	# Location
	modelLoc = pJoin(__neoMetaModel__._omfDir,'data','Model','admin','Automated Testing of ' + modelName)
	# Blow away old test results if necessary.
	try:
		shutil.rmtree(modelLoc)
	except:
		# No previous test results.
		pass
	# Create New.
	new(modelLoc)
	# Pre-run.
	__neoMetaModel__.renderAndShow(modelLoc)
	# Run the model.
	__neoMetaModel__.runForeground(modelLoc)
	# Show the output.
	__neoMetaModel__.renderAndShow(modelLoc)

if __name__ == '__main__':
	_tests_disabled() ## NOTE: Workaround for failing test. When model is ready, change back to just _tests()
	pass