<!DOCTYPE html>
<html>
	<head>
		<meta charset="UTF-8">
		<style>
            /* Define global css variables */
            /* I have to subtract 4px or so from the svgContainer to prevent the scrollbar from appearing. Making the header height less does not appear to change anything. */
            :root {
                --header-height: 35px;
                --header-padding-top: 8px;
                --header-padding-bottom: 8px;
            }
			* { 
                font-family: Helvetica, Arial, Sans-Serif;
            }
			div.divButton {
				-webkit-touch-callout: none;
				-webkit-user-select: none;
				-khtml-user-select: none;
				-moz-user-select: none;
				-ms-user-select: none;
				user-select: none;
				cursor: pointer;
				cursor: hand;
				position:fixed;
				width:30px;
				height:30px;
				text-align:center;
				font-size:30px;
				line-height:30px;
				color:white;
                background-color: dimgrey;
                left: 5px;
                border-radius: 5px;
			}
            #scaleButton {
                top: 175px;
            }
			body {
                /*width: 100%;
                height: 100%;*/
                margin:0px;
            }
			a {
				text-decoration: none;
                color: mediumseagreen;
                /*color: black;*/
			}
            /*a:visited {
                color: seagreen;
            }*/

            /* SVG */

            #interfaceContainer {
                position: relative;
            }

            /* This is the element that acts as a hook for svg-pan-zoom.js to attach a viewport, which it creates itself */
            /* overflow: hidden is set by svg-pan-zoom.js itself. No need to change that here. */
			#svgContainer {
                /* width must be 100%, meaning 100% of the document */
				width: 100%; 
                /* height must be manually set to a hard value */
				/*height: calc(100vh - var(--header-height) - var(--header-padding-bottom) - var(--header-padding-top));*/
				height: calc(100vh - var(--header-height) - var(--header-padding-bottom) - var(--header-padding-top) - 4px);
			}
			#saveButton {
				float:right;
			}

            div#loadingMessage {
                width: 100%;
                height: 100%;
				/*background-color: rgba(0,0,0,0.4); */
                background-color: white;
                position: fixed;
                top: 0px;
            }

            /**************************************************
            // Header and menu links
            **************************************************/

			#header {
				width:100%;
				height: var(--header-height);
				padding-top: var(--header-padding-top);
				padding-bottom: var(--header-padding-bottom);
				background:black;
                display: flex;
                justify-content: space-between;
                align-items: center;
			}
            #menuLeft h4 {
                margin: 0px 0px 4px 20px;
            }
            #menuLeft p {
                margin: 0px 0px 0px 20px;
            }
            #menuRight { 
              display:flex;
                      align-items: center;
            }
            .white {
                color: #F8F8F8;
            }
            .menuHeading {
                margin: 0px;
                padding: 5px;
                border-radius: 5px 5px 0px 0px;
            }
            .expandedHeading {
                color: black;
                background: #F8F8F8;
            }
            .headerGroup {
                position: relative; /* set to relative in order to correctly align the ul.menu */
                margin-right: 15px;
                cursor: pointer;
            }
            ul.menu {
                list-style: none; /* remove bullet points from menu */
                margin: 0px;
                padding: 0px;
                position: absolute; /* remove the menu from the document flow */
                background-color: #F8F8F8;
                right: 0px; /* align the menu to the left */
                box-shadow: 0 11px 10px rgba(0, 0, 0, 0.2); /* add shadow to the menu */
                border-radius: 5px 0 0 0; /* round the top left corner of the menu */
                max-height: 550px; /* Limit the length of the component list */
                overflow: auto;
                white-space: nowrap;
            }
            ul.menu li { 
                padding: 4px; 
            }
            ul.menu li:hover {
                background:green; color:white; 
            }

            /**************************************************
            // Modal Dialogs
            **************************************************/

            #componentTable {
                max-height: 65vh;
                overflow: auto;
                min-width: 450px;
            }
            #progressModalCancel {
                background-color: crimson;
            }
            #progressModal {
                z-index: 1;
            }
            #massAddModal .modalContent {
                width: 400px;
            }
            #climateModal label {
                white-space: nowrap;
            }
            #anonymizeModal {
                white-space: nowrap;
            }
			.modal {
                position: fixed;
                top: 0px;
                width: 100%;
                height: 100%;
                display: flex;
                justify-content: center;
                align-items: center;
				background-color: rgba(0,0,0,0.4); /* Black w/ opacity */
			}
	 		.modalContent {
                padding: 20px;
                border-radius: 10px;
				background-color: #fefefe;
                /*max-height: 80vh;*/
                /*overflow: auto;*/
                overflow: hidden;
                max-width: 80vw;

			}
            .progressModalMessages {
                padding: 20px;
            }
            .modalContentButtons {
                padding: 50px 0px 0px 0px;
                text-align: center;
            }
            #feederListFlex {
                display: flex;
                min-width: 50vw;
            }
            #feederListFlex h3 {
                text-align: center;
            }
            #feederListFlex div {
                width: 50%;
            }
            .right {
                float: right;
            }
            .centered {
                text-align: center;
            }
            .modalHeading {
                text-align: center;
            }
            .modalInput {
                font-size: medium;
                border: 0px;
                background-color: gainsboro;
                width: 100%;
            }
            .modalInputLine {
                font-size: medium;
                border: 0px;
                background-color: gainsboro;
            }
            .vertFlex {
                display: flex;
                flex-direction: column;
            }
            .legendFlex {
                display: flex;
                height: 40vh;
            }
            .legendGradiant {
                height: 100%;
                width: 5vw;
            }
            .legendAxis {
                height: 100%;
                margin: 0px 0px 0px 20px;
                justify-content: space-between;
            }
            .legendAxis p {
                margin: 0px;
            }
            .modalTableHeader {
                margin: 20px 0px 0px 0px;
            }
            .modalButton {
                font-size: medium;
                background-color: seagreen;
                -webkit-border-radius: 5px;
                -moz-border-radius: 5px;
                border-radius: 5px;
                border: none;
                color: white;
                cursor: pointer;
                padding: 4px 6px 4px;
            }
            .leftText {
                text-align: left;
            }
            .modalTableRow {
                width: 50%;
            }
            .scrollableList {
                overflow: auto;
                max-height: 70vh;
                list-style-type: none;
                margin: 0px;
                padding: 0px 20px 0px 20px;
                cursor: pointer;
            }
            .feederItem {
                padding: 5px 0px 5px 0px;
                margin: 10px 0px 10px 0px;
            }
            .feederItem:hover {
                color: white;
                background-color: green;
            }
            .buttonRow button {
                margin-right: 5px;
            }
            .tableInput {
                font-size: small;
                background-color: gainsboro;
                padding: 3px;
                border: 0px;
            }
            .deleteButton {
                background-color: #CC0000;
                /*padding: 1px 7px 1px 7px;*/
            }
            /* TODO: might need to delete this rule */
            .editButton {
                font-size: small;
                /*width: 100%;*/
            }

			/* dataTable */

            .floatingTables {
                position: absolute;
                top: 0px;
                right: 51vw;
                height: 0px;
            }

            #descriptionTables { }

            #selectionTable { }

            .formContainer {
				/*position: fixed;*/
				/*top: 55px;*/
                height:0px;
				/*right: 5px;*/
            }

            /* Don't set overflow-y to hidden */
			.dataTable {
                position: fixed;
				top: 55px;
				border:1px solid black;
				border-collapse: collapse;
                display: inline-block;
                overflow-x: hidden;
				max-height: 90vh;
                right: 10px;
			}
            .dataTable tr {
                border-bottom: 1px solid black;
            }
            .dataTable tr:last-child {
                border: 0px;
            }
            .tableTitle {
                background-color: black;
                color: white;
                cursor: move;
            }
			tbody {
                border-collapse: collapse;
			}
			td {
				background:white;
				border-collapse: collapse;
			}
            .verticalPadded {
				padding: 5px 0px 5px 0px;
            }
            .fullPadded {
				padding: 5px;
            }
            #componentList {
                min-width:250px;
            } /* Hack to prevent horizontal scrolling. */

            /* SVG Styling */

            line { stroke: rgb(0,0,0); } /* black */
            line.parentChild { stroke: rgb(211,211,211); } /* LightGray */
            circle {
                stroke: rgb(255,255,255); /* white */
                fill: rgb(128,128,128); /* gray */
            }
            .house { fill: rgb(0,0,255); } /* blue */
            .load { fill: rgb(0,0,255); } /* blue */
            .generator {  fill: rgb(255,0,0); } /* red */
            .triplex_meter { fill:rgb(255,165,0); } /* orange */
            .storage { fill: rgb(255,0,0); } /* red */
            .capacitor { fill: rgb(128,0,128);}  /* purple */
            .underground_line { stroke: rgb(128,128,128);}
            .transformer { stroke:rgb(255,165,0); } /* orange */
            .regulator { stroke: rgb(255,0,0) ;} /* red */
            .undefined,.regulator_configuration,.transformer_configuration,.triplex_line_configuration,.line_configuration,.volt_var_control,.line_spacing,.climate,.overhead_line_conductor,.underground_line_conductor,.triplex_line_conductor,.player,.schedule { fill: rgb(191,191,191); } /* 75% lightness gray */
        </style>
        <link rel="stylesheet" href="/static/jquery-ui.min.css">
        <script type="text/javascript" src="/static/jquery.js"></script>
        <script type="text/javascript" src="/static/jquery-ui.min.js"></script>
        <script type="text/javascript" src="/static/svg-pan-zoom.js"></script>
        <script type="text/javascript" src="/static/chroma.min.js"></script>
        <script type="text/javascript" src="/static/papaparse.min.js"></script>
        <link rel="shortcut icon" href="/static/favicon.ico"/>
		{% if jasmine %}{{ jasmine | safe }}{% endif %}
		<!-- <script id='feederLoadScript' type='text/javascript' src='./Data for Testing/testFeeder.js'></script> -->
		<!-- <script id='feederLoadScript' type='text/javascript' src='./Data for Testing/testFeeder Largest.js'></script> -->
		<!-- <script id='feederLoadScript' type='text/javascript' src='./Data for Testing/testFeeder Norfork.js'></script> -->
	</head>
    <body>
        <div id="interfaceContainer">
            <div id="loadingMessage">
                <p style="font-size:60pt; text-align:center; width:100%;">Feeder Loading...</p>
            </div>
            <div id="descriptionTables" class="floatingTables"></div>
            <div id="selectionTable" class="floatingTables"></div>
            <!-- Controls -->
            <div style="top:55px; line-height:25px" class="divButton" onclick="window.panZoom.zoomIn()" title="Zoom In">+</div>
            <div style="top:95px;" class="divButton" onclick="window.panZoom.zoomOut()" title="Zoom Out">-</div>
            <div style="top:135px;" class="divButton" onclick="window.panZoom.reset()" title="Reset Zoom">R</div>
            <div id="scaleButton" class="divButton" title="Scale To">S</div>
            <!-- <div style='background:navy; top:215px; left:5px' id='saveLink' class='divButton' onclick='saveSvg()' title='Save File' download>S</div> -->
            <!-- Menu Bar -->
            <div id="header">
                <div id="menuLeft" class="white">
                    <h4>{{thisFeederName}}</h4>
                    <p>from "{{thisModelName}}"</p>
                </div>
                <div id="menuRight">
                    <h4 style="padding: 5px; margin-right: 15px;"><a id="helpButton" class="white" href="https://github.com/dpinney/omf/wiki/Tools-~-gridEdit" target="_blank">Help</a></h4>
                    <div class="headerGroup">
                        <h4 class="menuHeading white">Edit &#x25BE</h4>
                        <ul id="editMenu" class="menu" style="display: none;">
                        {% if showFileMenu %}
                            <li data-web="ami" class="not4dss">Add AMI Profiles...</li>
                            <li data-web="anonymize" class="not4dss">Anonymization...</li>
                            <li>Attachments...</li>
                            <li data-web="climate" class="not4dss">Climate...</li>
                            <li>Find...</li>
                            <li>Mass add...</li>
                            <li>Mass edit...</li>
                            <li data-web="scada" class="not4dss">Scada Loadshapes...</li>
                            <li class="not4dss">Static loads to houses</li>
                            <li data-web="zillowHouse" class="not4dss">Static loads to Zillow houses</li>
                            <li>Change opacity...</li>
                            <li>Color circuit...</li>
                        {% else %}
                            <li>Attachments...</li>
                            <li>Find...</li>
                            <li>Mass add...</li>
                            <li>Mass edit...</li>
                            <li class="not4dss">Static loads to houses</li>
                            <li>Change opacity...</li>
                            <li>Color circuit...</li>
                        {% endif %}
                        </ul>
                    </div>
                    <div class="headerGroup">
                        <h4 class="menuHeading white">Add &#x25BE;</h4>
                        <ul id="componentList" class="menu" style="display:none;"></ul>
                    </div>
                    <div class="headerGroup">
                        <h4 class="menuHeading white">File &#x25BE</h4>
                        <ul id="fileMenu" class="menu" style="display: none">
                            {% if showFileMenu %}
                            <li data-web="save">Save</li>
                            <li>View raw data</li>
                            <li data-web="rename">Rename</li>
                            <li data-web="load" class="not4dss">Load from model...</li>
                            <li data-web="new" class="not4dss">New blank feeder...</li>
                            <li data-web="windmil" class="not4dss">Windmil conversion...</li>
                            <li data-web="gridlabd" class="not4dss">GridLAB-D conversion...</li>
                            <li data-web="cyme" class="not4dss">CYMDIST conversion...</li>
                            <li data-web="opendss" class="not4gridlabd">OpenDSS conversion...</li>
                            <li data-web="map">View on map</li>
                            {% else %}
                            <li>View raw data</li>
                            <li data-web="map">View on map</li>
                            {% endif %}
                        </ul>
                    </div>
                </div>
            </div>
            <!-- Svg container -->
            <div id="svgContainerWrapper" style="height: auto;">
                <svg id="svgContainer" xmlns="http://www.w3.org/2000/svg"></svg>
            </div>
            <!-- Modals -->
            <div id="findModal" class="modal" style="display: none">
                <div class="modalContent">
                    <table>
                        <tr>
                            <td><input id="searchInput" type="text" value="Enter a term" class="modalInput"></td>
                            <td id="searchCount"></td>
                        </tr>
                        <tr><td><input checked id="searchExactString" type="radio" name="searchMode" value="searchExactString">Exact match</td></tr>
                        <tr><td><input id="searchSubstring" type="radio" name="searchMode" value="searchSubstring">Includes term</td></tr>
                        <tr>
                            <td>Key of current object:</td>
                            <td id="foundElementKey"></td>
                        </tr>
                        <tr><td><input type="checkbox" id="showTableOnFind">Show table on view</td></tr>
                        <tr>
                            <td>
                                <button id="findPrevious">Previous</button>
                                <button id="findNext">Next</button>
                            </td>
                        </tr>
                    </table>
                    <div class="modalContentButtons">
                        <button data-buttonfunction="toggle">Close</button>
                    </div>
                </div>
            </div>
            <div id="progressModal" class="modal" style="display: none">
                <div class="modalContent centered">
                    <img src="/static/spinner.gif">
                    <div class='progressModalMessages'></div>
                    <button class="deleteButton" data-buttonfunction="cancel" style="margin-right:300px;">Cancel</button>
                    <button data-buttonfunction="submit">OK</button>
                    </div>
                </div>
            </div>
            {% if showFileMenu %}
            <div id="loadModal" class="modal" style="display: none">
                <div class="modalContent">
                    <div id="feederListFlex">
                        <div>
                            <h3>Public Feeders</h3>
                            <ul id="publicFeederList" class="scrollableList"></ul>
                        </div>
                        <div>
                            <h3>My Feeders</h3>
                            <ul id="userFeederList" class="scrollableList"></ul>
                        </div>
                    </div>
                    <div class="modalContentButtons">
                        <button data-buttonfunction="toggle">Close</button>
                    </div>
                </div>
            </div>
            <div id="blankFeederModal" class="modal" style="display: none">
                <div class="modalContent">
                    <!--{{thisOwner}} is correct because this form is supposed to replace THIS feeder with a new blank one-->
                    <form onsubmit="submitForm({formId:'blankFeederForm'}); return false;" action="/newBlankFeeder/{{thisOwner}}" id="blankFeederForm">
                        <input type="hidden" name="_csrf_token" value="{{csrf_token()}}"/>
                        <input type="hidden" id="feederNum" name="feederNum" value="{{thisFeederNum}}"/>
                        <input type="hidden" id="modelName" name="modelName" value="{{thisModelName}}"/>
                        <input type="hidden" name="referrer" value="distribution"/>
                        <table>
                            <tbody>
                                <tr><th colspan="2">New Blank Feeder</th></tr>
                                <tr>
                                    <td><label for="blankFeederInput">Name</label></td>
                                    <td>
                                        <!-- TODO: add better validation than just the "required" attribute-->
                                        <input type="text" required id="blankFeederInput" name="feederNameNew" class="modalInput"/>
                                    </td>
                                </tr>
                            </tbody>
                        </table>
                        <div class="modalContentButtons">
                            <button type="button" data-buttonfunction="toggle">Close</button>
                            <button type="submit">Create</button>
                        </div>
                    </form>
                </div>
            </div>
            <div id="milsoftModal" class="modal" style="display: none">
                <div class="modalContent">
                    <!--I assume this is supposed to replace THIS feeder with the milsoft upload. Therefore, uniqObjName with {{thisOwner}} is correct.-->
                    <form onsubmit="submitForm({formId:'milsoftForm', pollUrl:'/checkConversion/{{thisModelName}}/{{thisOwner}}', inputId:'milsoftInput'}); return false;"
                    action="/milsoftImport/{{thisOwner}}" id="milsoftForm">
                        <input type="hidden" name="_csrf_token" value="{{csrf_token()}}"/>
                        <input type="hidden" id="feederNum" name="feederNum" value="{{thisFeederNum}}"/>
                        <input type="hidden" id="modelName" name="modelName" value="{{thisModelName}}"/>
                        <table>
                            <tbody>
                                <tr><th colspan="2">Milsoft Conversion</th></tr>
                                <tr>
                                    <td><label for="milsoftInput">Name</label></td>
                                    <td>
                                        <!-- TODO: add better validation than just the "required" attribute-->
                                        <input type="text" required id="milsoftInput" name="feederNameM" class="modalInput"/>
                                    </td>
                                </tr>
                                <tr>
                                    <td>Data File (.std)</td>
                                    <td><input type="file" required id="stdFile" name="stdFile" accept=".std" class="modalInput"/></td>
                                </tr>
                                <tr>
                                    <td>Equipment File (.seq)</td>
                                    <td><input type="file" required id="seqFile" name="seqFile" accept=".seq" class="modalInput"/></td>
                                </tr>
                            </tbody>
                        </table> 
                        <div class="modalContentButtons">
                            <button type="button" data-buttonfunction="toggle">Close</button>
                            <button type="submit">Import</button>
                        </div>
                    </form>
                </div> 
            </div>
            <div id="opendssModal" class="modal" style="display: none">
                <div class="modalContent">
                    <!--I assume this is supposed to replace THIS feeder with the gridlabd upload. Therefore, uniqObjName with {{thisOwner}} is correct.-->
                    <form onsubmit="submitForm({formId:'opendssForm', pollUrl:'/checkConversion/{{thisModelName}}/{{thisOwner}}', inputId:'feederNameOpendss'}); return false;"
                    action="/opendssImport/{{thisOwner}}" id="opendssForm">
                        <input type="hidden" name="_csrf_token" value="{{csrf_token()}}"/>
                        <input type="hidden" id="feederNum" name="feederNum" value="{{thisFeederNum}}"/>
                        <input type="hidden" id="modelName" name="modelName" value="{{thisModelName}}"/>
                        <table>
                            <tbody>
                                <tr><th colspan="2">OpenDSS Conversion</th></tr>
                                <tr>
                                    <td><label for="feederNameOpendss">Circuit Name</label></td>
                                    <td>
                                        <!-- TODO: add better validation than just the "required" attribute-->
                                        <input type="text" required id="feederNameOpendss" name="feederNameOpendss" class="modalInput"/>
                                    </td>
                                </tr>
                                <tr>
                                    <td>Data File (.dss)</td>
                                    <td><input type="file" required id="dssFile" name="dssFile" accept=".dss" class="modalInput"/></td>
                                </tr>
                            </tbody>
                        </table>
                        <div class="modalContentButtons">
                            <button type="button" data-buttonfunction="toggle">Close</button>
                            <button type="submit">Import</button>
                        </div>
                    </form>
                </div>
            </div>
            <div id="gridlabdModal" class="modal" style="display: none">
                <div class="modalContent">
                    <!--I assume this is supposed to replace THIS feeder with the gridlabd upload. Therefore, uniqObjName with {{thisOwner}} is correct.-->
                    <form onsubmit="submitForm({formId:'gridlabdForm', pollUrl:'/checkConversion/{{thisModelName}}/{{thisOwner}}', inputId:'gridlabdInput'}); return false;"
                    action="/gridlabdImport/{{thisOwner}}" id="gridlabdForm">
                        <input type="hidden" name="_csrf_token" value="{{csrf_token()}}"/>
                        <input type="hidden" id="feederNum" name="feederNum" value="{{thisFeederNum}}"/>
                        <input type="hidden" id="modelName" name="modelName" value="{{thisModelName}}"/>
                        <table>
                            <tbody>
                                <tr><th colspan="2">GridLab-D Conversion</th></tr>
                                <tr>
                                    <td><label for="gridlabdInput">Name</label></td>
                                    <td>
                                        <!-- TODO: add better validation than just the "required" attribute-->
                                        <input type="text" required id="gridlabdInput" name="feederNameG" class="modalInput"/>
                                    </td>
                                </tr>
                                <tr>
                                    <td>Data File (.glm)</td>
                                    <td><input type="file" required id="csvFile" name="glmFile" accept=".glm" class="modalInput"/></td>
                                </tr>
                            </tbody>
                        </table>
                        <div class="modalContentButtons">
                            <button type="button" data-buttonfunction="toggle">Close</button>
                            <button type="submit">Import</button>
                        </div>
                    </form>
                </div>
            </div>
            <div id="cymeModal" class="modal" style="display: none">
                <div class="modalContent">
                    <!--I assume this is supposed to replace THIS feeder with the cyme upload. Therefore, uniqObjName with {{thisOwner}} is correct.-->
                    <form onsubmit="submitForm({formId:'cymeForm', pollUrl:'/checkConversion/{{thisModelName}}/{{thisOwner}}', inputId:'cymeInput'}); return false;"
                    action="/cymeImport/{{thisOwner}}" id="cymeForm">
                        <input type="hidden" name="_csrf_token" value="{{csrf_token()}}"/>
                        <input type="hidden" id="feederNum" name="feederNum" value="{{thisFeederNum}}"/>
                        <input type="hidden" id="modelName" name="modelName" value="{{thisModelName}}"/>
                        <table>
                            <tbody>
                                <tr><th colspan="2">Cyme Conversion</th></tr>
                                <tr>
                                    <td><label for="cymeInput">Name</label></td>
                                    <td>
                                        <!-- TODO: add better validation than just the "required" attribute-->
                                        <input type="text" required id="cymeInput" name="feederNameC" class="modalInput"/>
                                    </td>
                                </tr>
                                <tr>
                                    <td>Network File (.mdb)</td>
                                    <td><input type="file" required id="mdbNetFile" name="mdbNetFile" accept=".mdb" class="modalInput"/></td>
                                </tr>
                            </tbody>
                        </table>
                        <div class="modalContentButtons">
                            <button type="button" data-buttonfunction="toggle">Close</button>
                            <button type="submit">Import</button>
                        </div>
                    </form>
                </div>
            </div>
            <div id="scadaModal" class="modal" style="display: none">
                <div class="modalContent">
                    <!--I assume this is supposed to update THIS feeder with the scada loadshape. Therefore, uniqObjName with {{thisOwner}} is correct.-->
                    <form onsubmit="submitForm({formId:'scadaForm', pollUrl:'/checkConversion/{{thisModelName}}/{{thisOwner}}'}); return false;"
                    action="/scadaLoadshape/{{thisOwner}}/{{thisFeederName}}" id="scadaForm">
                        <input type="hidden" name="_csrf_token" value="{{csrf_token()}}"/>
                        <input type="hidden" id="feederNum" name="feederNum" value="{{thisFeederNum}}"/>
                        <input type="hidden" id="modelName" name="modelName" value="{{thisModelName}}"/>
                        <table>
                            <tbody>
                                <tr>
                                    <th class="leftText">Scada Loadshapes</th>
                                    <th class="right"><a href="https://github.com/dpinney/omf/wiki/Tools-~-gridEdit#scada-loadshapes" target="_blank">Format Help</a></th>
                                </tr>
                                <tr>
                                    <td>File containing Scada load data (.csv)</td>
                                    <td><input type="file" required id="scadaFile" name="scadaFile" accept=".csv" class="modalInput"/></td>
                                </tr>
                                <tr><td colspan="100%">Note: Model "Simulation Start Date" should lie within the Scada load"s dates.</td></tr>
                            </tbody>
                        </table>
                        <div class="modalContentButtons">
                            <button type="button" data-buttonfunction="toggle">Close</button>
                            <button type="submit">Import</button>
                        </div>
                    </form>
                </div>
            </div>
            <div id="amiModal" class="modal" style="display: none">
                <div class="modalContent">
                    <!--I assume this is supposed to replace THIS feeder with the ami modeling. Therefore, uniqObjName with {{thisOwner}} is correct.-->
                    <form onsubmit="submitForm({formId:'amiForm', pollUrl:'/checkConversion/{{thisModelName}}/{{thisOwner}}'}); return false;"
                    action="/loadModelingAmi/{{thisOwner}}/{{thisFeederName}}" id="amiForm">
                        <input type="hidden" name="_csrf_token" value="{{csrf_token()}}"/>
                        <input type="hidden" id="feederNum" name="feederNum" value="{{thisFeederNum}}"/>
                        <input type="hidden" id="modelName" name="modelName" value="{{thisModelName}}"/>
                        <!--<input type="hidden" name="referrer" value="distribution"/>-->
                        <table>
                            <tbody>
                                <tr>
                                    <th class="leftText">AMI Profiles</th>
                                    <th class="right"><a href="https://github.com/dpinney/omf/wiki/Tools-~-gridEdit" target="_blank">Format Help</a></th>
                                </tr>
                                <tr>
                                    <td>File containing AMI load data (.csv)</td>
                                    <td><input type="file" required id="amiFile" name="amiFile" accept=".csv" class="modalInput"/></td>
                                </tr>
                                <tr>
                                    <td colspan="100%">Note: Model "Simulation Start Date" should lie within the AMI profiles"s dates.</td>
                                </tr>

                            </tbody>
                        </table>
                        <div class="modalContentButtons">
                            <button type="button" data-buttonfunction="toggle">Close</button>
                            <button type="submit">Import</button>
                        </div>
                    </form>
                </div>
            </div>
            <div id="climateModal" class="modal" style="display: none">
                <div class="modalContent">
                    <!--I assume this is supposed to update THIS feeder with the climate data. Therefore, uniqObjName with {{thisOwner}} is correct.-->
                    <form onsubmit="if (validateClimateModal()) { submitForm({formId:'climateForm', pollUrl:'/checkConversion/{{thisModelName}}/{{thisOwner}}'}) } return false;"
                    action="/climateChange/{{thisOwner}}/{{thisFeederName}}" id="climateForm">
                        <input type="hidden" name="_csrf_token" value="{{csrf_token()}}"/>
                        <!--<input type="hidden" id="feederNum" name="feederNum" value="{{thisFeederNum}}"/>-->
                        <input type="hidden" id="modelName" name="modelName" value="{{thisModelName}}"/>
                        <table>
                            <tbody>
                                <tr><th colspan="2">Climate Change</th></tr>
                                <tr>
                                    <td>
                                        <input id="USCRNImport" type="radio" name="climateImportOption" value="USCRNImport">
                                        <label for="USCRNImport">USCRN import</label>
                                    </td>
                                </tr>
                                <tr>
                                    <td><label for="uscrnYear">Year</label></td>
                                    <td><select id="uscrnYear" name="uscrnYear"></select></td>
                                </tr>
                                <tr>
                                    <td><label for="uscrnStation">Station</label></td>
                                    <td><select id="uscrnStation" name="uscrnStation"></select></td>
                                </tr>
                                <tr>
                                    <td>
                                        <input id="tmyImport" type="radio" name="climateImportOption" value="tmyImport">
                                        <label for="tmyImport">tmy import</label>
                                    </td>
                                </tr>
                                <tr>
                                    <td><label for="zipCode">ZIP Code:</label></td>
                                    <td><input id="zipCode" type="text" name="zipCode" pattern="\d+" minlength=5 maxlength=5 class="modalInput"></td>
                                </tr>
                            </tbody>
                        </table>
                        <div class="modalContentButtons">
                            <button type="button" data-buttonfunction="toggle">Close</button>
                            <button type="submit">Apply</button>
                        </div>
                    </form>
                </div>
            </div>
            <div id="anonymizeModal" class="modal" style="display: none">
                <div class="modalContent">
                    <!--I assume this is supposed to anonymize THIS feeder. Therefore, uniqObjName with {{thisOwner}} is correct.-->
                    <form onsubmit="submitForm({formId:'anonymizeForm', pollUrl:'/checkConversion/{{thisModelName}}/{{thisOwner}}'}); return false;" action="/anonymize/{{thisOwner}}/{{thisFeederName}}" id="anonymizeForm">
                        <input type="hidden" name="_csrf_token" value="{{csrf_token()}}"/>
                        <!--<input type="hidden" id="feederNum" name="feederNum" value="{{thisFeederNum}}"/>-->
                        <input type="hidden" id="modelName" name="modelName" value="{{thisModelName}}"/>
                        <table>
                            <tbody>
                                <tr><th>Anonymization</th></tr>
                                <tr><th class="leftText">Names and labels:</th></tr>
                                <tr>
                                    <td>
                                        <select name="anonymizeNameOption">
                                            <option value="noChange">No change</option>
                                            <option value="pseudonymize">Pseudonymize</option>
                                            <option value="randomize">Randomize</option>
                                        </select>
                                    </td>
                                </tr>
                                <tr><th class="leftText">Locations:</th></tr>
                                <tr>
                                    <td>
                                        <input type="radio" id="noChange" name="anonymizeLocationOption" value="noChange" checked>
                                        <label for="noChange">No Change</label>
                                    </td>
                                </tr>
                                <tr>
                                    <td>
                                        <input type="radio" id="randomize" name="anonymizeLocationOption" value="randomize">
                                        <label for="randomize">Randomize</label>
                                    </td>
                                </tr>
                                <tr>
                                    <td>
                                        <input type="radio" id="forceLayout" name="anonymizeLocationOption" value="forceLayout">
                                        <label for="forceLayout">Force Layout</label>
                                    </td>
                                </tr>
                                <tr>
                                    <td>
                                        <input type="radio" id="translation" name="anonymizeLocationOption" value="translation">
                                        <label for="translation">Translate</label>
                                    </td>
                                </tr>
                                <tr><td><input type="text" pattern="^[+-]?\d+(\.\d+)?$" name="translateRight" class="modalInputLine"> [ft] to the right and</td></tr>
                                <tr><td><input type="text" pattern="^[+-]?\d+(\.\d+)?$" name="translateUp" class="modalInputLine"> [ft] up with a</td></tr>
                                <tr><td><input type="text" pattern="^[+-]?\d+(\.\d+)?$" name="rotate" class="modalInputLine"> [degree] rotation.</td></tr>
                                <tr><th class="leftText">Electrical properties:</th></tr>
                                <tr>
                                    <td>
                                        <input type="checkbox" id="modifyLengthSize" name="modifyLengthSize" value="modifyLengthSize">
                                        <label for="modifyLengthSize">Modify conductor length and cable size</label>
                                    </td>
                                </tr>
                                <tr>
                                    <td>
                                        <input type="checkbox" id="smoothLoadGen" name="smoothLoadGen" value="smoothLoadGen">
                                        <label for="smoothLoadGen">Smooth AMI Loadshapes</label>
                                    </td>
                                </tr>
                                <tr>
                                    <td>
                                        <input type="checkbox" id="shuffleLoadGen" name="shuffleLoadGen" value="shuffleLoadGen">
                                        <label for="shuffleLoadGen">Shuffle loads and generators:</label>
                                        <!--<input type="text" name="shufflePerc" class="modalInputLine"> [%]</label>-->
                                        <!--Commented both of these out because I think the server expects a fractional decimal number-->
                                        <input type="text" pattern="^[+-]?\d+(\.\d+)?$" name="shufflePerc" class="modalInputLine"> [%]</label>
                                    </td>
                                </tr>
                                <tr>
                                    <td>
                                        <input type="checkbox" id="addNoise" name="addNoise" value="addNoise">
                                        <label for="addNoise">Add noise:</label>
                                        <!--<input type="text" name="noisePerc" class="modalInputLine"> [%]</label>-->
                                        <input type="text" pattern="^[+-]?\d+(\.\d+)?$" name="noisePerc" class="modalInputLine"> [%]</label>
                                    </td>
                                </tr>
                            </tbody>
                        </table>
                        <div class="modalContentButtons">
                            <button type="button" data-buttonfunction="toggle">Close</button>
                            <button type="submit">Apply</button>
                        </div>
                    </form>
                </div>
            </div>
            {% endif %}
            <div id="massAddModal" class="modal" style="display: none">
                <div class="modalContent">
                    <table>
                        <tbody>
                            <tr><th colspan="2">Mass Add</th></tr>
                            <tr>
                                <td>Add component:</td>
                                <td><select id="massAddComponentSelect"></select></td>
                            </tr>
                            <tr>
                                <td>To each:</td>
                                <td><select id="massAddTargetSelect"></select></td>
                            </tr>
                            <tr>
                                <td>With probability for each attachment (float between 0.0 and 1.0):</td>
                                <td><input type="text" value="1.0" class="modalInput"/></td>
                            </tr>

                        </tbody>
                    </table>
                    <div class="modalContentButtons">
                        <button data-buttonfunction="cancel">Close</button>
                        <button data-buttonfunction="submit">Apply</button>
                    </div>
                </div>
            </div>
            <div id="massAddSecondaryModal" class="modal" style="display: none;">
                <div class="modalContent">
                    <h3></h3>
                    <!--<div id="componentTable" data-tableinsert></div>-->
                    <div class="scrollableList" data-tableinsert></div>
                    <!--<div style="text-align:center; padding: 10px;">-->
                    <div class="modalContentButtons">
                        <button data-buttonfunction="cancel">Close</button>
                    </div>
                </div>
            </div>
            <div id="massEditModal" class="modal" style="display: none">
                <div class="modalContent">
                    <table>
                        <tbody>
                            <tr><th colspan="4">Mass Edit</th></tr>
                            <tr>
                                <td>For each object of type</td>
                                <td><select id="massEditTargetSelect"></select></td>
                                <td>with attribute</td>
                                <td><input type="text" id="massEditAttribute" class="modalInput"></td>
                            </tr>
                            <tr>
                                <td><input type="radio" name="attributeOperation" value="addTo">Add value to attribute</td>
                                <td><input type="text" id="addToValue" pattern="^0\.\d+|1(\.0+)?$" class="modalInput"/></td>
                            </tr>
                            <tr>
                                <td><input type="radio" name="attributeOperation" value="delete">Delete Attribute</td>
                            </tr>
                            <tr>
                                <td><input type="radio" name="attributeOperation" value="change">Change attribute to</td>
                                <td><input type="text" id="changeValue" pattern="^0\.\d+|1(\.0+)?$" class="modalInput"/></td>
                            </tr>
                            </tr>
                            <tr>		
                                <td><input type="radio" name="attributeOperation" value="multiplyBy">Multiply attribute by</td>
                                <td><input type="text" id="multiplyValue" pattern="^0\.\d+|1(\.0+)?$" class="modalInput"/></td>
                                <td style="text-align: center" >and add</td>
                                <td><input type="text" id="andAddValue" pattern="^0\.\d+|1(\.0+)?$" class="modalInput"/></td>
                            </tr>
                            <tr><td>Or</td></tr>
                            <tr>
                                <td><input type="radio" name="attributeOperation" value="addAttribute"> Add new attribute</td>
                                <td><input type="text" id="newAttributeKey" class="modalInput"></td>
                                <td style="text-align: center">with value</td>
                                <td><input type="text" id="newAttributeValue" pattern="^0\.\d+|1(\.0+)?$" class="modalInput"/></td>
                            </tr>
                        </tbody>
                    </table>
                    <div class="modalContentButtons">
                        <button data-buttonfunction="toggle">Close</button>
                        <button onclick="massEdit();">Apply</button>
                    </div>
                </div>
            </div>
            <div id="attachmentsModal" class="modal" style="display: none">
                <div class="modalContent">
                    <table>
                        <tbody>
                            <tr><th colspan="2">Attachments</th></tr>
                            <tr><td><select id="attachmentSelect"></select></td></tr>
                        </tbody>
                    </table>
                    <div class="modalContentButtons">
                        <button data-buttonfunction="toggle">Close</button>
                        <button data-buttonfunction="toggle" onclick="editAttachment()">Select</button>
                    </div>
                </div>
            </div>
            <div id="editAttachmentModal" class="modal" style="display: none">
                <div class="modalContent">
                    <table>
                        <tbody>
                            <tr><td id="attachmentTd"></td></tr>
                            <tr><td><textarea rows="25" cols="80" id="editAttachmentBox"></textarea></td></tr>
                        </tbody>
                    </table>
                    <div class="modalContentButtons">
                        <button data-buttonfunction="toggle">Close</button>
                        <button data-buttonfunction="toggle" onclick="saveAttachment();">Save</button>
                    </div>
                </div>
            </div>
            <div id="opacityModal" class="modal" style="display: none">
                <div class="modalContent">
                    <div class="scrollableList" data-tableinsert></div>
                    <div class="modalContentButtons">
                        <button data-buttonfunction="toggle">Close</button>
                        <button onclick="gOpacityManager.reset();">Reset</button>
                    </div>
                </div>
            </div>
            <div id="colorModal" class="modal" style="display: none">
                <div class="centered modalContent">
                    <h3>Color Circuit</h3>
                    <div class="fullPadded"><input type="file" multiple accept=".csv" class="modalInput"></div>
                    <div class="scrollableList leftText fullPadded" data-tableinsert></div>
                    <div class="modalContentButtons">
                        <button data-buttonfunction="toggle">Close</button>
                        <button data-buttonfunction="reset">Reset</button>
                    </div>
                </div>
            </div>
            <div id="colorLegends" class="floatingTables"></div>
            <!--Modals-->
        </div>
	</body>
</html>
<script id="feederInsert">let gReadFeeder = {% if thisFeederData %}{{ thisFeederData | safe }}{% else %}null{% endif %}; 
</script>
<style id="jqueryCssInsert">
</style>
<script id="jqueryInsert">
</script>
<script id="jqueryUiInsert">
</script>
<script id="panZoomInsert">
</script>
<script id="chromaInsert">
</script>
<script id="papaParseInsert">
</script>
<script type="text/javascript">
    /**
     * Need to do browser detection in a separate script because IE won't do anything inside of a <script><\/script> if there are syntax errors. If
     * the user agent contains "Trident" or "MSIE", it is very likely that the browser is Internet Explorer. Warn the user to switch browsers if they
     * are using internet explorer.
     */
    function couldBeInternetExplorer() {
        var keys = ["trident", "msie"],
            idx = keys.length - 1,
            userAgent = navigator.userAgent.toLowerCase();
        for (idx; idx > -1 && userAgent.indexOf(keys[idx]) === -1; idx--);
        return idx === -1 ? false : true;
    }
    if (couldBeInternetExplorer()) {
        alert("This interface is not supported in any version of Internet Explorer. Please switch to a supported browser, such as an updated version of Firefox or Chrome.")
    }
</script>
<script type="text/javascript">
//**************************************************
// global variables
//**************************************************

"use strict";
let gThisFeederName = "{% if thisFeederName %}{{ thisFeederName | safe }}{% else %}null{% endif %}";
const gThisFeederNum = {% if thisFeederNum %}{{ thisFeederNum | safe }}{% else %}null{% endif %}; 
let gThisModelName = "{% if thisModelName %}{{ thisModelName | safe }}{% else %}null{% endif %}"; 
const gThisOwner = "{% if thisOwner %}{{ thisOwner | safe }}{% else %}null{% endif %}"; 
const gCurrentUser = "{% if currentUser %}{{ currentUser | safe }}{% else %}null{% endif %}"
const gPublicFeeders = {% if publicFeeders %}{{ publicFeeders | safe }}{% else %}null{% endif %};
const gUserFeeders = {% if userFeeders %}{{ userFeeders | safe }}{% else %}null{% endif %}; 
const gWriteFeeder = deepCopy(gReadFeeder);
let gTree; // A wrapper around the gWriteFeeder.tree data structure. Has methods for accessing and modifying the data.
let gComponentManager; // A wrapper around all component.json objects.
let gSelection;
let gViewport; 
let gOpacityManager;
let gAddManager;
let gMinLon; // The minimum longitude found among all the gWriteFeeder.tree objects. Used to transform and flip how the graph is drawn.
let gMaxLat; // The maximum latitude found among all the gWriteFeeder.tree objects. Used to transform and flip how the graph is drawn.
let gDrawScaleFactor; // A number that scales all graph data to fit within a 1000 x 1000 viewport size so the graph draws nicely.
let gDownX;
let gDownY;
const gViridisColors = ["#440154FF", "#481567FF", "#482677FF", "#453781FF", "#404788FF", "#39568CFF", "#33638DFF", "#2D708EFF", "#287D8EFF", "#238A8DFF", "#1F968BFF", "#20A387FF", "#29AF7FFF", "#3CBB75FF", "#55C667FF", "#73D055FF", "#95D840FF", "#B8DE29FF", "#DCE319FF", "#FDE725FF"];
let gScaleLevel = 1.0; // Scale that all SVG objects are drawn at

// HACK: Hide anything that doesn't work with openDSS
{% if dssSchema %}
document.querySelectorAll('.not4dss').forEach(function(el) {
   el.style.display = 'none';
});
{% endif %}

//**************************************************
// Tree class
//**************************************************

const treePrototype = {

    /* Public methods */

    /**
     * tested.
     */
    insert(treeObject) {
        this.tree[treeObject.key] = treeObject.data;
        this.treeMap.add(treeObject.key);
    },

    /**
     * Replace an existing node in the tree with a copy of the component argument.
     * 
     * @param {string} key - the key of the existing object to replace.
     * @param {Object} component - the component from which to make a copy to insert into the tree.
     */
    replaceNode(key, component) {
        if (!isNumberString(key)) throw new Error("The key was not a string with a number value.");
        component = deepCopy(component);
        const component_relationship = getRelationship(component);
        const oldObject = this.getObject(key);
        const oldObject_relationship = getRelationship(oldObject);
        if (component_relationship === "line") throw new Error("The replacement component is not a node.");
        if (oldObject_relationship === "line") throw new Error(`The object with the key \"${key}\" is not a node.`);
        if (component_relationship === "configurationNode") {
            if (oldObject_relationship !== "configurationNode") {
                throw new Error("Configuration nodes cannot be used to replace non-configuration nodes.");
            }
        } else {
            component.name = component.object + key;
        }
        component.latitude = oldObject.latitude;
        component.longitude = oldObject.longitude;
        if (oldObject.parent == null) {
            delete component.parent;
        } else {
            component.parent = oldObject.parent;
        }
        const children = this.treeMap.getChildKeys(key);
        if (children != null) children.forEach(key => { this.getObject(key).parent = component.name; });
        const lines = this.treeMap.getLineKeys(key);
        if (lines != null) {
            lines.forEach(key => {
                const line = this.getObject(key);
                if (line.to === oldObject.name) {
                    line.to = component.name;
                }
                if (line.from === oldObject.name) {
                    line.from = component.name;
                }
            });
        }
        this.treeMap.remove([key]);
        this.tree[key] = component;
        this.treeMap.add(key);
    },

    /** 
     * tested.
     */
    isRemovable(key) {
        this.getObject(key);
        const children = this.treeMap.getChildKeys(key);
        if (children != null) return false;
        const lines = this.treeMap.getLineKeys(key);
        if (lines != null) return false;
        return true;
    },

    /**
     * not tested.
     * @param {Array} keys
     */
    remove(keys) {
        this.treeMap.remove(keys);
        keys.forEach(key => {
            this.getObject(key);
            delete this.tree[key];
        });
    },

    /** 
     * tested.
     * Return an array of keys that need to be deleted as a result of deleting a tree object.
     * 
     * @param {string} key - the key of the tree object for which to find its deletable subtree.
     * @param {Array} visited - contains keys of tree objects that have already been visited so the method dosen't * recurse infinitely in case of a cycle.
     * @return {Array}
     */
    getSubtreeToRemove(key, visited = []) {
        if (!Array.isArray(visited)) throw new Error("Visited argument must be an array");
        visited.push(key);
        const keySet = new Set();
        const lines = this.treeMap.getLineKeys(key);
        const children = this.treeMap.getChildKeys(key);
        if (lines != null) lines.forEach(key => keySet.add(key));
        if (children != null) children.forEach(key => keySet.add(key));
        keySet.forEach(outerKey => {
            if (!visited.includes(outerKey)) {
                this.getSubtreeToRemove(outerKey, visited).forEach(innerKey => keySet.add(innerKey));
            }
        });
        return Array.from(keySet);
    },

    /**
     * tested.
     */
    getObject(key) {
        const obj = this.tree[key];
        if (obj == null) throw new Error(`The object with the key "${key}" does not exist in the tree.`);
        return this.tree[key];
    },

    /**
     * not tested. 
     */
    getParent(childKey) {
        const parentKey = this.treeMap.getParentKey(childKey);
        if (parentKey == null) return;
        return this.getObject(parentKey);
    },

    /**
     * not tested.
     */
    getToNodeKey(lineKey) {
        const sourceName = this.tree[lineKey].to;
        if (sourceName == null) return;
        let key;
        try {
            key = this.treeMap.getKey(sourceName);
        } catch (e) {
            console.error(`The line object named "${this.getObject(lineKey).name}" has a nonexistent source node named "${sourceName}". The line was not drawn.`);
        }
        return key;
    },

    /**
     * not tested.
     */
    getToNode(lineKey) {
        const sourceKey = this.getToNodeKey(lineKey);
        if (sourceKey == null) return;
        return this.getObject(sourceKey);
    },

    /**
     * not tested.
     */
    getFromNodeKey(lineKey) {
        const targetName = this.tree[lineKey].from;
        if (targetName == null) return;
        let key;
        try {
            key = this.treeMap.getKey(targetName);
        } catch (e) {
            console.error(`The line object named "${this.getObject(lineKey).name}" has a nonexistent target node named "${targetName}". The line was not drawn.`);
        }
        return key;
    },

    /**
     * not tested.
     */
    getFromNode(lineKey) {
        const targetKey = this.getFromNodeKey(lineKey);
        if (targetKey == null) return;
        return this.getObject(targetKey);
    },

    /**
     * not tested.
     */
    getPairedNodeKeys(nodeKey) {
        const pairedNodes = [];
        const lineKeys = this.treeMap.getLineKeys(nodeKey);
        if (lineKeys == null) return;
        lineKeys.forEach(key => {
            if (this.getToNodeKey(key) === nodeKey) {
                pairedNodes.push(this.getFromNodeKey(key));
            } else {
                pairedNodes.push(this.getToNodeKey(key));
            }
        });
        return pairedNodes;
    }
    /* Private methods */
};

/**
* tested.
*/
function createTree(tree = {}) {
    const invalidKeys = [];
    const invalidCoordinateKeys = [];
    Object.keys(tree).forEach(key => {
        if (!isNumberString(key)) invalidKeys.push(key);
        ["longitude", "latitude"].forEach(prop => {
            if (tree[key][prop] != null) {
                if (isNumberString(tree[key][prop])) {
                    tree[key][prop] = parseFloat(tree[key][prop])
                } else if (typeof tree[key][prop] !== "number") {
                    invalidCoordinateKeys.push(key);
                }
            }
        });
    });
    if (invalidKeys.length !== 0) {
        throw new Error(`Interface could not be built. The following object keys aren't numbers: "${invalidKeys}".`);
    }
    if (invalidCoordinateKeys.length !== 0) {
        throw new Error(`Interface could not be built. The following object keys have objects with non-numeric longitude or latitude values: "${invalidCoordinateKeys.join(", ")}".`);
    }
    const treeWrapper = Object.create(treePrototype);
    treeWrapper.tree = tree;
    treeWrapper.treeMap = createTreeMap(tree);
    return treeWrapper;
}

//**************************************************
// TreeMap class
//**************************************************

const treeMapPrototype = {

    /* Public methods */

   /**
    * not tested.
    */
    add(key) {
        this.mapName(key);
        this.mapChild(key);
        this.mapLine(key);
    },

   /**
    * not tested.
    * @param {Array} keys
    */
    remove(keys) {
        keys.forEach(key => {
            this.unmapLine(key);
            this.unmapChild(key);
        });
        keys.forEach(key => {
            this.unmapName(key);
        });
    },

   /**
    * not tested.
    * This should throw an Error. If I provide what I believe is a valid name, I expect to get a key!
    */
    getKey(name) {
        if (name == null) {
            throw new Error(`getKey() failed. The name: "${name}" is invalid.`);
        }
        const key = this.names[name];
        if (key === undefined) {
            throw new Error(`getKey() failed. Did not find the name "${name}" in this.names.`);
        }
        return key;
    },

   /**
    * not tested.
    */
    getChildKeys(key) {
        return this.children[key];
    },

   /**
    * not tested.
    */
    getLineKeys(key) {
        return this.lines[key];
    },

   /**
    * not tested.
    */
    getParentKey(childKey) {
        const parentName = this.tree[childKey].parent;
        if (parentName === undefined) return;
        let parentKey;
        try {
            parentKey = this.getKey(parentName);
        } catch (e) {
            console.error(`The child object named "${this.tree[childKey].name}" has a nonexistent parent object named "${parentName}". The parent-child line was not drawn.`);
            return;
        }
        return parentKey;
    },

    /* Private TreeMap methods */

    /**
    * not tested.
    */
    getNodeEndKeys(lineKey) {
        const sourceName = this.tree[lineKey].to;
        const targetName = this.tree[lineKey].from;
        let sourceKey, targetKey;
        if (sourceName === undefined && targetName === undefined) return {};
        if (sourceName !== undefined && targetName !== undefined) {
            try {
                sourceKey = this.getKey(sourceName);
                targetKey = this.getKey(targetName);
            } catch(e) {
                //Commented out because this message is redundant and less helpful than other error messages
                //console.error(`The line object named "${this.tree[lineKey].name}" has nonexistent 'to' and/or 'from' nodes.`);
                return {};
            }
        } else {
            console.error(`The line object named "${this.tree[lineKey].name}" is missing a 'to' or 'from' property.`);
            return {};
        }
        return {sourceKey: sourceKey, targetKey: targetKey};
    },

   /**
    * not tested. 
    */
    mapName(key) {
        const name = this.tree[key].name;
        if (name == null) return; // TODO: Do I allow names to be null at all?
        const lowercaseName = String(name).toLowerCase();
        if (lowercaseName === "null" || lowercaseName === "undefined") return;
        this.names[name] = key;
    },

   /**
    * not tested.
    */
    unmapName(key) {
        const name = this.tree[key].name;
        if (name == null) return;
        delete this.names[name];
    },

    /**
    * not tested.
    */
    mapChild(childKey) {
        const parentKey = this.getParentKey(childKey);
        if (parentKey == null) return;
        if (this.children[parentKey] == null) {
            this.children[parentKey] = [childKey];
        } else if (!this.children[parentKey].includes(childKey)) {
            this.children[parentKey].push(childKey);
        } 
    },

   /**
    * not tested.
    */
    unmapChild(childKey) {
        const parentKey = this.getParentKey(childKey);
        if (parentKey == null) return;
        const idx = this.children[parentKey].indexOf(childKey);
        if (idx >= 0) {
            this.children[parentKey].splice(idx, 1);
            if (this.children[parentKey].length === 0) {
                delete this.children[parentKey];
            }
        } else {
            console.error(`Could not unmap child with key "${childKey}" from parent with key ${parentKey}.`);
        }
    },

   /**
    * not tested. 
    */
    mapLine(lineKey) {
        let {sourceKey, targetKey} = this.getNodeEndKeys(lineKey);
        if (sourceKey == null || targetKey == null) return;
        if (this.lines[sourceKey] == null) {
            this.lines[sourceKey] = [lineKey];
        } else if (!this.lines[sourceKey].includes(lineKey)) {
            this.lines[sourceKey].push(lineKey);
        }
        if (this.lines[targetKey] == null) {
            this.lines[targetKey] = [lineKey];
        } else if (!this.lines[targetKey].includes(lineKey)) {
            this.lines[targetKey].push(lineKey);
        }
    },

   /**
    * not tested.
    */
    unmapLine(lineKey) {
        let {sourceKey, targetKey} = this.getNodeEndKeys(lineKey);
        if (sourceKey == null || targetKey == null) return;
        [sourceKey, targetKey].forEach(key => {
            const idx = this.lines[key].indexOf(lineKey);
            if (idx >= 0) {
                this.lines[key].splice(idx, 1);
                if (this.lines[key].length === 0) {
                    delete this.lines[key];
                }
            } else {
                console.error(`Could not unmap line with key "${lineKey}" from node with key "${key}".`);
            }
        });
    },
};

/**
 * tested.
 */
function createTreeMap(tree) {
    const map = Object.create(treeMapPrototype);
    map.tree = tree;
    map.names = {};
    map.children = {};
    map.lines = {};
    //map.objectTypes = {};
    const keys = Object.keys(tree);
    keys.forEach(key => {
        map.mapName(key);
    });
    keys.forEach(key => {
        map.mapChild(key);
        map.mapLine(key);
    });
    return map;
}

//**************************************************
// ComponentManager class
//**************************************************

const componentManagerPrototype = {

    /* Public methods */

    /**
     * tested.
     */
    insert(component) {
        if (component.object == null) {
            alert(`The component ${JSON.stringify(component)} was invalid.`);
            return;
        }
        if (component.name == null) component.name = component.object;
        let objectMap = this.components[component.object];
        if (objectMap == null) {
            this.components[component.object] = {};
            objectMap = this.components[component.object];
        }
        if (objectMap[component.name] != null) {
            component.name = this.getUniqueName(objectMap, component.name);
        }
        objectMap[component.name] = component;
    },

    /**
     * @return {Array} - an array of component object type strings.
     */
    getTypes() {
        return Object.keys(this.components);
    },

    /**
     * @return {Array|undefined} - an array of component names of the specified object type, or undefined.
     */
    getNamesOfType(objectType) {
        const objects = this.components[objectType];
        return objects == null ? undefined : Object.keys(objects);
    },

    /**
     * @return {Object} - a component object.
     */
    get(objectType, name) {
        const objectMap = this.components[objectType];
        return objectMap == null ? undefined : objectMap[name];
    },

    /**
     * @return {Object} - whichever component object happens to be stored first in the object map for that object type.
     */
    getFirst(objectType) {
        const names = this.getNamesOfType(objectType);
        return names == null ? undefined : this.components[objectType][names[0]];
    },

    /* Private methods */

    getUniqueName(objectMap, name) {
        const originalName = name;
        let count = 0;
        while (objectMap[name] != null) {
            count++;
            name = `${originalName}_${count}`;
        }
        return name;
    }
}

function createComponentManager() {
    const cm = Object.create(componentManagerPrototype);
    cm.components = {};
    return cm;
}

// Insert the components into the gComponentManager
(() => {
    const components = {% if components %}{{ components | safe }}{% else %}null{% endif %};
    gComponentManager = createComponentManager();
    Object.values(components).forEach(c => {
        gComponentManager.insert(c);
    });
})();

//**************************************************
// addManager class
//**************************************************

const addManagerPrototype = {

    /* Public methods */

    /**
     * not tested.
     */ 
    massAdd() {
        const modal = createProgressModal();
        const component = this.component;
        const targetObject = this.target;
        if (component.object === 'recorder' || getRelationship(gComponentManager.getFirst(targetObject)) !== 'line') {
            const probability = this.probability;
            const newObjects = [];
            modal.clearAndAddMessage(`Adding a "${component.object}" object to every "${targetObject}" object. This could take a few seconds.`);
            setTimeout(() => {
                Object.keys(gTree.tree).forEach(key => {
                    if (gTree.getObject(key).object === targetObject && Math.random() < probability) {
                        const tObject = createTreeObject(component, gTree);
                        tObject.setupChildNode(key);
                        gTree.insert(tObject);
                        newObjects.push(tObject.key);
                    }
                });
                createSvgData(newObjects).draw(gViewport);
                modal.clearAndAddMessage(`${newObjects.length} "${component.name}" objects were added to the feeder.`);
                modal.finish();
            }, 10);
        } else {
            modal.clearAndAddMessage('Mass add failed. No object can be added as a child of a line, except for recorder objects.');
            modal.finish();
        }
    },

    /**
     * TODO: implement formatting function and test on this table.
     * @param {string} type - The type of the object to view.
     * @param {boolean} massAdd - Whether or not this is a mass add operation.
     */ 
    buildSecondaryModal(type, massAdd=false) {
        const modal = document.getElementById("massAddSecondaryModal");     
        modal.removeAttribute("style");
        const tableDiv = modal.querySelector("[data-tableinsert]");
        Array.from(tableDiv.children).forEach(child => {
            child.parentElement.removeChild(child);
        });
        modal.querySelector("h3").textContent = type;
        const table = document.createElement("table");
        const tBody = document.createElement("tbody");
        table.append(tBody);
        const that = this;
        modal.querySelector("button[data-buttonfunction='cancel']").onclick = () => {
            modal.style.display = "none";
            that.component = {};
            document.getElementById("massAddModal").querySelector("select#massAddComponentSelect").selectedIndex = 0;
        }
        alphabeticalForEach.bind(gComponentManager.getNamesOfType(type))(name => {
            const tr = document.createElement("tr");
            let td = document.createElement("td");
            tr.append(td);
            const component = gComponentManager.get(type, name);
            let button;
            if (massAdd === false) {
                button = getTableButton("Add", () => {
                    modal.style.display = "none";
                    getAddComponentFunction(component)();
                });
            } else {
                button = getTableButton("Select", () => {
                    modal.style.display = "none";
                    that.component = component;
                });
            }
            td.append(button);
            td = document.createElement("td");
            td.textContent = name;
            tr.append(td);
            tBody.append(tr);
        });
        ["h1", "h2", "h3", "h4", "h5", "h6"].forEach(h => {
            const headings = Array.from(modal.querySelectorAll(`div.modalContent > ${h}`));
            if (headings.length > 0) {
                headings.forEach(h => {
                    h.classList.add("centered");
                });
            }
        });
        formatTable(table);
        tableDiv.append(table);
    },

    /**
     * Not tested.
     */
    setupTargetSelect() {
        const select = document.getElementById("massAddTargetSelect");
        select.innerHTML = "";
        select.innerHTML += `<option value=${""}>${""}</option>`;
        const relationships = getRelationshipsWithTypes();
        const types = []; // I need a "types" array because I want to sort all of the types together
        Object.keys(relationships).filter(r => r !== "configurationNode").forEach(relationship => {
            relationships[relationship].forEach(type => {
                if (!types.includes(type)) types.push(type);
            });
        });
        alphabeticalForEach.bind(types)(type => {
            const option = document.createElement("option");
            option.textContent = type;
            option.value = type;
            // Don't add event listeners to option elements, add them to the select element.
            select.append(option);
        });
        const that = this;
        select.onchange = function() {
            that.target = this.value;
        }
    },

    /* Private methods */

    /**
     * I don't need to build the primary modal, but I do need to set it up. When "close" is clicked, this instance of addManager never goes away
     * (memory leak) because of the reference to the primary modal. Also because the document elements have event listeners that link to the
     * addManager. Easy solution is just to have one global addManager. It would be interesting to test this memory leak hypothesis. Also I'm adding
     * multiple event listeners to the same element right?
     */
    setupPrimaryModal() {
        const modal = document.getElementById("massAddModal");
        const input = modal.querySelector("input");
        const that = this;
        // Don't want to add an event listener every time this is set up.
        input.onchange = function() {
            that.setProbability(this);
        }
        modal.querySelector("button[data-buttonfunction='submit']").onclick = () => {
            if (that.component.object == null) {
                alert("Please select a component to add.")
            } else if (that.target === "") {
                alert("Please select an object type to add to.")
            } else {
                that.massAdd();
                toggleDisplay(modal);
                that.reset();
            }
        }
        const cancelButton = modal.querySelector("button[data-buttonfunction='cancel']").onclick = () => {
            toggleDisplay(modal);
            that.reset();
        }
    },

    /**
     * The components never change, so don't bother updating. We can only add child components.
     */
    setupComponentSelect() {
        const select = document.getElementById("massAddComponentSelect");
        select.innerHTML += `<option value=${""}>${""}</option>`;// TODO: add blank item
        // Create the options in the select
        alphabeticalForEach.bind(gComponentManager.getTypes())(type => {
            if (getRelationship(gComponentManager.getFirst(type)) === "childNode") {
                const names = gComponentManager.getNamesOfType(type);
                const option = document.createElement("option");
                select.append(option);
                if (names.length === 1) {
                    //TODO: show the name in the modal
                    option.value = "finish";
                    option.textContent = type;
                } else {
                    option.value = "continue";
                    option.textContent = `${type}...`;
                }
            }
        });
        // Determine what happens when an option in the select is clicked
        const that = this;
        select.addEventListener("change", function() {
            const value = this.options[this.selectedIndex].value;
            if (value === "") {
                that.component = {};
            } else {
                let type = this.options[this.selectedIndex].textContent;
                if (value === "finish") {
                    const name = gComponentManager.getNamesOfType(type)[0];
                    that.component = gComponentManager.get(type, name);
                } else if (value === "continue"){
                    type = type.replace(/[.]{3}/, "");
                    that.buildSecondaryModal(type, true);
                }
            }
        });
    },

    //add on change anonymous listener to input
    setProbability(input) {
        let float = input.value;
        if (!isNumberString(float) || parseFloat(float) > 1.0 || parseFloat(float) < 0) {
            alert("Please enter a valid number for attachment probability.");
            input.value = this.probability;
        } else {
            this.probability = parseFloat(float)
        }
    },

    reset() {
        const modal = document.getElementById("massAddModal");
        Array.from(modal.querySelectorAll("select")).forEach(s => {
            s.selectedIndex = 0;
        });
        modal.querySelector("input").value = "1.0";
        this.target = "";
        this.component = {};
        this.probability = 1;
    }
}

function createAddManager() {
    const am = Object.create(addManagerPrototype);
    am.probability = 1.0; //default so there's never an invalid value
    am.target = "";
    am.component = {}; //need to display component.name
    am.setupComponentSelect();
    am.setupPrimaryModal();
    return am;
}

//**************************************************
// Selection Interface
//**************************************************

const selectionPrototype = {

    /* Public methods */

    hasId(id) {
        if (this.selectedElements.find(e => e.id === id) != null) return true;
        return false;
    },
    remove(element) {
        const elements = this.selectedElements.filter(e => e.id === element.id);
        if (elements.length === 0) throw new Error(`Remove operation failed. The element "${element.tagName}" does not exist in this selection.`);
        elements.forEach(e => {
            e.classList.remove("selected");
            Array.from(e.children).forEach(child => {
                e.removeChild(child);
            })
            this.selectedElements.splice(this.selectedElements.indexOf(e), 1);
        });
    },
    add(element) {
        if (this.selectedElements.includes(element)) {
            throw new Error("Add operation failed. The element argument already exists in this selection.");
        } else if (element.classList.contains("selected")) {
            throw new Error("Add operation failed. The element argument already has the 'selected' class.");
        }
        element.classList.add("selected");
        this.addAnimation(element);
        this.selectedElements.push(element);
    },
    empty() {
        this.selectedElements.forEach(e => {
            e.classList.remove("selected");
            Array.from(e.children).forEach(child => {
                e.removeChild(child);
            });
        });
        this.selectedElements = [];
    },
    getKeys() {
        return this.selectedElements.map(element => {
            return element.id;
        });
    },

    /* Private methods */

    /** 
     * An <animate> element points to exactly one other element. If there is no 'href' attribute, then the element is the direct parent of the <animate> element. I cannot apply a single <animate> element to multiple elements.
     * @param {HTMLElement} e
     */
    addAnimation(e) {
        e.innerHTML = `<animate id="anim1${e.id}" attributeName="stroke" values="#FFFFFF;#00FF00;#FFFFFF" dur="0.6s" repeatCount="indefinite"/>`;
    },
}

function createSelection() {
    const obj = Object.create(selectionPrototype);
    obj.selectedElements = [];
    return obj;
}

function saveSvg() {
	// Create an SVG that can be saved.
	alert("We are redirecting you to a static version of the SVG that you can save as a .svg file.")
	var svg = document.getElementById("svgContainer").outerHTML
	var win = window.open()
	win.document.write(svg)
}

function downloadTextFile() {
	// WARNING! Performance is very bad because the JSON is enormous! This can hang your browser!
	alert("We are opening a window with JSON in it that you can save as a .json file.")
	var modJson = JSON.stringify(gWriteFeeder);
	var win = window.open();
	win.document.write(modJson);
}

function scaleGraphForVisualAppearance(objectCount) {
    if (objectCount < 300) {
        gScaleLevel = 5;
    } else if (objectCount < 2000) {
        gScaleLevel = 2;
    } else if (objectCount < 4000) {
        gScaleLevel = .4;
    } else {
        gScaleLevel = .1;
    }
}

/**
 * TODO: add unit tests
 * Get dimensions with: panZoom.getSizes()
 * scale of .0000004 displays real lat/lon fairly well
 */
function createViewport(tree, svgContainer) {
    const keys = Object.keys(tree);
    const firstKey = keys.find(key => tree[key].longitude != null && tree[key].latitude != null);
    if (firstKey == null) {
        // There were no coordinates, so insert some!
        const objects = Object.values(tree);
        insertCoordinates(objects, 0, 0, 50);
    }
    scaleGraphForVisualAppearance(keys.length)
    const minMax = getMinMax({objectContainer: tree, properties: ["longitude", "latitude"]});
    let {latitude: {min: minLat}} = minMax;
    let {latitude: {max: maxLat}} = minMax;
    let {longitude: {min: minLon}} = minMax;
    let {longitude: {max: maxLon}} = minMax;
    /* Longitude is not reversed, so I want the minimum longitude to use as the offset. Latitude IS reversed, so I want the maximum latitude to use as the offset. */
    const longitudeRange = maxLon - minLon;
    const latitudeRange = maxLat - minLat;
    gMinLon = minLon;
    gMaxLat = maxLat;
    /* Multiply by the gDrawScaleFactor when drawing. Divide by the gDrawScaleFactor when storing. 
    We use the larger of the range values to set the gDrawScaleFactor to make the graph fit in the viewport initially.
    */
    if (longitudeRange > latitudeRange) {
        gDrawScaleFactor = 1000/longitudeRange;
    } else {
        gDrawScaleFactor = 1000/latitudeRange;
    }
    /*
    Special case: minimum and maximum longitude and latitude are all the same (e.g. 0)! gDrawScale factor won't space things further apart, it just
    makes various scales fit in the viewport
    */
    if (gDrawScaleFactor === Infinity) {
        gDrawScaleFactor = 1;
    }
    svgContainer.setAttribute("viewBox",`0 0 ${1000} ${1000}`);
    /* Uncomment below to make gScaleFactor go away */
    //gDrawScaleFactor = 1;
    //svgContainer.setAttribute("viewBox",`0 0 ${longitudeRange} ${latitudeRange}`);
    /* Uncomment above to make gScaleFactor go away */
	window.panZoom = svgPanZoom("#svgContainer", {
        /* Override the default values set by "optionsDefaults" in svg-pan-zoom.js */
        dblClickZoomEnabled: false,
        zoomScaleSensitivity: 0.2,
        minZoom: 0.01,
		maxZoom: 800
    });
}

//**************************************************
// Click event functions
//**************************************************

/**
 * TODO: add unit tests, this should only handle selection objects. creating tables is a special listener attached to svgContainer,
 * not svgContainerWrapper
 * Listener on the SVG object that handles user clicks.
 */
function handleSelection(event) {
    if (detectDrag(event)) return;
    const element = event.target;
    if (event.altKey && (element.tagName === "circle" || element.tagName === "line") && !element.classList.contains("parentChild")) {
        if (gSelection.hasId(element.id)) {
            gSelection.remove(element);
            //Copied from rowPrototype.delete(). Refactor needed
            const table = document.getElementById(`descriptionTable_${element.id}`);
            if (table != null) {
                document.getElementById("descriptionTables").removeChild(table);
            }
        } else {
            gSelection.add(element);
        }
        rebuildSelectionTable();
    } else if (!event.altKey) {
        gSelection.empty();
        destroyTables(["descriptionTables", "selectionTable"]);
        //destroyTables(["selectionTable"]);
        if ((element.tagName === "circle" || element.tagName === "line") && !element.classList.contains("parentChild")) {
            gSelection.add(element);
            const table = createDescriptionTable(element.id);
            table.id = `descriptionTable_${element.id}`;
            document.getElementById("descriptionTables").appendChild(table);
        } 
    }
}

/**
 * Scale the thickness of all lines and size of all circles. This helps user see details.
 * @param {number} x
 */
function scaleTo(x) {
    gScaleLevel = x;
	const circles = document.getElementsByTagName("circle")
	const lines = document.getElementsByTagName("line")
	// Scale Circles
	for (let i = 0; i < circles.length; i++) {
		circles[i].setAttribute("r", 2*x)
		circles[i].setAttribute("stroke-width", 0.5*x)
	}
	// Scale Lines
	for (let i = 0; i < lines.length; i++) {
		if (lines[i].getAttribute("class").indexOf("p2") !== -1) {
			lines[i].setAttribute("stroke-width", 2*x)
		}
		else if (lines[i].getAttribute("class").indexOf("p3") !== -1) {
			lines[i].setAttribute("stroke-width", 3*x)
		}
		else if (lines[i].getAttribute("class").indexOf("parentChild") !== -1) {
			lines[i].setAttribute("stroke-width", 0.5*x)
		}
		else {
			lines[i].setAttribute("stroke-width", x)
		}
	}
}

//Returns real Lat/Long of a click event, used in the moveBus function
function clickLatLon(event) {
	const pan = window.panZoom.getPan();
    const zoom = panZoom.getSizes().realZoom;
	const svg = document.getElementById("svgContainer");
	let pt = svg.createSVGPoint();
	pt.x = event.clientX;
	pt.y = event.clientY;
	pt = pt.matrixTransform(svg.getScreenCTM().inverse());
	let x = pt.x;
	let y = pt.y;
	const coords = {
		x: (x - pan.x) / zoom,
		y: (y - pan.y) / zoom
	};
	return coords;
}

//**************************************************
// Find modal interface
//**************************************************

function searchTerm() {
    let keys;
    let operation = document.querySelector("input[name='searchMode']:checked").value;
    if (operation === "searchExactString") {
        keys = findExactMatchingObjects(gTree.tree, this.value.trim());
    } else if (operation === "searchSubstring") {
        keys = findSubstringMatchingObjects(gTree.tree, this.value.trim());
    }
    prepareFoundKeys.bind(this)(keys);
}

/**
 * @param {Array} keys
 */
function prepareFoundKeys(keys) {
    document.getElementById("searchCount").textContent = `hits: ${keys.length}`;
    const nextButton = document.getElementById("findNext");
    const previousButton = document.getElementById("findPrevious");
    if (keys.length === 0 || this.value === "") {
        alert(`No results found for term: "${this.value}".`)
        const feedback = function() {
            alert("Please enter a new term to search for."); 
        }
        nextButton.onclick = feedback;
        previousButton.onclick = feedback;
        document.getElementById("foundElementKey").textContent = "";
        return;
    }
    const upperIndex = keys.length - 1;
    let idx = 0;
    viewElement(keys[idx]);
    nextButton.onclick = function() {
        idx++;
        if (idx > upperIndex) idx = 0;
        viewElement(keys[idx]);
    }
    previousButton.onclick = function() {
        idx--;
        if (idx < 0) idx = upperIndex;
        viewElement(keys[idx]);
    }
}

/**
 * Return the key of the object whose own key, property value, or property key exactly matched the search term. 
 * 
 * Don't return the key if the matching object wasn't drawn due to bad JSON data.
 * @param {Object} tree
 * @param {string} string
 */
function findSubstringMatchingObjects(tree, string) {
    const keys = [];
    if (string === "") return keys;
    for (let key in tree) {            
        if (key.includes(string) && document.getElementById(key) != null) {
            keys.push(key);
            continue;
        }
        for (let propertyKey in tree[key]) {
            let propertyVal = tree[key][propertyKey];
            if (typeof(propertyVal) !== "string") propertyVal += "";
            if (propertyKey.toLowerCase().includes(string.toLowerCase()) && document.getElementById(key) != null) {
                keys.push(key);
                break;
            } else if (propertyVal.toLowerCase().includes(string.toLowerCase()) && document.getElementById(key) != null) {
                keys.push(key);
                break;
            }
        }
    }
    return keys;
}

/**
 * Return the key of the object whose own key, property value, or property key contained the search term as a substring.
 * 
 * Don't return the key if the matching object wasn't drawn due to bad JSON data.
 * @param {Object} tree
 * @param {string} string
 */   
function findExactMatchingObjects(tree, string) {
    const keys = [];
    if (string === "") return keys;
    for (let key in tree) {
        if (key === string && document.getElementById(key) != null) {
            keys.push(key);
            continue;
        } 
        for (let propertyKey in tree[key]) {
            let propertyVal = tree[key][propertyKey];
            if (typeof(propertyVal) !== "string") propertyVal += "";
            if (propertyKey.toLowerCase() === string.toLowerCase() && document.getElementById(key) != null) {
                keys.push(key);
                break;
            } else if (propertyVal.toLowerCase() === string.toLowerCase() && document.getElementById(key) != null) {
                keys.push(key);
                break;
            }
        }
    }
    return keys;
}

/** 
 * TODO: add unit tests
 */
function viewElement(key) {
    destroyTables(["descriptionTables"]);
    if (document.getElementById("showTableOnFind").checked) {
        document.getElementById("descriptionTables").appendChild(createDescriptionTable(key));
    }
    document.getElementById("foundElementKey").textContent = key;
    gSelection.empty();
    const element = document.getElementById(key);
    gSelection.add(element);
    let x, y;
    if (element.getAttribute("cx") != null && element.getAttribute("cy") != null) {
        x = element.getAttribute("cx");
        y = element.getAttribute("cy");
    } else {
		x = (parseFloat(element.getAttribute("x1")) + parseFloat(element.getAttribute("x2"))) / 2;
		y = (parseFloat(element.getAttribute("y1")) + parseFloat(element.getAttribute("y2"))) / 2;
    }
    // I can"t make this work 
    //panZoom.zoomAtPoint(2, {x: x, y: y});
    // Do this instead 
	panZoom.pan({x:0, y:0})
	var realZoom = window.panZoom.getSizes().realZoom
	var width = window.panZoom.getSizes().width / 2
	var height = window.panZoom.getSizes().height / 2
    panZoom.pan({x:width - (x * realZoom), y:height - (y * realZoom)})
    panZoom.zoom(20/gScaleLevel);
}

//**************************************************
// Header menu functions
//**************************************************

//delete this eventually
function insertIndependentComponent(component) {
    alert("Please click a location on the graph to insert this component.");
    const svgContainer = document.getElementById("svgContainer");
    svgContainer.setAttribute("style", "cursor: crosshair");
    svgContainer.onclick = function(event) {
        if (detectDrag(event)) return;
        const tObject = createTreeObject(component, gTree);
        insertCoordinates([tObject.data], 0, 0, 0);
        getMoveNodesFunction([tObject.data])(event);
        gTree.insert(tObject);
        createSvgData([tObject.key]).draw(gViewport);
    }
}

//delete this eventually
function insertChildComponent(keys, component) {
    const svgContainer = document.getElementById("svgContainer");
    if (keys.length === 0) {
        alert("Please click on another circle that is not a configuration node to add this component as a child.");
        svgContainer.setAttribute("style", "cursor: crosshair");
        svgContainer.onclick = function(event) {
            if (detectDrag(event)) return;
            event.stopPropagation();
            detachListener();
            let parent;
            try {
                parent = gTree.getObject(event.target.id);
                if (parent != null && getRelationship(parent) !== "configurationNode") {
                    if (component.object === "recorder" || getRelationship(parent) !== "line") {
                        const tObject = createTreeObject(component, gTree);
                        tObject.setupChildNode(event.target.id);
                        gTree.insert(tObject);
                        createSvgData([tObject.key]).draw(gViewport);
                    } else {
                        alert("Insertion failed. You clicked on a line. Only meter recorders can be children of lines.");
                    }
                } else {
                    alert("Insertion failed. You clicked on a configuration node.");
                }
            } catch (e) {
                alert("Insertion failed. You click on an invalid object");
            }
        }
    } else {
        const newObjects = [];
        keys.forEach(key => {
            const tObject = createTreeObject(component, gTree);
            tObject.setupChildNode(key);
            gTree.insert(tObject);
            newObjects.push(tObject.key);
        });
        createSvgData(newObjects).draw(gViewport); 
    }
}

// delete this eventually
function insertLineComponent(keys, component) {
    const svgContainer = document.getElementById("svgContainer");
    if (keys.length === 0) {
        alert("Please click on two circles that are not configuration nodes to add this line.");
        const nodes = [];
        svgContainer.setAttribute("style", "cursor: crosshair");
        svgContainer.onclick = function(event) {
            if (detectDrag(event)) return;
            event.stopPropagation();
            try {
                const node = gTree.getObject(event.target.id);
                const relationship = getRelationship(node);
                if (relationship === "childNode" || relationship === "independentNode") {
                    if (!gSelection.hasId(event.target.id)) {
                        gSelection.add(event.target);
                        nodes.push(event.target.id);
                    }
                } else {
                    alert(`You clicked on a "${relationship}" type object. Please click on a circle that is not a configuration node.`);
                    return;
                }
            } catch (e) {
                alert(`You clicked on an invalid object. Please click on a circle that is not a configuration node.`);
                return;
            }
            if (nodes.length === 2) {
                const tObject = createTreeObject(component, gTree);
                tObject.setupLine(nodes[0], nodes[1]);
                gTree.insert(tObject);
                createSvgData([tObject.key]).draw(gViewport)
                gSelection.empty();
                detachListener();
            }
        }
    } else {
        const newObjects = [];
        for (let i = 0; i < keys.length - 1; i++) {
            let tObject = createTreeObject(component, gTree);
            tObject.setupLine(keys[i], keys[i + 1]);
            gTree.insert(tObject);
            newObjects.push(tObject.key);
        }
        createSvgData(newObjects).draw(gViewport);
    }
}

//**************************************************
// Handler functions
//**************************************************

function attachHandlers() {
    addComponentHandlers();
    addMouseHandlers();
    addKeyHandlers();
    Array.from(document.querySelectorAll("div.headerGroup")).forEach(h => {
        h.addEventListener("click", toggleHeader);
    });
    const isStatic = interfaceIsStatic();
    addModelViewerHandlers(isStatic);
    {% if showFileMenu %}
    addModelOwnerHandlers(isStatic);
    {% endif %}
    makeModalsDraggable();
    prepareFindModal();
    prepareColorModal();
}

function prepareFindModal() {
    const searchInput = document.getElementById("searchInput");
    searchInput.addEventListener("change", searchTerm);
    document.getElementById("searchExactString").addEventListener("change", function() {
        searchTerm.call(searchInput);
    });
    document.getElementById("searchSubstring").addEventListener("change", function() {
        searchTerm.call(searchInput);
    });
    formatTable(document.getElementById("findModal").querySelector("table"));
}

function prepareColorModal() {
    const colorModal = document.getElementById("colorModal");
    const colorManager = createColorManager();
    colorModal.querySelector("input[type='file']").addEventListener("change", async function() {
        await colorManager.buildHTML(this.files);
    });
    colorModal.querySelector("button[data-buttonfunction='reset']").addEventListener("click", () => {
        colorManager.removeColors();
    });
}

function toggleHeader() {
    const heading = this.querySelector(".menuHeading");
    if (heading.classList.contains("expandedHeading")) {
        // Close this header if it was open
        closeHeader.call(this);
    } else {
        // Open this header and close all other headers
        expandHeader.call(this);
        const that = this;
        Array.from(document.querySelectorAll("div.headerGroup")).forEach(div => {
            if (div !== that) {
                closeHeader.call(div);
            }
        });
    }
}

function expandHeader() {
    const heading = this.querySelector(".menuHeading");
    const headingName = heading.textContent.split(" ")[0];
    if (!heading.classList.contains("expandedHeading")) {
        heading.classList.add("expandedHeading");
        heading.innerHTML = headingName + " &#x25B4;";
        this.querySelector("ul").removeAttribute("style");
    }
}

function closeHeader() {
    const heading = this.querySelector(".menuHeading");
    const headingName = heading.textContent.split(" ")[0];
    if (heading.classList.contains("expandedHeading")) {
        heading.classList.remove("expandedHeading");
        heading.innerHTML = headingName + " &#x25BE;";
        this.querySelector("ul").style.display = "none";
    }
}

/** 
 * TODO: add a click listener instead of doing it backwards!
 * Fill menu of "Add" button and add its handler functions.
 */
/* How do I handle component variations within the select? 
*/
function addComponentHandlers() {
    const ul = document.getElementById("componentList");
    alphabeticalForEach.bind(gComponentManager.getTypes())(type => {
		const li = document.createElement("li");
        ul.appendChild(li);
        let names = gComponentManager.getNamesOfType(type);
        if (names.length === 1) {
            li.textContent = type;
            const component = gComponentManager.get(type, names[0]);
            const func = getAddComponentFunction(component);
            li.addEventListener("click", func);
        } else {
            li.textContent = `${type}...`;
            li.addEventListener("click", function() {
                gAddManager.buildSecondaryModal(type);
            });
        }
    });
}

//TODO: move to add manager
function getAddComponentFunction(component) {
    let func;
    const relationship = getRelationship(component);
    switch (relationship) {
        case "independentNode":
        case "configurationNode":
            func = function() {
                if (isValidForAdd(gSelection.getKeys(), component)) {
                    insertIndependentComponent(component);
                }
            }
            //li.addEventListener("click", function() {
            //    if (isValidForAdd(gSelection.getKeys(), component)) {
            //        insertIndependentComponent(component);
            //    }
            //});
            break;
        case "childNode":
            func = function() {
                if (isValidForAdd(gSelection.getKeys(), component)) {
                    insertChildComponent(gSelection.getKeys(), component);
                }
            }
            //li.addEventListener("click", function() {
            //    if (isValidForAdd(gSelection.getKeys(), component)) {
            //        insertChildComponent(gSelection.getKeys(), component);
            //    }
            //});
            break;
        case "line":
            func = function() {
                if (isValidForAdd(gSelection.getKeys(), component)) {
                    insertLineComponent(gSelection.getKeys(), component);
                }
            }
            //li.addEventListener("click", function() {
            //    if (isValidForAdd(gSelection.getKeys(), component)) {
            //        insertLineComponent(gSelection.getKeys(), component);
            //    }
            //});
            break;
    }
    return func;
}

/** 
 * Fill a list with feeders that the user can load into this feeder
 * @param {Element} ul - An html element where the list will be attached.
 * @param {Array} feeders - An array of objects, where each object has properties "model" and "name", or null. 
 * @param {string} owner - Either "public" or the current user.
 */
function fillFeederList(ul, feeders, owner, thisModelName, thisFeederName) {
    if (feeders == null) return; // sometimes the user has no feeders
    if (ul == null) return; // there is no ul if we don't show the file menu
    const sortedNames = [...new Set(feeders.map(feeder => feeder.name.toLowerCase()))].sort();
    sortedNames.forEach(name => {
        const feeder_ary = feeders.filter(f => f.name.toLowerCase() === name);
        feeder_ary.forEach(f => {
            if (f.model !== thisModelName || f.name !== thisFeederName) {
                const li = document.createElement("li");
                li.classList.add("feederItem");
                li.innerHTML = `<strong>${f.name}</strong> from <br>"${f.model}"`;
                li.addEventListener("click", function() {
                    // What is the feeder.model for a public feeder? It's "publicFeeders". Do feeders not have their own owner property? No they
                    // don't. That's why I have a separate owner variable 
                    loadFeeder(f.name, f.model, owner);
                });
                ul.append(li);
            }
        });
    });
}

/**
 * These features should be enabled for every user who views this model, whether they are an owner or not.
 * @param {boolean} interfaceIsStatic - true if this interface was rendered outside of a web server context.
 */
function addModelViewerHandlers(interfaceIsStatic=true) {
    const fileMenu = document.getElementById("fileMenu");
    const fileMenuNodes = Array.from(fileMenu.querySelectorAll("li"));
    const editMenu = document.getElementById("editMenu");
    const editMenuNodes = Array.from(editMenu.querySelectorAll("li"));
    // Add handlers to file menu
    fileMenuNodes.find(li => li.textContent.toLowerCase() === "view raw data").addEventListener("click", downloadTextFile);
    // Add handlers to edit menu
    editMenuNodes.find(li => li.textContent.toLowerCase() === "attachments...").addEventListener("click", () => {
        loadAttachments();
        toggleDisplay(document.getElementById("attachmentsModal"));
    });
    editMenuNodes.find(li => li.textContent.toLowerCase() === "find...").addEventListener("click", () => {
        toggleDisplay(document.getElementById("findModal"));
        document.getElementById("searchInput").focus(); 
    });
    editMenuNodes.find(li => li.textContent.toLowerCase() === "mass add...").addEventListener("click", () => {
        gAddManager.setupTargetSelect();
        toggleDisplay(document.getElementById("massAddModal"));
    });
    editMenuNodes.find(li => li.textContent.toLowerCase() === "mass edit...").addEventListener("click", () => {
        updateAttachTargets("massEditTargetSelect", gTree.tree);
        toggleDisplay(document.getElementById("massEditModal"));
    });
    editMenuNodes.find(li => li.textContent.toLowerCase() === "change opacity...").addEventListener("click", () => {
        gOpacityManager.update();
        gOpacityManager.buildOpacityModal();
    });
    editMenuNodes.find(li => li.textContent.toLowerCase() === "color circuit...").addEventListener("click", () => {
        toggleDisplay(document.getElementById("colorModal"));
    });
    editMenuNodes.find(li => li.textContent.toLowerCase() === "static loads to houses").addEventListener("click", convertStaticLoadsIntoHouses);
    if (!interfaceIsStatic) {
        fileMenu.querySelector("li[data-web='map']").addEventListener("click", () => {
            window.open(`/displayMap/${gThisOwner}/${gThisModelName}/${gThisFeederNum}`, '_blank');
        });
    } else {
        fileMenu.querySelector("li[data-web='map']").remove()
    }
}

{% if showFileMenu %}
/**
 * These features should only be enabled for the owner of a model.
 * @param {boolean} interfaceIsStatic - true if this interface was rendered outside of a web server context.
 */
function addModelOwnerHandlers(interfaceIsStatic=true) {
    const fileMenu = document.getElementById("fileMenu");
    const editMenu = document.getElementById("editMenu");
    if (!interfaceIsStatic) {
        // Add handlers to file menu
        fileMenu.querySelector("li[data-web='save']").addEventListener("click", () => saveFeeder(gWriteFeeder));
        fileMenu.querySelector("li[data-web='rename']").addEventListener("click", getNewFeederName);
        fileMenu.querySelector("li[data-web='load']").addEventListener("click", () => toggleDisplay(document.getElementById("loadModal")));
        fileMenu.querySelector("li[data-web='new']").addEventListener("click", () => toggleDisplay(document.getElementById("blankFeederModal")));
        fileMenu.querySelector("li[data-web='windmil']").addEventListener("click", () => toggleDisplay(document.getElementById("milsoftModal")));
        fileMenu.querySelector("li[data-web='gridlabd']").addEventListener("click", () => toggleDisplay(document.getElementById("gridlabdModal")));
        fileMenu.querySelector("li[data-web='opendss']").addEventListener("click", () => toggleDisplay(document.getElementById("opendssModal")));
        fileMenu.querySelector("li[data-web='cyme']").addEventListener("click", () => toggleDisplay(document.getElementById("cymeModal")));
        // Fill feeder lists
        fillFeederList(document.getElementById("publicFeederList"), gPublicFeeders, "public", gThisModelName, gThisFeederName);
        fillFeederList(document.getElementById("userFeederList"), gUserFeeders, gCurrentUser, gThisModelName, gThisFeederName);
        // Prepare the climate modal
        fillClimateModalOptions();
        // Add handlers to edit menu
        editMenu.querySelector("li[data-web='ami']").addEventListener("click", () => toggleDisplay(document.getElementById("amiModal")));
        editMenu.querySelector("li[data-web='anonymize']").addEventListener("click", () => toggleDisplay(document.getElementById("anonymizeModal")));
        editMenu.querySelector("li[data-web='climate']").addEventListener("click", () => toggleDisplay(document.getElementById("climateModal")));
        editMenu.querySelector("li[data-web='scada']").addEventListener("click", () => toggleDisplay(document.getElementById("scadaModal")));
        editMenu.querySelector("li[data-web='zillowHouse']").addEventListener("click", startZillowHouses);
    }
}
{% endif %}

function addMouseHandlers() {
    const svgContainerWrapper = document.getElementById("svgContainerWrapper");
    svgContainerWrapper.addEventListener("click", function(event) {
        handleSelection(event);
    });
    svgContainerWrapper.addEventListener("mousedown", function(event) {
        gDownX = event.clientX;
    });
    svgContainerWrapper.addEventListener("mouseup", function(event) {
        gDownY = event.clientY;
    });
    svgContainerWrapper.addEventListener("click", function() {
        Array.from(document.querySelectorAll("div.headerGroup")).forEach(div => {
            closeHeader.call(div);
        });
    });
    document.getElementById("scaleButton").addEventListener("click", function() {
        const userScale = prompt("Scale line thickness by this multiple:", gScaleLevel);
        if (isNumberString(userScale)) {
            scaleTo(parseFloat(userScale));
        }
    });
}

function addKeyHandlers() {
    document.body.addEventListener("keydown", function(event) {
        if (event.target.tagName.toLowerCase() !== "input") {
            switch (event.key) {
                case "m":
                    destroyTables(["descriptionTables"]);
                    attachMoveListener(gSelection.getKeys());
                    break;
                case "-":
                    panZoom.zoomOut();
                    break;
                case "=":
                    panZoom.zoomIn();
                    break;
                case "Escape":
                    const svgContainer = document.getElementById("svgContainer");
                    if (svgContainer.onclick != null) {
                        alert("Operation cancelled");
                        detachListener();
                    }
                    break;
            }
        }
    });
}

/** 
 * TODO: add unit tests If an element isn't displayed, set it's inline display value to the default browser value. If the element is displayed, then
 * hide it.
 * @param {HTMLElement} element
 */
function toggleDisplay(element) {
    if (element.style.display === "none") {
        element.removeAttribute("style");
    } else {
        element.style.display = "none";
        if (element.id === "findModal") return;
        // When we hide a modal (except the findModal), set any of the text fields to empty.
        Array.from(element.querySelectorAll("input[type='text']")).forEach(input => input.value = "");
    }
}

function makeModalsDraggable() {
    $("#findModal .modalContent").draggable();
    $("#progressModal .modalContent").draggable();
    $("#loadModal .modalContent").draggable();
    $("#blankFeederModal .modalContent").draggable();
    $("#milsoftModal .modalContent").draggable();
    $("#gridlabdModal .modalContent").draggable();
    $("#cymeModal .modalContent").draggable();
    $("#scadaModal .modalContent").draggable();
    $("#amiModal .modalContent").draggable();
    $("#massAddModal .modalContent").draggable();
    $("#massEditModal .modalContent").draggable();
    $("#attachmentsModal .modalContent").draggable();
    $("#editAttachmentModal .modalContent").draggable();
    $("#colorModal .modalContent").draggable();
    $("#massAddSecondaryModal .modalContent").draggable();
    $("#climateModal .modalContent").draggable();
    // Position the description table depending on whether or not it is draggable
    //document.getElementById("descriptionTable").removeAttribute("style");
    //document.getElementById("descriptionTable").style.left = "70vw";
}

/**
 * TODO: add unit tests
 */
 function getMoveNodesFunction(objects, tBody=null, tObject=null) {
    if (objects.length > 1 && tBody != null) throw new Error("Cannot update a description table when multiple nodes have been selected to be moved.");
    const moveNodes = function(event) {
        event.stopPropagation();
        detachListener();
        const coords = clickLatLon(event);
        move(objects, coords);
        if (tObject != null) {
            if (objects.length !== 1) throw new Error("Can only update the tObject of a description table when moving a single object!");
            tObject.data.longitude = objects[0].longitude;
            tObject.data.latitude = objects[0].latitude;
        }
        if (tBody != null) {
            Array.from(tBody.getElementsByTagName("input")).forEach(input => {
                if (input.dataset.coordinate === "latitude") {
                    input.value = gMaxLat - coords.y/gDrawScaleFactor;
                } else if (input.dataset.coordinate === "longitude") {
                    input.value = coords.x/gDrawScaleFactor + gMinLon;
                }
            });
        }
    };
    return moveNodes
}

function detachListener() {
    const element = document.getElementById("svgContainer");
    element.setAttribute("style", "cursor: default");
    element.onclick = null;
}

// Ignore drags, those should be handled by svg-panzoom.
function detectDrag(event) {
    return (gDownX !== event.clientX || gDownY !== event.clientY) ? true : false;
}

//**************************************************
// Edit menu interface
//**************************************************

/*
Don't touch existing houses or their loads
Don't ever replace regular load objects
1) Delete triplex nodes (have NO parent) and replace them with houses that have randomly generated loads
2) Replace triplex loads (have parent) with houses that have randomly generated loads
- triplex_loads AND triplex_nodes CAN have parents, but triplex_nodes usually won't
- triplex_load always has a parent
-There are no files with both triplex loads and triplex nodes.
*/
function convertStaticLoadsIntoHouses() {
    const modal = createProgressModal();
    const keys = Object.keys(gTree.tree).filter(key => {
        const object = gTree.getObject(key).object;
        return object === 'triplex_load' || object === 'triplex_node';
    });
    if (keys.length === 0) {
        modal.clearAndAddMessage('This data has no triplex load or triplex node objects that can be converted into houses.');
        modal.finish();
        return;
    }
    modal.clearAndAddMessage(`Converting every triplex load and/or triplex node into a house with children. This could take a few seconds.`);
    setTimeout(function() {
        keys.forEach(key => { 
            gTree.replaceNode(key, gComponentManager.get("house", "R1_SingleFamilyHome_1990-2005"));
            addLoadsToHouse(key);
        });
        createSvgData(keys).draw(gViewport);
        modal.clearAndAddMessage(`${keys.length} triplex objects were converted into houses with children.`)
        modal.finish();
    }, 10);
}

function addLoadsToHouse(key) {
    // Insert water heater
    let tObject = createTreeObject(gComponentManager.get("waterheater", "waterheater"), gTree);
    tObject.setupChildNode(key)
    gTree.insert(tObject);
    // Insert responsive ZIPload
    tObject = createTreeObject(gComponentManager.get("ZIPload", "ZIPload"), gTree);
    tObject.setupChildNode(key);
    let responsiveBasePower = Math.random();
    responsiveBasePower = responsiveBasePower < .5 ? responsiveBasePower + .5 : responsiveBasePower;
    tObject.data["base_power"] = `responsive_loads*${responsiveBasePower}`;
    gTree.insert(tObject);
    // Insert unresponsive ZIPload
    tObject = createTreeObject(gComponentManager.get("ZIPload", "ZIPload"), gTree);
    tObject.setupChildNode(key);
    let unresponsiveBasePower = Math.random() + 1.5;
    tObject.data["base_power"] = `unresponsive_loads*${unresponsiveBasePower}`;
    gTree.insert(tObject);
}

/**
 * The user could have added a new component to the graph that they now wish to attach to. That's why I have to update the attach targets.
 */
/**
 * Can you mass edit configuration nodes? Don't want to edit timezone objects. Disqualify all objects with no "object" property. Climate objects have "climate"
 * as object, but there is no "climate" component. There is no reason why we can't mass edit configuration objects. I'm only editing existing objects, so it
 * has nothing to with components.
 */
function updateAttachTargets(id, tree) {
    document.getElementById(id).innerHTML = "";
	const attachList = [];
	for (let key in tree) {
        if (tree[key].object != null && !attachList.includes(tree[key].object) ) {
            attachList.push(tree[key].object);
        }
    }
    alphabeticalForEach.bind(attachList)(object => {
        document.getElementById(id).innerHTML += `<option value=${object}>${object}</option>`;
    });
}

// keep this, rename it
function getKeysOfObjectsWithoutNumericValues(keys, attributeKey) {
    const tree = gTree.tree;
    const invalidKeys = keys.filter(key => {
        let value = tree[key][attributeKey];
        if (typeof value !== "string") {
            value = String(tree[key][attributeKey]);
        }
        if (!isNumberString(value)) {
            return true;
        }
    });
    return invalidKeys;
}

//only toggle upon successful completion of operation
function massEdit() {
    let operation = document.querySelector("input[name='attributeOperation']:checked");
    if (operation == null) {
        alert("Please select an operation with radio buttons on the 'Mass Edit' menu.");
        return;
    }
    operation = operation.value;
    const objectType = document.getElementById("massEditTargetSelect").value;
    const keys = Object.keys(gTree.tree).filter(key => gTree.getObject(key).object === objectType)
    if (operation === "addAttribute") {
        massAddAttribute(keys, objectType);
        return;
    }
    const attributeKey = document.getElementById("massEditAttribute").value.trim();
    //Make sure the attribute exists
    let invalidKeys = [];
    for (let key of keys) {
        if (gTree.getObject(key)[attributeKey] === undefined) {
            invalidKeys.push(key);
        }
    }
    if (invalidKeys.length > 0) {
        alert(`Mass edit failed. The attribute "${attributeKey}" is missing from one or more objects:\nObject names: "${invalidKeys.map(key => gTree.getObject(key).name).join(", ")}".\nObject keys: "${invalidKeys.join(", ")}".`);
        return;
    }
    //Make sure the attribute exists
    switch (operation) {
        case "addTo":
        case "multiplyBy":
        case "change":
            if (nonModifiableProperties.includes(attributeKey)) {
                alert(`Mass edit failed. The following properties cannot be modified: "${nonModifiableProperties.join(", ")}".`);
                return;
            }
            if (operation === "addTo" || operation === "multiplyBy") {
                invalidKeys = getKeysOfObjectsWithoutNumericValues(keys, attributeKey);
                if (invalidKeys.length > 0) {
                    alert(`Mass edit failed. The attribute "${attributeKey}" does not have a numeric value in the following objects: \nObject names: "${invalidKeys.map(key => gTree.getObject(key).name).join(", ")}".\nObject keys: "${invalidKeys.join(", ")}".`);
                    return;
                }
                if (operation === "addTo") {
                    massAddition(keys, attributeKey, objectType);
                } else if (operation === "multiplyBy") {
                    massMultiplication(keys, attributeKey, objectType);
                }
            } else if (operation === "change") {
                massChange(keys, attributeKey, objectType);
            }
            break;
        case "delete":
            if (nonDeletableProperties.includes(attributeKey)) {
                alert(`Mass edit failed. The properties "${nonDeletableProperties.join(", ")}" cannot be deleted.`);
                return;
            }
            for (let key of keys) {
                delete gTree.getObject(key)[attributeKey];
            }
            alert(`${keys.length} ${objectType} objects had the "${attributeKey}" attribute deleted.`);
            toggleDisplay(document.getElementById("massEditModal"));
            createSvgData(Object.keys(gTree.tree)).quickDraw(gViewport);
            break;
    }
}

/* For the recorder special case, I need to know if the object under consideration is a recorder or not */
/**
 * @param {string} name - the name of the object that is being considered as a parent.
 * @param {string} object - the type of the object that needs the parent. Only matters for the "recorder" special case
 */
function isValidParentName(name, object) {
    try {
        const relationship = getRelationship(gTree.getObject(gTree.treeMap.getKey(name)));
        if (relationship === "configurationNode"  || (relationship === "line" && object !== "recorder")) return false; 
    } catch (e) {
        return false;
    }
    return true;
}

function isValidToOrFromNode(name) {
    const invalidTypes = ["configurationNode", "line"];
    try {
        const relationship = getRelationship(gTree.getObject(gTree.treeMap.getKey(name)));
        if (invalidTypes.includes(relationship)) {
            return false;
        }
    } catch (e) {
        return false;
    }
    return true;
}

function massAddAttribute(keys, objectType) {
    const newKey = document.getElementById("newAttributeKey").value.trim();
    if (newKey === "") {
        alert(`Mass edit failed. Please enter a name for the attribute you want to add.`);
        return;
    }
    if (nonModifiableProperties.includes(newKey)) {
        alert(`Mass edit failed. The properties "${nonModifiableProperties.join(", ")}" cannot be overwritten.`);
        return;
    }
    if (newKey === "to" || newKey === "from" || newKey === "parent") {
        alert(`Mass edit failed. Cannot add the attributes 'to', 'from', or 'parent'.`);
        return;
    }
    const newValue = document.getElementById("newAttributeValue").value;
    for (let key of keys) {
        gTree.getObject(key)[newKey] = newValue;
    }
    alert(`${keys.length} ${objectType} objects had the "${newKey}" attribute added.`);
    toggleDisplay(document.getElementById("massEditModal"));
    createSvgData(Object.keys(gTree.tree)).quickDraw(gViewport);
}

/**
 * @param {keys} - the keys of the objects to be changed
 * @param {attributeKey} - the attribute that is being changed
 * @param {objectType} - The "object" property of every object that is being changed
 */
function massChange(keys, attributeKey, objectType) {
    let newValue = document.getElementById("changeValue").value.trim();
    switch (attributeKey) {
        case "parent":
            if (!isValidParentName(newValue, objectType)) {
                alert(`Mass change failed. The name "${newValue}" is not a valid parent name.`);
                return;
            }
        case "to":
        case "from":
            if (!isValidToOrFromNode(newValue)) {
                alert(`Mass change failed. The name "${newValue}" is not a valid name for a source or target of a line.`);
                return;
            }
    }
    if (["longitude", "latitude"].includes(attributeKey)) {
        if (!isNumberString(newValue)) {
            alert(`Please enter a valid number to edit "latitude" or "longitude".`);
            return;
        } else {
            newValue = parseFloat(newValue);
        }
    }
    const treeObjectCopies = [];
    keys.forEach(key => {
        treeObjectCopies.push(createTreeObject(key, gTree));
    });
    createSvgData(keys).remove(gViewport);
    let count = keys.length;
    const unedited = [];
    treeObjectCopies.forEach(tObject => {
        if (attributeKey === "to") {
            if (tObject.data.from !== newValue) {
                tObject.data[attributeKey] = newValue;
            } else {
                count--;
                unedited.push(tObject.key);
            }
        } else if (attributeKey === "from") { 
            if (tObject.data.to !== newValue) {
                tObject.data[attributeKey] = newValue;
            } else {
                count--; 
                unedited.push(tObject.key);
            }
        } else {
            tObject.data[attributeKey] = newValue;
        }
        gTree.insert(tObject);
    });
    let msg = `${count} ${objectType} objects had the "${attributeKey}" attribute changed.`;
    msg = unedited.length === 0 ? msg : msg + ` The following objects did not have their "${attributeKey}" attribute changed: "${unedited.map(key => gTree.getObject(key).name).join(", ")}".`
    alert(msg);
    toggleDisplay(document.getElementById("massEditModal"));
    createSvgData(Object.keys(gTree.tree)).quickDraw(gViewport);
}

function massAddition(keys, attributeKey, objectType) {
    let operand = document.getElementById("addToValue").value.trim();
    if (!isNumberString(operand)) {
        alert("Mass edit failed. Please enter a valid number if you choose 'Add to Value'.");
        return;
    }
    operand = parseFloat(operand);
    for (let key of keys) {
        gTree.getObject(key)[attributeKey] = parseFloat(gTree.getObject(key)[attributeKey]) + operand;
    }
    alert(`${keys.length} ${objectType} objects had their "${attributeKey}" attribute edited.`);
    toggleDisplay(document.getElementById("massEditModal"));
    createSvgData(Object.keys(gTree.tree)).quickDraw(gViewport);
}


function massMultiplication(keys, attributeKey, objectType) {
    let multiplyOperand = document.getElementById("multiplyValue").value.trim();
    let addOperand = document.getElementById("andAddValue").value.trim() === "" ? "0" : document.getElementById("andAddValue").value.trim();
    if (!isNumberString(multiplyOperand) || !isNumberString(addOperand)) {
        alert("Mass edit failed. Please enter valid operands if you choose 'Multiply attribute by'.");
        return;
    }
    multiplyOperand = parseFloat(multiplyOperand);
    addOperand = parseFloat(addOperand);
    for (let key of keys) {
        gTree.getObject(key)[attributeKey] = parseFloat(gTree.getObject(key)[attributeKey]) * multiplyOperand + addOperand;
    }
    alert(`${keys.length} ${objectType} objects had their "${attributeKey}" attribute edited.`);
    toggleDisplay(document.getElementById("massEditModal"));
    createSvgData(Object.keys(gTree.tree)).quickDraw(gViewport);
}

function loadAttachments() {
    const selectElement = document.getElementById("attachmentSelect");
    selectElement.innerHTML = "";
	for (let key in gWriteFeeder.attachments) {
        selectElement.innerHTML += `<option value=${key}>${key}</option>`;
    }
}

function editAttachment() {
	toggleDisplay(document.getElementById("editAttachmentModal"));
	let name =  document.getElementById("attachmentSelect").value; // Get the name of the attachment
	document.getElementById("attachmentTd").innerHTML = name;  // Set the name of the attachment in the window
	document.getElementById("editAttachmentBox").value = gWriteFeeder.attachments[name];
}

function saveAttachment() {
	let name = document.getElementById("attachmentSelect").value;
    gWriteFeeder.attachments[name] = document.getElementById("editAttachmentBox").value;
    alert("Attachment saved");
}

{% if showFileMenu %}

/**
 * Subhourly data starts in 2006, although there are only 97 out of the 156 stations in 2006. We need subhourly data to get a wind speed measurement. A
 * few stations have really poor data quality.
 */
function fillClimateModalOptions() {
    const yearSelect = document.getElementById("uscrnYear");
    const stationSelect = document.getElementById("uscrnStation");
    if (yearSelect == null || stationSelect == null) return;
    const allUSCRNYears = [2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016, 2017, 2018, 2019];
    const allUSCRNStations = ["AK_Bethel_87_WNW", "AK_Cordova_14_ESE", "AK_Deadhorse_3_S", "AK_Denali_27_N", "AK_Fairbanks_11_NE", "AK_Glennallen_64_N", "AK_Gustavus_2_NE",
	"AK_Ivotuk_1_NNE", "AK_Kenai_29_ENE", "AK_King_Salmon_42_SE", "AK_Metlakatla_6_S", "AK_Port_Alsworth_1_SW", "AK_Red_Dog_Mine_3_SSW", "AK_Ruby_44_ESE",
    "AK_Sand_Point_1_ENE", "AK_Selawik_28_E", "AK_Sitka_1_NE", "AK_St._Paul_4_NE", "AK_Tok_70_SE", "AK_Toolik_Lake_5_ENE", "AK_Utqiagvik_formerly_Barrow_4_ENE",
    "AK_Yakutat_3_SSE", "AL_Brewton_3_NNE", "AL_Clanton_2_NE", "AL_Courtland_2_WSW", "AL_Cullman_3_ENE", "AL_Fairhope_3_NE", "AL_Gadsden_19_N", "AL_Gainesville_2_NE",
	"AL_Greensboro_2_WNW", "AL_Highland_Home_2_S", "AL_Muscle_Shoals_2_N", "AL_Northport_2_S", "AL_Russellville_4_SSE", "AL_Scottsboro_2_NE", "AL_Selma_6_SSE",
	"AL_Selma_13_WNW", "AL_Talladega_10_NNE", "AL_Thomasville_2_S", "AL_Troy_2_W", "AL_Valley_Head_1_SSW", "AR_Batesville_8_WNW", "AZ_Elgin_5_S", "AZ_Tucson_11_W",
	"AZ_Williams_35_NNW", "AZ_Yuma_27_ENE", "CA_Bodega_6_WSW", "CA_Fallbrook_5_NE", "CA_Merced_23_WSW", "CA_Redding_12_WNW", "CA_Santa_Barbara_11_W", "CA_Stovepipe_Wells_1_SW",
	"CA_Yosemite_Village_12_W", "CO_Boulder_14_W", "CO_Cortez_8_SE", "CO_Dinosaur_2_E", "CO_La_Junta_17_WSW", "CO_Montrose_11_ENE", "CO_Nunn_7_NNE", "FL_Everglades_City_5_NE",
	"FL_Sebring_23_SSE", "FL_Titusville_7_E", "GA_Brunswick_23_S", "GA_Newton_8_W", "GA_Newton_11_SW", "GA_Watkinsville_5_SSE", "HI_Hilo_5_S", "HI_Mauna_Loa_5_NNE",
	"IA_Des_Moines_17_E", "ID_Arco_17_SW", "ID_Murphy_10_W", "IL_Champaign_9_SW", "IL_Shabbona_5_NNE", "IN_Bedford_5_WNW", "KS_Manhattan_6_SSW", "KS_Oakley_19_SSW",
	"KY_Bowling_Green_21_NNE", "KY_Versailles_3_NNW", "LA_Lafayette_13_SE", "LA_Monroe_26_N", "ME_Limestone_4_NNW", "ME_Old_Town_2_W", "MI_Chatham_1_SE", "MI_Gaylord_9_SSW",
	"MN_Goodridge_12_NNW", "MN_Sandstone_6_W", "MO_Chillicothe_22_ENE", "MO_Joplin_24_N", "MO_Salem_10_W", "MS_Holly_Springs_4_N", "MS_Newton_5_ENE", "MT_Dillon_18_WSW",
	"MT_Lewistown_42_WSW", "MT_St._Mary_1_SSW", "MT_Wolf_Point_29_ENE", "MT_Wolf_Point_34_NE", "NC_Asheville_8_SSW", "NC_Asheville_13_S", "NC_Durham_11_W", "ND_Jamestown_38_WSW",
	"ND_Medora_7_E", "ND_Northgate_5_ESE", "NE_Harrison_20_SSE", "NE_Lincoln_8_ENE", "NE_Lincoln_11_SW", "NE_Whitman_5_ENE", "NH_Durham_2_N", "NH_Durham_2_SSW", "NM_Las_Cruces_20_N",
	"NM_Los_Alamos_13_W", "NM_Socorro_20_N", "NV_Baker_5_W", "NV_Denio_52_WSW", "NV_Mercury_3_SSW", "NY_Ithaca_13_E", "NY_Millbrook_3_W", "OH_Wooster_3_SSE", "OK_Goodwell_2_E",
	"OK_Goodwell_2_SE", "OK_Stillwater_2_W", "OK_Stillwater_5_WNW", "ON_Egbert_1_W", "OR_Coos_Bay_8_SW", "OR_Corvallis_10_SSW", "OR_John_Day_35_WNW", "OR_Riley_10_WSW",
	"PA_Avondale_2_N", "RI_Kingston_1_NW", "RI_Kingston_1_W", "SC_Blackville_3_W", "SC_McClellanville_7_NE", "SD_Aberdeen_35_WNW", "SD_Buffalo_13_ESE", "SD_Pierre_24_S",
	"SD_Sioux_Falls_14_NNE", "TN_Crossville_7_NW", "TX_Austin_33_NW", "TX_Bronte_11_NNE", "TX_Edinburg_17_NNE", "TX_Monahans_6_ENE", "TX_Muleshoe_19_S", "TX_Palestine_6_WNW",
	"TX_Panther_Junction_2_N", "TX_Port_Aransas_32_NNE", "UT_Brigham_City_28_WNW", "UT_Torrey_7_E", "VA_Cape_Charles_5_ENE", "VA_Charlottesville_2_SSE", "WA_Darrington_21_NNE",
    "WA_Quinault_4_NE", "WA_Spokane_17_SSW", "WI_Necedah_5_WNW", "WV_Elkins_21_ENE", "WY_Lander_11_SSE", "WY_Moose_1_NNE", "WY_Sundance_8_NNW"
    ];
    yearSelect.innerHTML += `<option value=${""}>${""}</option>`;
    allUSCRNYears.forEach(e => {
        const option = document.createElement("option");
        option.textContent = e;
        option.value = e;
        yearSelect.append(option);
    });
    stationSelect.innerHTML += `<option value=${""}>${""}</option>`;
    allUSCRNStations.forEach(e => {
        const option = document.createElement("option");
        option.textContent = e;
        option.value = e;
        stationSelect.append(option);
    });
}

/**
 * Start the server process to convert every triplex load and/or triplex node into a Zillow house.
 */
function startZillowHouses() {
    let cancelled = false
    let modal;
    modal = createProgressModal(() => {
        cancelled = true;
        modal.hide();
    });
    const triplexObjects = Object.entries(gTree.tree).filter(([key, obj]) => 
        obj.object === 'triplex_load' || obj.object === 'triplex_node'
        ).map(([key, obj]) => 
            ({ key: key, latitude: obj.latitude, longitude: obj.longitude })
        );
    if (triplexObjects.length === 0) {
        modal.clearAndAddMessage('This data has no triplex load or triplex node objects that can be converted into Zillow houses.');
        modal.hideCancelButton();
        modal.finish();
        return;
    }
    modal.clearAndAddMessage('Submitting your triplex objects for conversion...')
    const formData = new FormData();
    formData.set('triplexObjects', JSON.stringify(triplexObjects));
    formData.set('owner', gThisOwner);
    formData.set('modelName', gThisModelName);
    const request = $.ajax({
        type: "POST",
        url: "/zillowHouses",
        data: formData,
        processData: false,
        contentType: false
    }).done(function(data, text, jqXHR) {
        if (!cancelled) {
            pollZillowHouses();
        }
    }).fail(function(jqXHR, textStatus, errorThrown) {
        if (!cancelled) { // Don't show the user an error message because they don't care
            modal.clearAndAddMessage('Operation failed. We were unable to submit your triplex objects.');
            modal.hideCancelButton();
            modal.finish();
            //console.log(jqXHR.status); // 500
            //console.log(jqXHR.responseText); // Error message
        }
    });
}

/**
 * Poll the server until the Zillow house information is ready for download.
 */
function pollZillowHouses() {
    let cancelled = false;
    let modal;
    modal = createProgressModal(() => {
        cancelled = true;
        modal.hide();
    });
    modal.clearAndAddMessage('Converting triplex objects into real-world Zillow houses. This could take many minutes...');
    const formData = new FormData();
    formData.set('owner', gThisOwner);
    formData.set('modelName', gThisModelName);
    const intervalId = setInterval(function() {
        $.ajax({
            type: 'POST',
            url: '/checkZillowHouses',
            data: formData,
            processData: false,
            contentType: false
        }).done(function(data, textStatus, jqXHR) { // textStatus is useless
            if (!cancelled) {
                if (jqXHR.status === 200) {
                    clearInterval(intervalId);
                    const keys = Object.keys(data);
                    keys.forEach(key => {
                        gTree.replaceNode(key, data[key]);
                        gTree.tree[key].name = "zillow_house" + key;
                    });
                    createSvgData(keys).draw(gViewport); // redraw so nodes are proper color
                    modal.clearAndAddMessage(`Success. ${keys.length} triplex objects were converted into Zillow houses.`);
                    modal.hideCancelButton();
                    modal.finish();
                }
            } else {
                clearInterval(intervalId);
            }
        }).fail(function(jqXHR, textStatus, errorThrown) {
            if (!cancelled) {
                clearInterval(intervalId);
                modal.clearAndAddMessage('Operation failed. We were unable to get the house data to convert triplex objects into Zillow houses.');
                modal.hideCancelButton();
                modal.finish();
                //console.log(jqXHR.status); // 500
                //console.log(jqXHR.responseText); // server response
            }
        });
    }, 5000);
}

//**************************************************
// File menu interface
//**************************************************

/** 
 * Used to save the new changes or undo an operation by resaving the old changes.
 */
function saveFeeder(feeder) {
    const formData = new FormData();
    formData.set("feederObjectJson", JSON.stringify(feeder));
    const postRequest = $.ajax({
        type: "POST",
        url: `/saveFeeder/${gThisOwner}/${gThisModelName}/${gThisFeederName}/${gThisFeederNum}`,
        data: formData,
        processData: false,
        contentType: false,
    });
    const modal = createProgressModal();
    if (feeder === gReadFeeder) {
        modal.clearAndAddMessage('Re-saving the data from your most recent save...');
        postRequest.done(function() {
            modal.clearAndAddMessage('Success. Your data was restored to the most recent save.');
            modal.finish();
        }).fail(function() {
            modal.clearAndAddMessage('The server raised an internal exception during the save operation.');
            modal.finish();
        });
    } else if (feeder === gWriteFeeder) {
        modal.clearAndAddMessage('Saving changes to your file...');
        postRequest.done(function() {
            modal.hide();
            gReadFeeder = deepCopy(gWriteFeeder);
        }).fail(function() {
            modal.clearAndAddMessage('The server raised an internal exception during the save operation.');
            modal.finish();
        });
    }
}

/**
 * serverFeederName: The name of the feeder I want to load, e.g. "ABEC Columbia"
 * serverModelName: Either "publicFeeders" or something like "Simple Market System Indy Solar"
 * 
 * @param {string} owner - either "public" or the current user.
 */
async function loadFeeder(serverFeederName, serverModelName, owner) {
    let cancelled = false;
    const modal = createProgressModal(() => {
        cancelled = true;
        saveFeeder(gReadFeeder);
    });
    if (feederNeedsSave()) {
        modal.clearAndAddMessage('You have unsaved changes. Please save this feeder before loading a new feeder.');
        modal.hideCancelButton();
        modal.finish();
        return;
    }
    let submitForm = false;
    await $.ajax({ // I need to check if a user's feeder still exists.
        url: `/uniqObjName/Feeder/${owner}/${serverFeederName}/${serverModelName}`// good
    }).done(function(data) {
        if (data.exists) { 
            submitForm = true;
        } else {
            modal.clearAndAddMessage('This feeder no longer exists. Please refresh the page, or select another feeder.');
            modal.hideCancelButton();
            modal.finish();
        }
    }).fail(function() {
        modal.clearAndAddMessage('The AJAX request failed to get a successful response from the server.');
        modal.hideCancelButton();
        modal.finish();
    });
    if (submitForm === false) return;
    modal.clearAndAddMessage('Loading feeder from the server...');
    let formData = new FormData();
    formData.set('referrer', 'distribution');
    $.ajax({
        type: "POST",
        // {owner} is correct. {owner} is either "public" to load from public feeders or <current user> to load from the users feeders. {gThisOwner}
        // is correct because I am overwriting THIS feeder file, which is either publicly owned or owned by the current user. {gThisOwner} cannot be
        // {gCurrentUser} because then I can't overwrite public files as the admin.
        url: `/loadFeeder/${serverFeederName}/${serverModelName}/${gThisModelName}/${gThisFeederNum}/${owner}/${gThisOwner}`,
        data: formData,
        processData: false,
        contentType: false,
    }).done(function() {
        if (!cancelled) { // This is to prevent this modal from overwriting the active save modal
            modal.clearAndAddMessage('Success. This feeder has been overwritten with the selected feeder.');
            modal.cancelButton.textContent = 'Undo';
            modal.finishButton.onclick = () => {
                modal.hide();
                reloadWrapper();
            }
            modal.finish();
        }
    }).fail(function() {
        if (!cancelled) {
            modal.clearAndAddMessage('The server raised an internal exception while loading the feeder.');
            modal.hideCancelButton();
            modal.finish();
        }
    });
}

function validateClimateModal() {
    const modal = document.getElementById("climateForm");
    const radioButtons = Array.from(modal.querySelectorAll("input[name='climateImportOption']:checked"));
    if (radioButtons.length !== 1) {
        alert("Please select a climate change option.");
        return false;
    }
    if (radioButtons[0].value === "USCRNImport") {
        if (modal.querySelector("select[id='uscrnYear']").value === "") {
            alert("Please select a year for the USCRN import.");
            return false;
        }
        if (modal.querySelector("select[id='uscrnStation']").value === "") {
            alert("Please select a station for the USCRN import.");
            return false;
        }
    } else if (radioButtons[0].value === "tmyImport") {
        if (modal.querySelector("input[id='zipCode']").value === "") {
            alert("Please enter a valid 5-digit ZIP Code.");
            return false;
        }
    }
    return true;
}

/** 
 * Submit a from to do one of the following:
 * 1) Import a Milsoft, GridLAB-D, or CYME file into this .omd file.
 * 2) Load a new blank feeder into this .omd file
 * 3) Modify this .omd file with SCADA calibration
 * 4) Modify this .omd file with AMI 
 * 5) Modify this .omd file with climate
 * 6) Modify this .omd file with anonymization
 */
async function submitForm({formId, pollUrl, inputId}) {
    let cancelled = false;
    const modal = createProgressModal(() => {
        cancelled = true;
        // In cases where the initial operation changed the name of the .omd file on the server, we must rename the .omd file to its previous name
        // in order to completely undo the operation. These operations don't change the .omd name: climate, anonymize, scada, ami
        if (['blankFeederForm', 'milsoftForm', 'gridlabdForm', 'cymeForm'].includes(formId)) {
            let oldServerName;
            if (formId === 'blankFeederForm') {
                oldServerName = document.getElementById('blankFeederInput').value;
            } else if (formId === 'milsoftForm') {
                oldServerName = document.getElementById('milsoftInput').value;
            } else if (formId === 'gridlabdForm') {
                oldServerName = document.getElementById('gridlabdInput').value;
            } else if (formId === 'cymeForm') {
                oldServerName = document.getElementById('cymeInput').value;
            }
            renameFeeder(oldServerName, gThisFeederName, false);
        }
        saveFeeder(gReadFeeder);
    });
    if (feederNeedsSave()) {
        modal.clearAndAddMessage('You have unsaved changes. Please save your feeder before modifying it.');
        modal.hideCancelButton();
        modal.finish();
        return;
    }
    let submitForm = true;
    if (inputId !== undefined) { // inputId was defined, therefore we need to check the file name on the server before submitting the form
        submitForm = false;
        const fileName = document.getElementById(inputId).value;
        await $.ajax({ // Check if the file exists, using the user-provided fileName
            url: `/uniqObjName/Feeder/${gThisOwner}/${fileName}/${gThisModelName}` // good
        }).done(function(data) {
            if (data.exists === true) {
                modal.clearAndAddMessage(`You already have a feeder named "${fileName}". Please choose a different name.`);
                modal.hideCancelButton();
                modal.finish();
            } else {
                submitForm = true; // The file does not exist. Submit the form.
            }
        }).fail(function() {
            modal.clearAndAddMessage('The AJAX request failed to get a successful response from the server');
            modal.hideCancelButton();
            modal.finish();
        });
    }
    if (submitForm === false) return;
    modal.clearAndAddMessage('Submitting your file...');
    const form = document.getElementById(formId);
    const formData = new FormData(form);
    if (formId === 'milsoftForm') {
        const stdFileSize = formData.get('stdFile').size;
        let conversionTime = Math.round(0.8860308267 * Math.E ** (0.000000460300437 * stdFileSize));
        if (conversionTime === 0) {
            modal.addMessage('Estimated conversion duration: < 1 minute');
        } else if (conversionTime === 1) {
            modal.addMessage('Estimated conversion duration: 1 minute');
        } else {
            modal.addMessage(`Estimated conversion duration: ${conversionTime} minutes`);
        }
    }
    const formRequest = $.ajax({
        type: "POST",
        url: form.action,
        data: formData,
        processData: false,
        contentType: false,
    });
    if (pollUrl === undefined) { // We don't want to poll the server. Just reload the page.
        formRequest.done(function() {
            if (!cancelled) {
                modal.clearAndAddMessage('Success. Your file was loaded into this feeder.');
                modal.cancelButton.textContent = 'Undo';
                modal.finishButton.onclick = () => {
                    modal.hide();
                    reloadWrapper();
                }
                modal.finish();
            }
        }).fail(function() {
            if (!cancelled) {
                modal.clearAndAddMessage('The server raised an internal exception during form submission.')
                modal.hideCancelButton();
                modal.finish();
            }
        });
    } else {
        formRequest.done(function(data) {
            const intervalId = setInterval(function() {
                $.ajax({
                    url: pollUrl
                }).done(function(data) { // Try not to modify this section. The only way this section can be improved is if the server code is improved first
                    if (cancelled) {
                        clearInterval(intervalId); // If operation was canceled, stop polling. The cancelFunc() will do the rest.
                    } else { // data can be a string, or it can be json with an "exists" property
                        if (data.exists === false) { // processing completed successfully
                            clearInterval(intervalId);
                            if (formId == 'anonymizeForm') {
                                modal.clearAndAddMessage('Success. Your file was anonymized.');
                            } else if (formId === 'climateForm') {
                                modal.clearAndAddMessage('Success. Climate data was added.');
                            } else if (formId === 'scadaForm') {
                                modal.clearAndAddMessage('Success. SCADA data was added.');
                            } else if (formId === 'amiForm') {
                                modal.clearAndAddMessage('Success. AMI data was added.');
                            } else {
                                modal.clearAndAddMessage('Success. Your file was loaded into this feeder.');
                            }
                            modal.cancelButton.textContent = 'Undo';
                            modal.finishButton.onclick = () => {
                                modal.hide();
                                reloadWrapper();
                            }
                            modal.finish();
                        } else if (data.exists == null) { // processing ended in error
                            clearInterval(intervalId);
                            if (data === 'milError') {
                                modal.clearAndAddMessage('The .std and .seq files used were incorrectly formatted.');
                            } else if (data === 'glmError') {
                                modal.clearAndAddMessage('The .glm file used was incorrectly formatted.');
                            } else if (data === 'amiError') {
                                modal.clearAndAddMessage('The AMI file used was incorrectly formatted.');
                            } else {
                                if (!data.endsWith('.')) data += '.';
                                modal.clearAndAddMessage(data);
                            }
                            modal.cancelButton.textContent = 'Undo';
                            modal.hideCancelButton();
                            modal.finish();
                        }
                    }
                }).fail(function() {
                    clearInterval(intervalId);
                    if (!cancelled) {
                        modal.clearAndAddMessage('The server raised an internal exception during the file operation.')
                        modal.hideCancelButton();
                        modal.finish();
                    }
                });
            }, 5000);
        });
    }
}

async function getNewFeederName() {
    const modal = createProgressModal();
    if (feederNeedsSave()) {
        modal.clearAndAddMessage('You have unsaved changes. Please save the feeder before renaming.');
        modal.finish();
        return;
    }
    let newName = prompt('Rename the feeder to', `${gThisFeederName}`);
    while (/\W/.test(newName)) {
        newName = prompt('Only letters, digits and underscore are allowed.\nPlease enter a different name', `${gThisFeederName}`);
    }
    if (newName != null) {
        await $.ajax({
            url: `/uniqObjName/Feeder/${gThisOwner}/${newName}/${gThisModelName}` // good because of course I am renaming THIS feeder file
        }).done(function(data) {
            if (data.exists) {
                modal.clearAndAddMessage(`You already have a feeder named "${newName}". Please choose a different name.`);
                modal.finish();
                return;
            } else {
                renameFeeder(gThisFeederName, newName);
            }
        });
    } else {
        modal.hide();
    }
}

/**
 * The modal shouldn't be shown when the rename operation is being used to undo a newBlankFeeder operation
 */
async function renameFeeder(oldServerName, newName, showModal=true) {
    let modal;
    if (showModal === true) {
        if (newName === gThisFeederName) { // We are undoing a previous rename operation
            modal = createProgressModal();
            modal.clearAndAddMessage('Undoing the previous rename...');
        } else { // We are using a new name
            modal = createProgressModal(() => {
                renameFeeder(newName, oldServerName);
            });
            modal.clearAndAddMessage('Renaming this feeder file...');
            modal.finishButton.onclick = () => { // good
                gThisFeederName = newName;
                document.getElementById('menuLeft').querySelector('h4').textContent = newName;
                modal.hide();
            }
        }
    }
    await $.ajax({
        url: `/renameFeeder/${gThisOwner}/${gThisModelName}/${oldServerName}/${newName}/${gThisFeederNum}`
    }).done(function(data) {
        if (showModal === true) {
            if (data === 'Failure') {
                modal.clearAndAddMessage('Rename operation failed.');
                modal.hideCancelButton();
            } else {
                modal.clearAndAddMessage('Success. This feeder file was renamed.');
            }
            modal.finish();
        }
    }).fail(function() {
        modal.clearAndAddMessage('The server raised an internal exception during the rename operation.')
        modal.hideCancelButton();
        modal.finish();
    });
}

{% endif %}

function reloadWrapper() {
    // Force the client to always request new files from the server without using the browser cache. 
    window.location.reload(true);
}

const progressModalPrototype = {
    /**
     * This function is called to remove the spinner and show the "OK" button
     * @param {Function} func - An additional function to execute when the "OK" button is clicked
     */
    finish(func) {
        if (func != null) func(); // This line makes it possible to execute ANOTHER function during "modal.finish()", although it isn't used anywhere
        this.spinner.style.display = 'none';
        this.finishButton.removeAttribute('style');
    },

    hide() {
        this.self.style.display = 'none';
    },

    _clearMessages() {
        Array.from(this.messageDiv.children).forEach(element => element.remove());
    },

    clearAndAddMessage(message) {
        this._clearMessages();
        this.addMessage(message);
    },

    addMessage(message) {
        const h2 = document.createElement('h2');
        h2.textContent = message;
        this.messageDiv.append(h2);
    },

    hideCancelButton() {
        this.cancelButton.style.display = 'none';
    }
}

/**
 * @param {Function} cancelFunc - (optional) if provided, this function will execute when the "Cancel" button is clicked on the modal. If not
 *     provided, the "Cancel" button is never shown to the user
 */
function createProgressModal(cancelFunc=null) {
    const obj = Object.create(progressModalPrototype);
    obj.self = document.getElementById('progressModal');
    obj.messageDiv = obj.self.querySelector('div.progressModalMessages');
    obj._clearMessages();
    obj.cancelButton = obj.self.querySelector("button[data-buttonfunction='cancel']");
    obj.cancelButton.textContent = 'Cancel'; // reset the "Cancel" button just in case it was changed
    obj.finishButton = obj.self.querySelector("button[data-buttonfunction='submit']");
    obj.finishButton.textContent = 'OK'; // reset the "OK" button just in case it was changed
    obj.finishButton.style.display = 'none'; // Always hide the "OK" button initially
    obj.finishButton.onclick = () => { obj.hide(); }
    if (cancelFunc == null) {
        obj.cancelButton.style.display = 'none';
        obj.cancelButton.onclick = null;
    } else {
        obj.cancelFunc = cancelFunc;
        obj.cancelButton.onclick = obj.cancelFunc;
        obj.cancelButton.removeAttribute('style');
    }
    obj.spinner = obj.self.querySelector('img');
    obj.spinner.removeAttribute('style');
    obj.self.removeAttribute('style');
    return obj;
}

/**
 * Return true if this TreeWrapper can be moved, otherwise return false;
 * @return {boolean}
 */
function isValidForMove(objects) {
    if (objects.length === 0) {
        alert(`Please select at least one circle to move.`);
        return false
    }
    const names = getNamesOfTypes(objects, "line");
    if (names.length !== 0) {
        alert(`Lines cannot be moved. Please unselect the following lines: ${names.join(", ")}.`);
        return false
    }
    return true
}

/**
 * This cannot be used directly for placing new components, because this function assumes that all objects
 * that are being moved already exist in the data. Its only acceptable for this function to be canceled
 * if the objects have already all been drawn.
 * @param {Array} keys
 */
function attachMoveListener(keys, tBody=null, tObject=null) {
    const objects = [];
    keys.forEach(key => {
        objects.push(gTree.getObject(key));
    });
    if (isValidForMove(objects)) {
        const element = document.getElementById("svgContainer");
        element.setAttribute("style", "cursor: crosshair");
        const moveNodes = getMoveNodesFunction(objects, tBody, tObject);
        element.onclick = function(event) {
            moveNodes(event);
            createSvgData(keys).draw(gViewport);
        }
    }
}

/**
 * Translate the 'longitude' and 'latitude' properties of all nodes in this TreeWrapper according
 * to the arguments.
 * 
 * These x, y coordinate arguments are relative to the viewport, which means they have a minimum
 * value of 0 and that the gMinLon and gOffsetY must be added to them before they are real 
 * coordinates to be stored in the tree.
 * @param {number} x - an x coordinate relative to the viewport, usually created with a click on the screen.
 * @param {number} y - a y coordinate relative to the viewport, usually created with a click on the screen.
 */
function move(objects, {x, y}) {
    let offsetX = gMinLon, offsetY = gMaxLat, scaleFactor = gDrawScaleFactor;
    if (arguments[2] != null) {// needed for testing
        offsetX = arguments[2].offsetX;
        offsetY = arguments[2].offsetY;
        scaleFactor = arguments[2].scaleFactor;
    }
    const nodes = [];
    let avgLon = 0;
    let avgLat = 0;
    objects.forEach(obj => {
        if (getRelationship(obj) !== "line") {
            nodes.push(obj);
            avgLon += obj.longitude;
            avgLat += obj.latitude;
        }
    });
    if (nodes.length === 0) return;
    avgLon /= nodes.length;
    avgLat /= nodes.length;
    nodes.forEach(node => {
        node.longitude = node.longitude - avgLon + offsetX + x/scaleFactor;
        //node.latitude = node.latitude - avgLat + offsetY + y/scaleFactor;
        node.latitude = node.latitude - avgLat + offsetY - y/scaleFactor;
    });
}

/**
 * TODO: do some sort of pre-scan to find an empty square in the graph to insert the configuration objects.
 * Parse this TreeWrapper.tree and insert longitude and latitude properties if a non-line type object does not contain them.
 * @param {number} initX - the longitude of the top left corner of the square.
 * @param {number} initY - the latitude of the top left corner of the square.
 * @param {number} spacing - how far apart the nodes should be spaced from one another
 * 
 * @param {Array} objects - the objects that need coordinates
 */
function insertCoordinates(objects, initX, initY, spacing) {
    let gen = getCoordinates(initX, initY, spacing);
    objects.forEach(obj => {
        if (getRelationship(obj) !== "line" && (obj.longitude == null || obj.latitude == null)) {
            let coords = gen.next().value;
            obj.longitude = coords.longitude;
            obj.latitude = coords.latitude;
        }
    });
}

/**
 * TODO: rename this function or delete it
 * @param {Object[]} objects
 * @param {string[]} types
 * @return string[]
 */
function getNamesOfTypes(objects, ...types) {
    return objects.filter(obj => {
        const relationship = getRelationship(obj);
        return types.includes(relationship);
    }).map(obj => obj.name !== undefined ? obj.name : Object.values(obj)[0]);
}

/**
 * good. No unit tests need.
 * @param {Object[]} selection
 * @param {Object} component
 * @return {boolean}
 */
function isValidForAdd(keys, component) {
    const selection = keys.map(key => gTree.getObject(key));
    const relationship = getRelationship(component);
    const configNames = getNamesOfTypes(selection, "configurationNode");
    const lineNames = getNamesOfTypes(selection, "line");
    const errorMsgStart = `This component "${component.object}" `;
    const errorMsgConfig = `Please unselect the following configuration nodes: "${configNames.join(", ")}" before trying to add this component again.`;
    const errorMsgLine = `Please unselect the following lines: "${lineNames.join(", ")}" before trying to add this component again.`;
    switch (relationship) {
        case "independentNode":
        case "configurationNode":
            if (selection.length !== 0) {
                alert(errorMsgStart + "cannot be inserted using other objects. Please unselect all objects before adding this component again.");
                return false;
            }
            break;
        case "childNode":
            if (configNames.length > 0) {
                alert(errorMsgStart + "cannot be added as a child of a configuration node. " + errorMsgConfig);
                return false;
            }
            if (lineNames.length > 0 && component.object !== "recorder") {
                alert(errorMsgStart + "cannot be added as a child of a line. " + errorMsgLine);
                return false;
            }
            break;
        case "line":
            if (selection.length === 1) {
                alert("Please select at least 2 circles to add this line.");
                return false;
            } else if (configNames.length > 0) {
                alert(errorMsgStart + "cannot be connected to configuration nodes. " + errorMsgConfig);
                return false;
            } else if (lineNames.length > 0) {
                alert(errorMsgStart  + "cannot be connected to lines. " + errorMsgLine);
                return false;
            } 
            /* If any nodes in the selection already have a line between them, fail. special case will require refactor of this method */
            for (let i = 0; i < keys.length; i++) {
                const pairedNodes = gTree.getPairedNodeKeys(keys[i]);
                if (pairedNodes != null) {
                    let previouslyConnectedNodes = pairedNodes.filter(key => keys.includes(key));
                    if (previouslyConnectedNodes.length > 0) {
                        alert(`Insertion failed. The node named "${gTree.getObject(keys[i]).name}" is already connected to nodes "${previouslyConnectedNodes.map(key => gTree.getObject(key).name).join(", ")}".`);
                        return false;
                    }
                }
            }
            break;
    }
    return true;
}

//**************************************************
// Public utility functions
//**************************************************

/**
 * There are 4 relationships of objects: lines, child nodes, independent nodes, and configuration nodes.
 * The line between a parent and child doesn't exist in the data itself, it's merely shown in the svg
 * to demonstrate the relationship between two nodes.
 */

/**
 * Return true if the string is a valid number, otherwise return false. Thanks stackoverflow.
 * @param {string}
 * @return {boolean}
 */
function isNumberString(str) {
    if (typeof str !== "string" || /\s/.test(str)) {
        //console.error(`Expected "${str}" to be a string without whitespace, but it was not.`);
        return false;
    } 
    if (isNaN(str) || isNaN(parseFloat(str))) {
        //console.error(`Expected "${str}" to be a string that could be parsed to a number, but it was not.`);
        return false;
    }
    return true;
}

/**
 * Return the relationship of the object with regard to this interface.
 *
 * This function is important because the order in which an object is checked matters. For example, an object could be both a 'line' relationship and
 * a 'configurationNode' relationship, but the 'line' relationship should take precedence over the 'configurationNode' relationship, so 'line' should
 * be returned.
 * @param {Object} obj
 * @return {string}
 */
function getRelationship(obj) {
    if (isLine(obj)) {
        return "line";
    } else if (isConfigurationNode(obj)) {
        return "configurationNode";
    } else if (isChildNode(obj)) {
        return "childNode";
    }
    return "independentNode"
}

/** 
 * Return an object that is a copy of the argument object. JSON.stringify() has many limitations so be careful!.
 * 
 * @param {Object} oldObject - the object to copy.
 * @return {Object} - a copy of the oldObject.
 */
 function deepCopy(oldObject) {
    if (Object.getPrototypeOf(oldObject) !== Object.prototype) {
        throw new Error("This function cannot be used to copy objects that are not plain JavaScript objects.");
    }
    const properties = Object.getOwnPropertyNames(oldObject);
    const keys = Object.keys(oldObject);
    for (let key of keys) {
        if (typeof(oldObject[key]) === "function") {
            throw new Error("This function cannot be used to copy objects with methods.");
        } else if (oldObject[key] === undefined) {
            // JSON.stringify will not copy a property of an object with an undefined value.
            throw new Error("JSON.stringify silently ignores properties with undefined values, so this function cannot handle undefined values.");
        }
    }
    return JSON.parse(JSON.stringify(oldObject));
}

/**
 * TODO: add unit tests, refactor to allow testing any tree
 * @return {Array} - an object with keys "childNode", "line", "independentNode", "configurationNode", with each key referencing an array of object
 * types.
 */
function getRelationshipsWithTypes() {
    const relationships = {};
    Object.values(gTree.tree).forEach(obj => {
        const type = obj.object;
        const relationship = getRelationship(obj);
        if (type != null) {
            if (relationships[relationship] == null) relationships[relationship] = [];
            if (!relationships[relationship].includes(type)) relationships[relationship].push(type);
        }
    });
    return relationships;
}

/**
 * Doesn't need unit tests.
 */
function enableDrag(element) {
    if (window.jQuery != null) {
        element.style.left = "50vw";
        $(element).draggable();
    }
}

/**
 * @param {Function} - the function to call on each element of the array of strings.
 *
 * This function is like <Array>.forEach(), but 1) it assumes the <Array> contains only strings 2) it iterates over the array in caseless sorted order
 * 3) it must be used with bind()
 */
 function alphabeticalForEach(func) {
    const sorted = this.map(casedWord => casedWord.toLowerCase()).sort().map(lowercaseWord => {
        return this.find(casedWord => casedWord.toLowerCase() === lowercaseWord);
    });
    sorted.forEach((casedWord, idx, ary) => {
        func(casedWord, idx, ary);
    });
}

/**
 * Return the minimum and maximum values inside of an object or an object of objects.
 * 
 * @param {Object} object - the object within which to find the minimum and maximum values.
 * @param {Object} objectContainer - an object which has other objects as properties.
 * @param {Array} properties - the properties to scan for min and max values across all objects in the objectContainer.
 * @return {Object}
 */
function getMinMax({object=null, objectContainer=null, properties=null}) {
    if (object != null) {
        let min, max;
        const values = Object.values(object);
        values.forEach(val => {
            val = parseFloat(val);
            if (!isNaN(val)) {
                if (min == null) {
                    min = val;
                    max = val;
                } else {
                    if (val < min) min = val;
                    if (val > max) max = val;
                }
            }
        });
        return {
            min: min,
            max: max
        }
    }
    if (objectContainer != null && properties != null) {
        const minMax = {};
        const objects = Object.values(objectContainer);
        properties.forEach(prop => minMax[prop] = {});
        objects.forEach(obj => {
            properties.forEach(prop => {
                const propVal = parseFloat(obj[prop]);
                if (!isNaN(propVal)) {
                    if (minMax[prop].min == null) {
                        minMax[prop].min = propVal;
                        minMax[prop].max = propVal;
                    } else {
                        if (propVal < minMax[prop].min) minMax[prop].min = propVal;
                        if (propVal > minMax[prop].max) minMax[prop].max = propVal;
                    }
                }
            });
        });
        return minMax;
    }
}

/**
 * Doesn't need unit tests.
 * @param {HTMLElement} e
 */
 function getStyleAttribute(e) {
    const tagName = e.tagName.toLowerCase();
    return tagName === "circle" ? "fill" : "stroke";
}

/**
 * TODO: add unit tests
 * @param {string} rgba
 * @return {string|undefined}
 */
function getAlpha(rgba) {
    if (/rgba\(/.test(rgba)) {
        return rgba.match(/\d[^,]*\d(?=\))/)[0];
    }
}

/**
 * Doesn't need unit tests
 * @param {string} className
 * @return {string}
 */
function getDefaultFill(className) {
    const cssRule = getCSSRule(className);
    return cssRule.style.fill;
}

/**
 * Doesn't need unit tests.
 * @param {string} className
 * @return {string}
 */ 
function getDefaultStroke(className) {
    const cssRule = getCSSRule(className);
    return cssRule.style.stroke;
}

/**
 * @param {string} rgb
 * @param {number} alpha
 * @return {string}
 */
function insertAlpha(rgb, alpha) {
    if (!/rgb\(/.test(rgb)) throw new Error("rgb argument must be an 'rgb' string, not an 'rgba' string");
    return rgb.replace(")", `, ${alpha})`).replace("b", "ba");
}

/**
 * Doesn't need unit tests. Tested via color().
 * @param {HTMLElement} e - the HTMLElement to color.
 * @param {string|Object} rgb - either an "rgb()" string or an instance of custom class from chroma.js
 */
function preserveAlphaWithNewColor(e, rgb) {
    if (typeof rgb === "string") {
        if (!/rgb\(/.test(rgb)) throw new Error("rgb argument must be an 'rgb' string, not an 'rgba' string");
    } else {
        rgb = rgb.css().replace(/,/g, ", ");
    }
    const firstThreeNumbers = /(\d+[^\d]+){2}\d+/;
    const styleAttribute = getStyleAttribute(e);
    const oldColor = e.style[styleAttribute];
    const alpha = getAlpha(oldColor);
    const defaultColorValues = (styleAttribute === "fill" ? getDefaultFill(e.classList[0]) : getDefaultStroke(e.classList[0])).match(firstThreeNumbers)[0];
    if (alpha != null) {
        e.style[styleAttribute] = insertAlpha(rgb, alpha);
        //e.style[styleAttribute] = rgb.replace(")", `, ${alpha})`).replace("b", "ba");
        return;
    }
    if (rgb.match(firstThreeNumbers)[0] === defaultColorValues) {
        e.removeAttribute("style");
        return;
    }
    e.style[styleAttribute] = rgb;
    return;
}

/**
 * Doesn't need unit tests. Tested via setAlpha().
 * Set the style of the HTMLElement to either its exisitng inline color with a new alpha value, or the default CSS coloring with the alpha value.
 * @param {HTMLElement} e
 * @param {number} alpha
 */
function preserveColorWithNewAlpha(e, alpha) {
    if (typeof alpha !== "number") throw new Error("New alpha value must be a number");
    if (alpha > 1 || alpha < 0) throw new Error("New alpha value must be between 0 and 1, inclusive.");
    const firstThreeNumbers = /(\d+[^\d]+){2}\d+/;
    const styleAttribute = getStyleAttribute(e);
    let inlineColorValues = e.style[styleAttribute].match(firstThreeNumbers);
    if (inlineColorValues == null) {
        if (alpha === 1) {
            e.removeAttribute("style");
            return;
        } else {
            let rgba = styleAttribute === "fill" ? getDefaultFill(e.classList[0]) : getDefaultStroke(e.classList[0]);
            rgba = insertAlpha(rgba, alpha);
            //rgba = rgba.replace(")", `, ${alpha})`).replace("b", "ba");
            e.style[styleAttribute] = rgba;
            return;
        }
    } 
    inlineColorValues = inlineColorValues[0];
    const defaultColorValues = (styleAttribute === "fill" ? getDefaultFill(e.classList[0]) : getDefaultStroke(e.classList[0])).match(firstThreeNumbers)[0];
    if (inlineColorValues === defaultColorValues && alpha === 1) {
        e.removeAttribute("style");
        return;
    } else {
        e.style[styleAttribute] = `rgba(${inlineColorValues}, ${alpha})`;
        return;
    }
}

/**
 * Determine whether or not this interface was loaded as a static file or as part of a web server request.
 */
function interfaceIsStatic() {
    return document.getElementById("panZoomInsert").textContent.trim() !== ""
}

/**
 * Determine whether or not to force the user to save their feeder. This might not always be sufficient, due to the many limitations of using JSON.stringify().
 */
function feederNeedsSave() {
    return JSON.stringify(gReadFeeder) !== JSON.stringify(gWriteFeeder);
}

//**************************************************
// Private utility functions
//**************************************************

/**
 * Return true if the object has a 'parent' property, otherwise return false.
 * @param {Object} obj
 * @return {boolean}
 */
function isChildNode(obj) {
    return obj.parent !== undefined;
}

/**
 * Return true if the object has 'from' and 'to' properties, otherwise return false.
 * @param {Object} obj
 * @return {boolean}
 */
function isLine(obj) {
    return obj.from !== undefined && obj.to !== undefined;
}

/**
 * Return true if the object is a configuration node.
 * @param {Object} obj
 * @return {boolean}
 */
function isConfigurationNode(obj) {
    if (obj.object == null || configurationTypes.includes(obj.object)) return true;
    return false;
}

/**
 * TODO: add unit tests!
 * Return the document CSSStyleRule that applies to the class name.
 * @param {string} className
 * @return {CSSStyleRule}
 */
function getCSSRule(className) {
    const cssRules = document.styleSheets[0].cssRules;
    const keys = Object.keys(cssRules);
    let key = keys.find(key => {
        const selectorString = cssRules[key].selectorText;
        if (selectorString == null) return false;
        const ary = selectorString.split(",").map(string => string.trim());
        return ary.includes(`.${className}`);
    });
    if (key == null) {
        let relationship;
        try {
            // Need try-catch because player objects have an "object" property but don't exist in components
            relationship = getRelationship(gComponentManager.getFirst(className));
        } catch (e) {
            relationship = "not a line";
        }
        if (relationship === "line") {
            key = keys.find(key => cssRules[key].selectorText === "line");
        } else {
            key = keys.find(key => cssRules[key].selectorText === "circle");
        }
    }
    return cssRules[key];
}

/**
 * Return a generator that will provide the longitude and latitude for an object.
 * 
 * @param {number} initX - the longitude of the top left corner of the square.
 * @param {number} initY - the latitude of the top left corner of the square.
 * @param {number} spacing - how far apart to space a node from adjacent nodes in the square.
 * @return {Generator}
 */
function * getCoordinates(initX, initY, spacing) {
    yield {
        longitude: initX,
        latitude: initY
    }
    let x = 0;
    let y = 0;
    let dimension = 1;
    while (true) {
        if (x <= dimension) {
            yield {
                longitude: initX + (x++ * spacing),
                latitude: initY + (dimension * spacing)
            }
        } else {
            yield {
                longitude: initX + (dimension * spacing),
                latitude: initY + (y++ * spacing)
            }
        }
        if (y === dimension) {
            dimension++;
            x = 0;
            y = 0;
        }
    }
}

//**************************************************
// OpacityManager class
//**************************************************

const opacityManagerPrototype = {

    /* Public methods */

    /**
     * Doesn't need unit tests.
     * Fill the document opacity modal HTMLElement with content.
     */
    buildOpacityModal() {
        const modal = document.getElementById("opacityModal");
        const tableDiv = modal.querySelector("[data-tableinsert]");
        Array.from(tableDiv.children).forEach(child => {
            child.parentElement.removeChild(child);
        });
        const table = document.createElement("table");
        const titleRow = document.createElement("tr");
        ["", "Object", "Opacity"].forEach(str => {
            const td = document.createElement("td");
            td.classList.add("centered");
            td.classList.add("fullPadded");
            const h = document.createElement("h3");
            h.textContent = str;
            td.append(h);
            titleRow.append(td);
        });
        table.append(titleRow);
        const that = this;
        alphabeticalForEach.bind(Object.keys(that.types))(type => {
            const tr = document.createElement("tr");
            let td = document.createElement("td");
            td.classList.add("fullPadded");
            const btn = getTableButton("Highlight", () => this.highlight(type));
            td.append(btn);
            tr.append(td);
            td = document.createElement("td");
            td.classList.add("fullPadded");
            td.textContent = type;
            tr.append(td);
            td = document.createElement("td");
            td.classList.add("fullPadded");
            const input = document.createElement("input");
            input.classList.add("modalInput");
            input.dataset.objecttype = type;
            input.addEventListener("change", function() {
                that.setAlpha({className: type, input: this});
            });
            input.value = this.types[type];
            td.append(input);
            tr.append(td);
            table.append(tr);
        });
        tableDiv.append(table);
        modal.removeAttribute("style");
        if (window.jQuery != null) {
            $("#opacityModal .modalContent").draggable();
        }
    },

    /**
     * Set the alpha value on all HTMLElements with the specified class name.
     * @param {string} className
     * @param {HTMLInputElement} input
     * @param {string} value
     */
    setAlpha({className, input, value=null}) {
        let alpha;
        if (input != null) {
            alpha = input.value;
        } else if (value != null) {
            alpha = value;
        }
        if (isNumberString(alpha)) {
            alpha = parseFloat(alpha);
            if (alpha < 0 || alpha > 1) {
                alert("The opacity value must be between 0 and 1, inclusive.");
                input.value = this.types[className];
                return;
            }
        } else {
            alert("Please enter a valid number between 0 and 1, inclusive.");
            input.value = this.types[className];
            return;
        }
        this.types[className] = alpha; //record the alpha in the gOpacityManager for the case of adding new elements.
        const elements = Array.from(document.getElementsByClassName(className));
        elements.forEach(e => {
            preserveColorWithNewAlpha(e, alpha);
        });
    },

    /**
     * Doesn't need unit tests.
     * Update the OpacityManager to always display existing object types.
     */
    update() {
        const existingObjectTypes = [];
        Object.values(getRelationshipsWithTypes()).forEach(ary => {
            ary.forEach(type => existingObjectTypes.push(type));
        });
        existingObjectTypes.forEach(type => {
            if (this.types[type] == null) {
                // User added a new objectType, so add it
                this.types[type] = 1.0;
            }
        });
        Object.keys(this.types).forEach(type => {
            if (!existingObjectTypes.includes(type)) {
                // User deleted all of a previously existing objectType, so delete it
                delete this.types[type];
            }
        });
    },

    /* Private methods */

    /**
     * Set the alpha of every other object type to 0.1.
     * @param {string} className
     */
    highlight(className) {
        Object.keys(this.types).forEach(key => {
            if (key !== className) {
                this.types[key] = 0.1;
                this.setAlpha({className: key, value: "0.1"});
            } else {
                this.types[key] = 1;
                this.setAlpha({className: key, value: "1"});
            }
        });
        const opacityModal = document.getElementById("opacityModal");
        const classInput = opacityModal.querySelector(`input[data-objecttype='${className}']`);
        Array.from(opacityModal.querySelectorAll("input[data-objecttype]")).forEach(input => {
            if (input !== classInput) {
                input.value = 0.1;
            } else {
                input.value = 1;
            }
        }); 
    },

    /**
     * Set the alpha of every object type to 1.
     */
    reset() {
        Object.keys(this.types).forEach(key => {
            this.types[key] = 1.0;
            this.setAlpha({className: key, value: "1.0"});
        });
        Array.from(document.getElementById("opacityModal").querySelectorAll("input[data-objecttype]")).forEach(input => {
            input.value = 1.0;
        });
    },
};

/**
 * An OpacityManager is really setting alpha values on HTMLElements, but the term "opacity" is more straightforward.
 */
function createOpacityManager() {
    const om = Object.create(opacityManagerPrototype);
    om.types = {};
    Object.values(getRelationshipsWithTypes()).forEach(ary => {
        ary.forEach(type => {
            om.types[type] = 1.0;
        });
    });
    return om;
}

//**************************************************
// Coloring classes
//**************************************************

const colorMapPrototype = {

    /* Public methods */

    /**
     * Apply a color to each HTMLElement that maps to an object that exists in this ColorMap. If any element had an alpha value, preserve it.
     */ 
    color() {
        const invalidNames = [];
        Object.keys(this.colorMap).forEach(name => {
            try {
                const key = gTree.treeMap.getKey(name);
                const e = document.getElementById(key);
                preserveAlphaWithNewColor(e, this.colorMap[name]);
            } catch (e) {
                invalidNames.push(name);
            }
        });
        if (invalidNames.length > 0) {
            alert(`Unable to color the following objects because they weren't found in this graph: "${invalidNames.join(", ")}".`);
        } else {
            alert(`Successfully colored all objects according to the specified column "${this.title}" in the specified csv file "${this.parentTitle}".`);
        }
    },

    /**
     * TODO: break up into smaller methods?
     * Doesn't need unit tests.
     * Create a legend for the color map and append it to the "colorLegends" div.
     */
    appendLegend() {
        const masterDiv = document.createElement("div");
        masterDiv.classList.add("modalContent");
        masterDiv.classList.add("centered");
        masterDiv.style.border = "1px solid black";
        masterDiv.style.alignContent = "center";
        masterDiv.setAttribute("data-colorfile", this.parentTitle);
        masterDiv.setAttribute("data-colormap", this.title);
        let h = document.createElement("h2");
        h.textContent = this.parentTitle;
        masterDiv.append(h);
        h = document.createElement("h3");
        h.textContent = this.title;
        masterDiv.append(h);
        const flexbox = document.createElement("div");
        flexbox.classList.add("legendFlex");
        let div = document.createElement("div");
        div.classList.add("legendGradiant");
        div.style.background = `linear-gradient(0deg,${gViridisColors.join(",")})`;
        flexbox.append(div);
        div = document.createElement("div");
        div.classList.add("vertFlex");
        div.classList.add("legendAxis");
        div.classList.add("leftText");
        const increment = (this.max - this.min) / 7;
        for (let i = 0; i < 8; i++) {
            let p = document.createElement("p");
            let val;
            if (i === 0) {
                val = this.min;
            } else if (i === 7) {
                val = this.max;
            } else {
                val = this.min + i * increment;
            }
            val = val.toString();
            let decimalIdx = val.indexOf(".");
            if (decimalIdx !== -1) {
                val = val.slice(0, decimalIdx + 5);
            }
            p.textContent = val;
            div.prepend(p);
        }
        flexbox.append(div);
        masterDiv.append(flexbox);
        div = document.createElement("div");
        div.style.margin = "20px 0px 0px 0px";
        const button = getTableButton("Close", () => {
            const legendDiv = document.getElementById("colorLegends");
            const legend = legendDiv.querySelector(`div[data-colorfile='${this.parentTitle}'],[data-colormap='${this.title}']`);
            legend.parentElement.removeChild(legend);
        });
        div.append(button);
        masterDiv.append(div);
        document.getElementById("colorLegends").append(masterDiv);
        enableDrag(masterDiv);
    },

    /* private methods */

    /**
     * Create a color map by mapping the 'viridis' color scale to the data inside of this.colorMap.
     */
    buildColorScale() {
        const {min, max} = getMinMax({object: this.colorMap});
        this.min = min;
        this.max = max;
        const f = chroma.scale(gViridisColors).domain([min, max]);
        Object.keys(this.colorMap).forEach(key => {
            this.colorMap[key] = f(this.colorMap[key]);
        });
        this.colorScale = f;
    }
}

/**
 * Doesn't need unit tests.
 * A ColorMap is a wrapper around an object that maps tree object names to colors.
 * @param {string} title - the header of the column in the csv that this color map is representing.
 * @param {ColorFile} parent - the ColorFile that contains this ColorMap. 
 * @return {ColorMap}
 */
function createColorMap(title, parentTitle) {
    const obj = Object.create(colorMapPrototype);
    obj.title = title;
    obj.parentTitle = parentTitle;
    obj.colorMap = {};
    return obj;
}

const colorFilePrototype = {
    
    /* Public methods */

    /* Doesn't need unit tests */
    getTable() {
        const table = document.createElement("table");
        let tr = document.createElement("tr");
        let td = document.createElement("td");
        let h = document.createElement("h4");
        h.classList.add("modalTableHeader");
        h.textContent = this.title;
        td.append(h);
        tr.append(td);
        table.append(tr);
        tr = document.createElement("tr");
        td = document.createElement("td");
        td.classList.add("fullPadded");
        const select = document.createElement("select");
        select.setAttribute("data-colorfile", this.title);
        td.append(select);
        tr.append(td);
        table.append(tr);
        this.colorMaps.forEach(cm => {
            select.innerHTML += `<option value=${cm.title}>${cm.title}</option>`
        });
        tr = document.createElement("tr");
        td = document.createElement("td");
        td.classList.add("fullPadded");
        const button = getTableButton("Color", () => {
            const colorMapName = document.getElementById("colorModal").querySelector(`select[data-colorfile='${this.title}']`).value;//need quotes around the dataset value because of the '.' in the file name.
            const colorMap = this.colorMaps.find(cm => cm.title === colorMapName);
            //If the graph hasn't been desaturated, then it needs to be. If is has been desaturated, then do nothing
            if (this.parent.graphIsDesaturated === false) {
                this.parent.desaturateGraph();
            }
            colorMap.color();
            colorMap.appendLegend();
        });
        td.append(button);
        tr.append(td);
        table.append(tr);
        return table;
    },

    /* Private methods */

    /**
     * TODO: add unit tests
     * Build an array of ColorMaps by parsing the csv file and return the array.
     * @param {File} file
     * @return {Promise}
     */
    buildColorMaps(file) {
        const that = this;
        return new Promise(function(resolve, reject) {
            Papa.parse(file, {
                dynamicTyping: true,
                complete: function(results, file) {
                    const colorMaps = [];
                    try {
                        const headerRow = results.data[0];
                        for (let i = 1; i < headerRow.length; i++) {
                            colorMaps.push(createColorMap(headerRow[i], that.title));
                        }
                        for (let i = 1; i < results.data.length; i++) {
                            let row = results.data[i];
                            for (let j = 1; j < row.length; j++) {
                                colorMaps[j - 1].colorMap[row[0]] = row[j];
                            }
                        }
                        colorMaps.forEach(cm => cm.buildColorScale());
                        resolve(colorMaps);
                    } catch (e) {
                        reject();
                    }
                }
            });
        });
    }
}

/**
 * A ColorFile is a grouping of associated ColorMap objects.
 * @param {File} file - a csv file that maps the name of an object in this tree data to other data.
 * @return {ColorFile}
 */
async function createColorFile(file, parent) {
    const obj = Object.create(colorFilePrototype);
    obj.title = file.name;
    obj.parent = parent;
    obj.colorMaps = await obj.buildColorMaps(file);
    return obj;
}

const colorManagerPrototype = {

    /* Public methods */

    /**
     * Doesn't need unit tests.
     * Load the CSV files into ColorFile objects and fill the color modal HTML with content.
     * 
     * @param {FileList} files - the CSV files to be used to color the graph.
     */
    async buildHTML(files) {
        this.colorFiles = await this.buildColorFiles(Array.from(files));
        const tableDiv = document.getElementById("colorModal").querySelector("div[data-tableinsert]");
        while (tableDiv.firstChild) {
            tableDiv.removeChild(tableDiv.firstChild);
        }
        this.colorFiles.forEach(cf => {
            tableDiv.append(cf.getTable());
        });
    },

    /**
     * Remove all colors that were applied by all ColorMaps from all HTMLElements. If any element had an inline alpha value, preserve it.
     */
    removeColors() {
        Object.keys(gTree.tree).forEach(key => {
            const e = document.getElementById(key);
            // Need to watch out for objects that weren't drawn, like lines with non-existent node ends
            if (e != null) {
                const color = e.tagName.toLowerCase() === "circle" ? getDefaultFill(e.classList[0]) : getDefaultStroke(e.classList[0]);
                preserveAlphaWithNewColor(e, color);
            }
        });
        this.graphIsDesaturated = false;
    },

    /**
     * Prepare the graph to handle multiple overlapping ColorMap colorings by removing all special default colors from nodes and lines. For example, houses will go from blue to gray and transformers will go from yellow to gray.
     */
    desaturateGraph() {
        const cssRules = document.styleSheets[0].cssRules;
        const keys = Object.keys(cssRules);
        const circleFill = cssRules[keys.find(key => cssRules[key].selectorText === "circle")].style.fill;
        const lineStroke = cssRules[keys.find(key => cssRules[key].selectorText === "line")].style.stroke;
        Object.keys(gTree.tree).forEach(key => {
            const e = document.getElementById(key);
            // Need to watch out for data objects that weren't drawn, like lines with non-existent nodes
            if (e != null) {
                const color = e.tagName.toLowerCase() === "circle" ? circleFill : lineStroke;
                preserveAlphaWithNewColor(e, color)
            }
        });
        this.graphIsDesaturated = true;
    },

    /* Private methods */

    /**
     * Doesn't need unit tests.
     * Asynchronously create an array of ColorFiles and return it inside of a Promise.
     * @param {Array} files
     * @return {Promise}
     */
    buildColorFiles(files) {
        const that = this;
        return new Promise(async function(resolve, reject) {
            const colorFiles = [];
            for (let file of files) {
                try {
                    const cf = await createColorFile(file, that);
                    colorFiles.push(cf);
                } catch (e) {
                    alert(`We could not parse the CSV file "${file.name}" that you provided.`);
                }
            }
            resolve(colorFiles);
        });
    }
}

/**
 * Doesn't need unit tests.
 * A ColorManager object contains ColorFile objects.
 * @return {ColorManager}
 */
function createColorManager() {
    const obj = Object.create(colorManagerPrototype);
    obj.graphIsDesaturated = false;
    //obj.colorFiles = await obj.buildColorFiles(Array.from(files));
    return obj;
}

//**************************************************
// SVG classes
//**************************************************

const circlePrototype = {
    /**
     * good. doesn't need tests
     */
    getNewInstance() {
        const circle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
        this.update(circle);
        return circle; 
    },
    /**
     * good. doesn't need tests
     */
    update(circle) {
        if (circle.classList.contains("selected")) {
            circle.setAttribute("class", `${this.class} selected`);
        } else {
            circle.setAttribute("class", this.class);
        }
        circle.setAttribute("id", this.id);
        circle.setAttribute("r", this.r);
        circle.setAttribute("stroke-width", this["stroke-width"]);
        circle.setAttribute("cx", this.cx);
        circle.setAttribute("cy", this.cy);
        if (this.fill != null) {
            circle.setAttribute("style", `fill: ${this.fill}`);
        }
    }
};

/**
 * good. doesn't need unit tests
 */
function createCircle(nodeKey) {
    const circle = Object.create(circlePrototype);
    let tree = gTree;
    if (arguments[1] != null) tree = arguments[1]; // Need this for testing
    const node = tree.getObject(nodeKey);
    circle.id = nodeKey;
    circle.class = node.object;
    circle.r = 2 * gScaleLevel;
    circle["stroke-width"] = .5 * gScaleLevel;
    const lon = node.longitude;
    if (typeof lon !== "number") throw new Error(`'longitude' must be a number.`);
    const lat = node.latitude;
    if (typeof lat !== "number") throw new Error(`'latitude' must be a number.`);
    circle.cx = (lon - gMinLon) * gDrawScaleFactor;
    circle.cy = (gMaxLat - lat) * gDrawScaleFactor;
    const alpha = gOpacityManager.types[node.object];
    if (alpha != null && alpha !== 1) {
        const newFill = insertAlpha(getDefaultFill(node.object), alpha)
        circle.fill = newFill;
    }
    return circle;
}

const linePrototype = {
    /**
     * good. doesn't need tests
     */
    getNewInstance() {
        const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
        this.update(line);
        return line; 
    },

    /**
     * good. doesn't need tests
     */
    update(line) {
        if (line.classList.contains("selected")) {
            line.setAttribute("class", `${this.class} selected`);
        } else {
            line.setAttribute("class", this.class);
        }
        line.setAttribute("id", this.id);
        line.setAttribute("stroke-width", this["stroke-width"]);
        line.setAttribute("x1", this.x1);
        line.setAttribute("x2", this.x2);
        line.setAttribute("y1", this.y1);
        line.setAttribute("y2", this.y2);
        if (this.stroke != null) {
            line.setAttribute("style", `stroke: ${this.stroke}`);
        }
    }
};

/**
 * good. doesn"t need tests
 */
function createParentChildLineWithLine(lineKey, childKey) {
    let tree = gTree;
    if (arguments[2] != null) tree = arguments[2]; // Need this for testing
    const line = Object.create(linePrototype);
    const toNode = tree.getToNode(lineKey);
    const fromNode = tree.getFromNode(lineKey);
    if (toNode == null || fromNode == null) return; // The parent line could itself have nonexistent 'to' or 'from' nodes.
    const child = tree.getObject(childKey);
    line.x1 = (((toNode.longitude + fromNode.longitude)/2) - gMinLon) * gDrawScaleFactor;
    line.y1 = (gMaxLat - ((toNode.latitude + fromNode.latitude)/2)) * gDrawScaleFactor;
    line.x2 = (child.longitude - gMinLon) * gDrawScaleFactor;
    line.y2 = (gMaxLat - child.latitude) * gDrawScaleFactor;
    line.id = getParentChildLineId(lineKey, childKey, tree);    
    line.class = "parentChild";
    line["stroke-width"] = .5 * gScaleLevel;
    return line;
}

// Use to name parent-child lines like: "node18_waterheater4", but now it's just "18_4"
function getParentChildLineId(parentKey, childKey) {
    let tree = gTree;
    if (arguments[2] != null) tree = arguments[2]; // Need this for testing
    return `${parentKey}_${childKey}`;
}

/**
 * good. doesn't need tests
 */
function createParentChildLineWithNode(parentKey, childKey) {
    let tree = gTree;
    if (arguments[2] != null) tree = arguments[2]; // Need this for testing
    const line = Object.create(linePrototype);
    const parent = tree.getObject(parentKey);
    const child = tree.getObject(childKey); // Don't need to check for nonexistent parent because I already do that elsewhere
    line.x1 = (parent.longitude - gMinLon) * gDrawScaleFactor;
    line.y1 = (gMaxLat - parent.latitude) * gDrawScaleFactor;
    line.x2 = (child.longitude - gMinLon) * gDrawScaleFactor;
    line.y2 = (gMaxLat - child.latitude) * gDrawScaleFactor;
    line.id = getParentChildLineId(parentKey, childKey, tree);
    line.class = "parentChild";
    line["stroke-width"] = .5 * gScaleLevel;
    return line;
}

/**
 * good. doesn't need unit tests
 */
function createLine(lineKey) {
    let tree = gTree;
    if (arguments[1] != null) tree = arguments[1]; // Need this for testing
    const line = Object.create(linePrototype);
    const toNode = tree.getToNode(lineKey);
    const fromNode = tree.getFromNode(lineKey);
    if (toNode == null || fromNode == null) return; // A line could have nonexistent 'to' or 'from' nodes
    line.x1 = (fromNode.longitude - gMinLon) * gDrawScaleFactor;
    line.y1 = (gMaxLat - fromNode.latitude) * gDrawScaleFactor;
    line.x2 = (toNode.longitude - gMinLon) * gDrawScaleFactor;
    line.y2 = (gMaxLat - toNode.latitude) * gDrawScaleFactor;
    line.id = lineKey;
    const lineObject = tree.getObject(lineKey);
    const phaseCount = countPhases(lineObject.phases);
    line.class =  `${lineObject.object} p${phaseCount}`;
    switch (phaseCount) {
        case 2:
            line["stroke-width"] = 2 * gScaleLevel;
            break;
        case 3:
            line["stroke-width"] = 3 * gScaleLevel;
            break;
        default:
            line["stroke-width"] = gScaleLevel;
    }
    const alpha = gOpacityManager.types[lineObject.object];
    if (alpha != null && alpha !== 1) {
        const newStroke = insertAlpha(getDefaultStroke(lineObject.object), alpha);
        line.stroke = newStroke;
    }
    return line;
}

const svgDataPrototype = {

    /* Public methods */

    /**
     * good. doesn't need tests
     */
    draw(viewport) {
        this.setSubtreeToRedraw();
        this.quickDraw(viewport);
    },

    /**
     * good. doesn't need tests
     * Use this function when initializing the interface because it's a bit faster since it doesn't traverse subtrees.
     */
    quickDraw(viewport) {
        this.createData();
        this.parentChildLines.forEach(line => {
            this.appendSvg(line, viewport);
        });
        this.lines.forEach(line => {
            this.appendSvg(line, viewport);
        });
        this.circles.forEach(circle => {
            this.appendSvg(circle, viewport);
        });
    },

    /**
     * Just update existing objects. This is an optimization I can worry about later.
     */
    update() {},

    /**
     * good. Doesn't need tests.
     */
    remove(viewport) {
        this.primaryKeySet.forEach(key => {
            const obj = this.tree.getObject(key);
            const relationship = getRelationship(obj);
            if (relationship === "childNode") {
                const parentKey = this.tree.treeMap.getParentKey(key);
                if (parentKey != null) { // child could have a nonexistent parent
                    const id = getParentChildLineId(parentKey, key);
                    const e = document.getElementById(id);
                    viewport.removeChild(e);
                }
            }
            const e = document.getElementById(key);
            if (gSelection.hasId(key)) gSelection.remove(e);
            viewport.removeChild(e);
        });
        this.tree.remove(Array.from(this.primaryKeySet));
    },

    /* Private methods */

    /**
     * good. doesn't need tests
     */
    appendSvg(obj, viewport) {
        const e = document.getElementById(obj.id);
        if (e != null) {
            // Element already exists. Since we are doing a full redraw, remove it, update it, and re-append it.
            e.parentElement.removeChild(e);
            obj.update(e);
            viewport.appendChild(e);
        } else {
            viewport.appendChild(obj.getNewInstance());
        }
    },

    /**
     * good.
     */
    createData() {
        this.parentChildLines = [];
        this.lines = [];
        this.circles = [];
        this.subtreeKeySet.forEach(key => {
            const relationship = getRelationship(this.tree.getObject(key));
            switch (relationship) {
                case "line":
                    const line = createLine(key, this.tree);
                    if (line != null) this.lines.push(line);
                    break;
                case "childNode":
                    this.circles.push(createCircle(key, this.tree));
                    const parentKey = this.tree.treeMap.getParentKey(key);
                    // child could have nonexistent parent. Also, we only want parent-child lines for children of objects in the subtreeKeySet
                    if (parentKey != null && this.subtreeKeySet.has(parentKey)) {
                        const parentType = getRelationship(this.tree.getObject(parentKey));
                        if (parentType === "line") {// this is only for recorders
                            const line = createParentChildLineWithLine(parentKey, key, this.tree);
                            if (line != null) this.parentChildLines.push(line);
                        } else {
                            const line = createParentChildLineWithNode(parentKey, key, this.tree)
                            if (line != null) this.parentChildLines.push(line);
                        }
                    }
                    break;
                case "independentNode":
                case "configurationNode":
                    this.circles.push(createCircle(key, this.tree));
                    break;
            };
        });
    },

    /**
     * good.
     * Get the parent, children, connected lines, children of connected lines, paired nodes, and node ends of the object being redrawn.
     */
    setSubtreeToRedraw() {
        this.primaryKeySet.forEach(key => {
            const parentKey = this.tree.treeMap.getParentKey(key);
            if (parentKey != null) {
                this.subtreeKeySet.add(parentKey);
                if (getRelationship(this.tree.getObject(parentKey)) === "line") {
                    // If the parent line is redrawn, it will cover it's connected nodes unless I do this
                    this.subtreeKeySet.add(this.tree.getToNodeKey(parentKey));
                    this.subtreeKeySet.add(this.tree.getFromNodeKey(parentKey));
                }
            }
            const children = this.tree.treeMap.getChildKeys(key);
            if (children != null) children.forEach(childKey => this.subtreeKeySet.add(childKey));
            const lines = this.tree.treeMap.getLineKeys(key);
            if (lines != null) {
                lines.forEach(lineKey => {
                    this.subtreeKeySet.add(lineKey);
                    // Must also get the children of lines! This means only recorders
                    const lineChildren = this.tree.treeMap.getChildKeys(lineKey);
                    if (lineChildren != null) lineChildren.forEach(childKey => this.subtreeKeySet.add(childKey));
                });
            }
            const pairs = this.tree.getPairedNodeKeys(key);
            if (pairs != null) pairs.forEach(nodeKey => this.subtreeKeySet.add(nodeKey));
            // Don't forget to account for adding a line, even though lines cannot be moved!
            const toNodeKey = this.tree.getToNodeKey(key);
            if (toNodeKey != null) this.subtreeKeySet.add(toNodeKey);
            const fromNodeKey = this.tree.getFromNodeKey(key);
            if (fromNodeKey != null) this.subtreeKeySet.add(fromNodeKey); 
        });
    },
}

/**
 * good. doesn't need tests
 * @param {Array} keys
 */
function createSvgData(keys) {
    const svgData = Object.create(svgDataPrototype);
    svgData.tree = gTree;
    if (arguments[1] != null) svgData.tree = arguments[1]; // Need this for testing
    svgData.primaryKeySet = new Set();
    svgData.subtreeKeySet = new Set();
    keys.forEach(key => {
        svgData.primaryKeySet.add(key);
        svgData.subtreeKeySet.add(key)
    });
    return svgData;
}

//**************************************************
// TreeObject interface
//**************************************************

const treeObjectPrototype = {

    /* Public TreeObject methods.*/

    /**
     * good. Doesn't need unit tests
     * Set the 'parent', 'longitude', and 'latitude' properties of this TreeObject.data based on the 'parent' argument.
     * @param {Object} parent - the object to set as the parent of this child.
     */
    setupChildNode(parentKey) {
        if (getRelationship(this.data) !== "childNode") throw new Error("This TreeObject should have a relationship of 'childNode'.");
        const parent = gTree.getObject(parentKey);
        const relationship = getRelationship(parent);
        if (relationship === "configurationNode") throw new Error("The 'parent' argument cannot be a configuration node.");
        this.data.parent = parent.name;
        if (relationship === "line") {
            this.setupChildNodeWithLine(parentKey);
        } else {
            this.setupChildNodeWithNode(parentKey);
        }
    },

    /**
     * good. Doesn't need unit tests
     * Set the 'from', 'to', and 'phases' properties of this TreeObject.data based on the 'source' and 'target' arguments.
     * @param {Object} source - the starting node of the line.
     * @param {Object} target - the ending node of the line.
     */
    setupLine(sourceKey, targetKey) {
        if (getRelationship(this.data) !== "line") throw new Error("This TreeObject should have a relationship of 'line'.");
        const source = gTree.getObject(sourceKey);
        const target = gTree.getObject(targetKey);
        const sType = getRelationship(source);
        const tType = getRelationship(target);
        const types = ["childNode", "independentNode"];
        if (!types.includes(sType) || !types.includes(tType)) throw new Error("The 'source' and 'target' arguments should have a relationship of 'childNode' or 'independentNode'.");
        if (source.name == null || target.name == null) throw new Error("The 'source' and 'target' arguments should have a 'name' property.");
        if (source.phases === undefined) {
            const name = source.name !== undefined ? source.name : Object.values(source)[0]; 
            alert(`The source node of this line, "${name}", does not have a 'phases' property.`);
        } else {
            this.data.phases = source.phases;
        }
        this.data.from = source.name;
        this.data.to = target.name;
    },

    /* "Private" helper methods */

    setupChildNodeWithLine(lineKey) {
        const toNode = gTree.getToNode(lineKey);
        const fromNode = gTree.getFromNode(lineKey);
        const parentLongitude = (toNode.longitude + fromNode.longitude)/2;
        const parentLatitude = (toNode.latitude + fromNode.latitude)/2;
        const lonValue = this.getRandomOffset();
        this.data.longitude = Math.random() < 0.5 ? parentLongitude + lonValue : parentLongitude - lonValue; 
        const latValue = this.getRandomOffset();
        this.data.latitude = Math.random() < 0.5 ? parentLatitude + latValue : parentLatitude - latValue;
    },

    setupChildNodeWithNode(nodeKey) {
        const parent = gTree.getObject(nodeKey);
        const lonValue = this.getRandomOffset();
        this.data.longitude = Math.random() < 0.5 ? parent.longitude + lonValue : parent.longitude - lonValue;
        const latValue = this.getRandomOffset();
        this.data.latitude = Math.random() < 0.5 ? parent.latitude + latValue : parent.latitude - latValue;
    },

    getRandomOffset() {
        return ((Math.random() * 4) + 4)/gDrawScaleFactor; 
    }
};

/**
 * Return a key value which has not been used in tree.
 * @return {string} key
 */
function getNewTreeKey(tree) { 
	let nextKey = Object.keys(tree).length;
	while(tree.hasOwnProperty(nextKey.toString())) {
		nextKey += 1;
	}
	return nextKey.toString();
}

/**
 * good
 */
// Return the number of phases a line has.
function countPhases(str) {
	let total = 0
    if (str == null) return total;
	if (str.search("A") > -1) {total++}
	if (str.search("B") > -1) {total++}
	if (str.search("C") > -1) {total++}
	return total;
}

/** 
 * Return a TreeObject.
 * 
 * A TreeObject (which is not to be confused with a more general "tree object") is either:
 * 1) a copy of a component that is in the process of being added to the tree, OR
 * 2) a copy of an existing object in the tree.
 * 
 * @param {(string|Object)} input - either a key OR a map of properties to create this TreeObject.
 * @param {TreeWrapper} tree - the treeWrapper from which to create this TreeObject.
 * return {TreeObject} - Either a new component that does not exist in the tree, or a copy of an existing tree object inside of the treeWrapper argument.
 */
function createTreeObject(input, tree) {
    if (Object.getPrototypeOf(tree) !== treePrototype) throw new Error("'tree' argument must be an instance of the Tree class.");
    const tObject = Object.create(treeObjectPrototype);
    if (typeof(input) === "string") {
        if (isNumberString(input)) {
            const obj = tree.getObject(input);
            tObject.key = input;
            tObject.data = deepCopy(obj);
            ["longitude", "latitude"].forEach(prop => {
                if (tObject.data[prop] != null && typeof tObject.data[prop] === "string") {
                    throw new Error(`TreeObject creation failed. The tree object with key: "${input}" has a string value for its "${prop}" property.`);
                }
            });
            return tObject;
        } else {
            throw new Error(`TreeObject creation failed. If the 'input' argument is a string, it must be a numeric string.`);
        }
    } else if (typeof input === "object" && !Array.isArray(input)) {
        tObject.key = getNewTreeKey(tree.tree);
        tObject.data = deepCopy(input);
        if (tObject.data.name == null) throw new Error("TreeObject creation failed. The component lacks the 'name' property");
        tObject.data.name = `${tObject.data.name}_${tObject.key}`;
        ["longitude", "latitude"].forEach(prop => {
            if (tObject.data[prop] != null && typeof tObject.data[prop] === "string") {
                tObject.data[prop] = parseFloat(tObject.data[prop]);
            }
        });
        return tObject;
    } 
    throw new Error("TreeObject creation failed. The 'input' argument must be a string or an object.");
}

//**************************************************
// Modal functions 
//**************************************************

/**
 * @param {HTMLElement} modal
 */
function formatModal(modal) {
    Array.from(modal.querySelectorAll("td")).forEach(td => td.classList.add("fullPadded"));
    Array.from(modal.querySelectorAll("th")).forEach(th => th.classList.add("fullPadded"));
    Array.from(modal.querySelectorAll("button")).forEach(btn => btn.classList.add("modalButton"));
    Array.from(modal.querySelectorAll("button[data-buttonfunction='toggle']")).forEach(btn => {
        if (btn.textContent.toLowerCase() !== "select" && btn.textContent.toLowerCase() !== "save") {
            btn.classList.add("deleteButton")
        }
    });
    Array.from(modal.querySelectorAll("button[data-buttonfunction='cancel']")).forEach(btn => btn.classList.add("deleteButton"));
}

/**
 * @param {HTMLElement} modal
 */
function addModalHandlers(modal) {
    Array.from(modal.querySelectorAll("button[data-buttonfunction='toggle']")).forEach(btn => {
        btn.addEventListener("click", () => toggleDisplay(modal));
    });
}

(function setupModals() {
    Array.from(document.querySelectorAll("div.modal")).forEach(div => {
        formatModal(div);
        addModalHandlers(div);
    });
})();

//**************************************************
// Table classes 
//**************************************************

/**
 * These are names of properties in most objects in gWriteFeeder.tree that should not be deleted from objects because doing so might make that object
 * hard to identify with reference to the rest of the data.
 */
const nonDeletableProperties = ["name", "object", "from", "to", "parent", "latitude", "longitude", "configuration"];
/* If these properties were to be modified for a given gWriteFeeder.tree object, it would require significantly modifying the 
other objects.  These properties ARE technically modifiable, but allowing the user to change them would require more work 
than I think is worth it. It is easier just to create a new node.
*/
const nonModifiableProperties = ["name", "object"];
const titleProperties = ["object"];
/* This array is used to determine if an object is a configuration node, based on the "object" property of that node. If a node
lacks the "object" property entirely, then I know its a configuration node.
Player is a configuration object. Recorder can have a parent, so it is NOT a configuration object.
*/
const configurationTypes = ["regulator_configuration", "transformer_configuration", "triplex_line_configuration", "line_configuration",
"volt_var_control", "line_spacing", "climate", "overhead_line_conductor", "underground_line_conductor", "triplex_line_conductor",
"player", "schedule"];


function formatTable(table) {
    Array.from(table.querySelectorAll("td")).forEach(td => {
        td.classList.add("fullPadded");
    });
    //table.style.textalign = "left";
}

// delete this eventually
function rebuildSelectionTable() {
    destroyTables(["selectionTable"]);
    const ids = gSelection.getKeys();
    if (ids.length > 0) {
        const table = createSelectionTable(ids, gTree);
        document.getElementById("selectionTable").appendChild(table);
    } 
}
/**
 * TODO: add unit tests, $().draggable make the text unfocusable
 * If an object has no name, just get the first property in the object.
 */
function createSelectionTable(ids, tree) {
    const table = document.createElement("table");
    const tHead = document.createElement("thead");
    const tBody = document.createElement("tbody"); 
    const titleRow = createRow({key: "Selected Elements"});
    Array.from(titleRow.self.children).forEach(td => { 
        td.classList.add("tableTitle");
        td.classList.add("fullPadded");
    });
    titleRow.self.children[1].setAttribute("colspan", "2");
    titleRow.self.children[2].remove();
    tHead.append(titleRow.self);
    table.append(tHead);
    table.append(tBody);
    table.classList.add("dataTable");
    // duplicate
    const buttonRow = document.createElement("tr");
    buttonRow.classList.add("buttonRow");
    const buttonCell = document.createElement("td");
    buttonCell.setAttribute("colspan", "3");
    buttonCell.classList.add("fullPadded");
    buttonCell.append(getTableButton("move", function() {
        destroyTables(["descriptionTables"]);
        attachMoveListener(gSelection.getKeys());
    }));
    buttonRow.append(buttonCell);
    tBody.append(buttonRow);
    // duplicate
    ids.forEach(id => {
        let obj = tree.getObject(id);
        let name = obj.name != null ? obj.name : obj.object != null ? obj.object : Object.keys(obj)[0];
        const button = getTableButton("view", getDisplayTableFunction(id));
        let row = createRow({key: name, value: button, deletable: true}, document.getElementById(id));
        Array.from(row.self.children).forEach(td => {
            td.classList.add("fullPadded");
        });
        tBody.append(row.self);
    });
    enableDrag(table);
    return table;
}

/* Helper functions */

function getDisplayTableFunction(id) {
    let displayTable = function() {
        let table = document.getElementById(`descriptionTable_${id}`);
        if (table == null) {
            const table = createDescriptionTable(id);
            table.id = `descriptionTable_${id}`;
            document.getElementById("descriptionTables").append(table);
        }           
    }
    return displayTable;
}

function getTableButton(text, func) {
    const button = document.createElement("button");
    button.textContent = text;
    button.classList.add("modalButton");
    button.addEventListener("click", func);
    return button;
}


/**
 * TODO: add unit tests, don't allow longitude and latitude to be editted for lines!,
 * turn all key inputs into plain text upon clicking save (would look nice), 
 * 
 * Bugs: $().draggable() makes text unfocusable via double click. Unfortunately,
 * this is set behavior of the library because the demo on the jQuery wesbsite behaves the same way. Users must right click
 * text in a table to select it.
 * 
 * The form element is only used to take advantage of the "required" form validation functionality that is native to the
 * browser.
 */
function createDescriptionTable(id) {
    const form = document.createElement("form");
    form.classList.add("formContainer");
    const table = document.createElement("table");
    table.classList.add("dataTable");
    const tHead = document.createElement("thead");
    const tBody = document.createElement("tbody");
    // duplicate
    const buttonRow = document.createElement("tr");
    buttonRow.classList.add("buttonRow");
    const buttonCell = document.createElement("td");
    buttonCell.classList.add("fullPadded");
    buttonCell.setAttribute("colspan", "3");
    buttonRow.append(buttonCell);
    // duplicate
    form.append(table);
    table.append(tHead);
    table.append(tBody);
    tBody.append(buttonRow);
    const tObject = createTreeObject(id, gTree);
    if (getRelationship(tObject.data) !== "line") {
        buttonCell.append(createButton({action: "move", tObject: tObject, tableBody: tBody}).self);
    }
    buttonCell.append(createButton({action: "delete", tObject: tObject, tableBody: tBody}).self);
    buttonCell.append(createButton({action: "add", tObject: tObject, tableBody: tBody}).self);
    buttonCell.append(createButton({action: "save"}).self);
    form.addEventListener("submit", function(event) {
        event.preventDefault();
        // Delete the object entirely just in case parent was changed, in order to delete the old parent-child line
        const svg = createSvgData([tObject.key]);
        svg.remove(gViewport);
        gTree.insert(tObject);// re-insert the updated object. It is remapped in the process.
        svg.draw(gViewport);
        // alert("Object saved");
    });
    Object.keys(tObject.data).forEach(key => {
        let row;
        if (titleProperties.includes(key)) {
            row = createRow({key: key, tObject: tObject});
            Array.from(row.self.children).forEach(td => {
                td.classList.add("tableTitle");
                td.classList.add("fullPadded");
            });
            tHead.append(row.self);
        } else {
            row = createRow({key: key, deletable: true, tObject: tObject});
            Array.from(row.self.children).forEach(td => {
                td.classList.add("fullPadded");
            });
            tBody.appendChild(row.self);
        }
    });
    //Display key
    //row = createRow({key: "key", value: `${tObject.key}`});
    //Array.from(row.self.children).forEach(td => {
    //    td.classList.add("tableTitle");
    //});
    //tHead.append(row.self);
    //Display key
    enableDrag(table);
    return form;
}

/**
 * TODO: add unit tests
 */
 function destroyTables(ids) {
    ids.forEach(id => {
        const tableDiv = document.getElementById(id);
        Array.from(tableDiv.children).forEach(t => {
            tableDiv.removeChild(t);
        });
    });
}

const buttonPrototype = {

    /* Private helper methods */

    /**
     * TODO: update unit tests
     * Delete the TreeObject of this button from the TreeWrapper of this button
     */
    deleteObject() {
        const key = this.tObject.key;
        if (gTree.isRemovable(key)) {
            createSvgData([key]).remove(gViewport);
            rebuildSelectionTable();
        } else {
            let msg = `If you click "ok", you will delete this object and all of its connected children and/or lines. `;
            const children = gTree.treeMap.getChildKeys(key);
            if (children != null) {
                msg += `Do you want to delete "${gTree.getObject(key).name}" and its children: "${children.join(", ")}"? `;
            }
            const lines = gTree.treeMap.getLineKeys(key);
            if (lines != null) {
                msg += `Do you want to delete "${gTree.getObject(key).name}" and its lines: "${lines.join(", ")}"?`;
            }
            if (confirm(msg)) {
                const keys = gTree.getSubtreeToRemove(key);
                keys.push(key);
                createSvgData(keys).remove(gViewport);
                //console.log(document.getElementById("svgContainer").onclick);
                rebuildSelectionTable();
            }
        }
    },

    /**
     * TODO: add unit tests
     */
    validateArguments(args) {
        if (args.action === "move") {
            //if (args.tObject == null || args.tWrapper == null || args.tableBody == null) {
            //    throw new Error(`A button with a "${args.action}" action must have non-null tObject, tWrapper, and tableBody arguments`);
            //}
        } else if (args.action === "delete") {
            if (args.tObject == null || args.tableBody == null) {
                throw new Error(`A button with a "delete" action must have non-null tObject and tableBody arguments`);
            }
        } else if (args.action === "add") {
            if (args.tObject == null || args.tableBody == null) {
                throw new Error(`A button with an "add" action must have non-null tObject and tableBody arguments`);
            }
        } else if (args.action !== "save") {
            throw new Error(`The action argument must match an existing action`);
        }
    }
}

/**
 * TODO: add unit tests, DON'T remove tObject argument, remove tWrapper argument
 */
function createButton({action, tableBody=null, tObject=null}) {
    const button = Object.create(buttonPrototype);
    button.validateArguments(arguments[0]);
    button.self = document.createElement("button");
    button.self.textContent = action;
    button.self.classList.add("modalButton");
    button.tObject = tObject;
    button.tableBody = tableBody;
    button.self.type = "button";
    switch (action) {
        case "move":
            button.self.addEventListener("click", function() {
                attachMoveListener([tObject.key], tableBody, tObject);
            });
            break;
        case "delete":
            button.self.classList.add("deleteButton");
            button.self.addEventListener("click", function() {
                button.deleteObject();                
                document.getElementById("descriptionTables").removeChild(tableBody.parentElement.parentElement);
            });
            break;
        case "add":
            button.self.addEventListener("click", function() {
                const row = createRow({key: "", deletable: true, tObject: tObject});
                Array.from(row.self.children).forEach(td => {
                    td.classList.add("fullPadded");
                });
                tableBody.append(row.self);
            });
            break;
        case "save":
            button.self.type = "submit";
            break;
        default:
            throw new Error("The action argument must be a string that matches an existing action for this button.");
    }
    return button;
}

const rowPrototype = {

    /* Private helper methods */

    /**
     * Throw an error if arguments passed to createRow() were invalid.
     * @param {Object} args - an object containing the arguments that were passed to createRow().
     */
    validateArguments(args) {
        if (args.key != null && args.value != null && args.tObject != null) {
            throw new Error(`If there are key and tObject arguments, then the value of the row is determined by map[key] and passing a value
            argument is invalid`);
        } else if (args.tObject != null && args.tObject.data[args.key] === undefined && args.key !== "") {
            throw new Error("If a tObject argument is passed, the key argument should exist in that tObject.data.");
        } else if (args.key === "" && args.tObject == null) {
            throw new Error("If the key is an empty string, a tObject argument should be passed to the function");
        }
    },

    /**
     * Return false if the key already exists in the map or, otherwise return true.
     * @param {string} key - the incoming key that the user wants to write into the map belonging to this Row.
     * @return {boolean}
     */
    validateNewKey(key) {
        // These keys cannot be added becasue they would turn the object into a different type. If a user wants such an object, they should add a new one and edit its attributes.
        const invalidKeys = [undefined, "", "to", "from", "parent"];
        if (invalidKeys.includes(key)) return false;
        if (this.tObject.data[key] !== undefined) return false;
        return true;
    },

    /** 
     * Return false if the current key is an empty string, otherwise return true.
     * @return {boolean}
     */
    validateCurrentKey() {
        return this.key === "" ? false : true;
    },

    /**
     * Update a key in the map that belongs to this Row.
     * @param {HTMLInputElement} input - contains the new key that should be written to the map, if it is valid.
     */
    updateMapKey(input) {
        const newKey = input.value.trim();;
        if (this.validateNewKey(newKey)) {
            this.tObject.data[newKey] = this.tObject.data[this.key] != null ? this.tObject.data[this.key] : "";
            delete this.tObject.data[this.key];
            this.key = newKey;
        } else {
            alert(`A new attribute must not match an existing attribute. Additionally, the attributes "", "parent", "to", and "from" cannot be added.`);
            input.value = this.key;
        } 
    },
    /**
     * Return an HTMLTableCellElement.
     * @return {HTMLTableCellElement}
     */
    getKeyElement() {
        const td = document.createElement("td");
        if (this.key === "") {
            const input = document.createElement("input");
            input.classList.add("modalInput");
            td.appendChild(input);
            input.required = true;
            input.pattern = "[\\s]*[\\S]+.*";
            const that = this;
            input.addEventListener("change", function() {
                that.updateMapKey(this);
            });
        } else {
            td.textContent = this.key;
        } 
        return td;
    },

    /** 
     * Return true if the value is valid for the Row (based on the key of that Row), otherwise return false.
     * @param {string} value - a value for a corresponding key that should be validated based on the key.
     * @return {boolean}
     */
    validateNewValue(value) {
        if (this.key === "longitude" || this.key === "latitude") return isNumberString(value);
        if (this.key === "parent") {
            if (isValidParentName(value, this.tObject.object)) return true;
            return false;
        }
        if (this.key === "to" || this.key === "from") {
            if (!isValidToOrFromNode(value)) return false;
            if (this.key === "to" && this.tObject.data.from === value) return false;
            if (this.key === "from" && this.tObject.data.to === value) return false;
        }
        return true;
    },

    /** 
     * Update a value in the map that belongs to this Row.
     * @param {HTMLInputElement} input - contains the new value that should be written to the map, if the value is valid.
     */
    updateMapValue(input) {
        if (!this.validateCurrentKey()) {
            alert("Please enter a valid key for this row before entering a value.");
            input.value = "";
            return;
        }
        let newValue = input.value.trim();
        if (this.validateNewValue(newValue)) {
            if (this.key === "longitude" || this.key === "latitude") newValue = parseFloat(newValue);
            this.tObject.data[this.key] = newValue;
        } else {
            alert(`The value "${newValue}" is invalid for for the key "${this.key}" in the table.`);
            input.value = this.tObject.data[this.key];
        }
    },
    /** 
     * Return an HTMLTableRowElement.
     * @param {Array} nonModifiableProperties - a hard-coded array of properties that the user shouldn't be able to modify.
     * @return {HTMLTableRowElement}
     */
    getValueElement(nonModifiableProperties) {
        const td = document.createElement("td");
        if (typeof(this.value) === "string") {
            // Display a string with no regard to any TreeObject
            td.textContent = this.value;
            return td;
        } else if (this.value instanceof HTMLElement) {
            // Display another HTMLElement instead of a string
            td.append(this.value);
            return td;
        } else if (this.value == null) {
            if (this.tObject == null) {
                // Don't display any value
                return td;
            } else {
                // Display value within TreeObject.data
                const value = this.key === "" ? "" : this.tObject.data[this.key];
                if (this.key === 'object') {
                    td.textContent = value;
                    return td;
                }
                const input = document.createElement("input");
                input.classList.add("modalInput");
                input.value = value;
                td.appendChild(input);
                if (nonModifiableProperties.includes(this.key)) {
                    input.readOnly = true;
                } else {
                    if (this.key === "longitude") {
                        input.dataset.coordinate = "longitude";
                    } else if (this.key === "latitude") {
                        input.dataset.coordinate = "latitude";
                    }
                    const that = this;
                    input.addEventListener("change", function() {
                        that.updateMapValue(this);
                    });
                }
                return td;
            }
        }
        throw new Error("Invalid value was provided for this row");
    },

    /** 
     * TODO: add unit tests
     * Return an HTMLTableRowElement.
     * @param {boolean} deletable - whether or not the returned <td> should have a delete button element child.
     * @param {Array} nonDeletableProperties - a hard-coded array of properties that the user should not be able
     * to delete from a TreeObject.
     * @return {HTMLTableRowElement}
     */
    getDeleteElement(deletable, nonDeletableProperties) {
        const td = document.createElement("td");
        if (deletable === true && !nonDeletableProperties.includes(this.key)) {
            const btn = document.createElement("button");
            btn.innerHTML = "&#9587;"
            btn.setAttribute("class", "modalButton deleteButton"); 
            td.appendChild(btn);
            btn.addEventListener("click", () => { this.remove() });
        } 
        return td;
    },

    /**
     * TODO: update unit tests
     * Delete the row from the table. Delete the key from the map, if there was a map.
     */
    remove() {
        this.self.parentElement.removeChild(this.self);
        if (this.tObject != null) {
            delete this.tObject.data[this.key];
        } 
        // This is only used with the selection table rows (very confusing btw)
        if (this.element != null) {
            gSelection.remove(this.element);
            const table = document.getElementById(`descriptionTable_${this.element.id}`);
            if (table != null) {
                document.getElementById("descriptionTables").removeChild(table);
            }
            if (gSelection.getKeys().length === 0) {
                destroyTables(["selectionTable"]);
            }
        }
    },
}

/** 
 * Return a Row that can be appended to a table.
 * 
 * @param {string} key - the key of the row, which must be a property of the tObject.data argument if the tObject argument is not null.
 * @param {string|HTMLElement} - an optional value of the row.
 * @param {Object} map - an optional object that contains the data being manipulated by all of the rows. 
 * @param {?} value - either a string or an HTMLElement to be displayed outright, with no relationship to the tObject (which should be null if this argument is passed).
 * @param {boolean} deletable - whether or not the row should have a delete button.
 * @return {Row} - A wrapper object around the HTMLTableRowElement.
 */ 
function createRow({key, value=null, tObject=null, deletable=false}) {
    const obj = Object.create(rowPrototype);
    obj.validateArguments(arguments[0]);
    obj.key = key;
    obj.value = value;
    obj.tObject = tObject;
    //obj.map = map;
    obj.self = document.createElement("tr");
    obj.self.append(obj.getDeleteElement(deletable, nonDeletableProperties));
    obj.self.append(obj.getKeyElement());
    obj.self.append(obj.getValueElement(nonModifiableProperties));
    if (arguments[1] != null) {
        obj.element = arguments[1];
    }
    return obj;
}

//**************************************************
// Initialization
//**************************************************

/**
 * Initialize the interface. The order of the initialization functions matters. This is a function declaration instead of an automatically invoked
 * function expression because the testing code needs to call this function.
 */
async function initializeInterface() {
    if (!interfaceIsStatic()) {
        try {
            await checkServerConversion();
        } catch (e) {
        }
    }
    createInterface();
    {% if showFileMenu %}
    if (!interfaceIsStatic() && feederNeedsSave()) {
        // Save to account for objects that were given artifical grid coordinates. This will make the interface less annoying
        saveFeeder(gWriteFeeder);
    }
    {% endif %}
    attachHandlers();
    document.getElementById("loadingMessage").style.display = "none"
}
initializeInterface();

function createSingletons() {
    gOpacityManager = createOpacityManager();
    gAddManager = createAddManager();
    gSelection = createSelection();
}

function createInterface() {
    createViewport(gWriteFeeder.tree, document.getElementById("svgContainer"));
    gTree = createTree(gWriteFeeder.tree);
    const objects = Object.values(gTree.tree);
    insertCoordinates(objects, gMinLon, gMaxLat, (1000/gDrawScaleFactor) * .005);
    gViewport = document.getElementsByClassName("svg-pan-zoom_viewport")[0];
    createSingletons();
    createSvgData(Object.keys(gTree.tree)).quickDraw(gViewport);
}

function checkServerConversion() {
    return new Promise(function(resolve, reject) {
        let cancelled = false;
        let reload = false;
        const modal = createProgressModal(() => {
            if (confirm('Are you sure you want to cancel the in-progress server file conversion?')) {
                cancelled = true;
                saveFeeder(gReadFeeder);
                resolve();
            }
        });
        modal.clearAndAddMessage('Checking for an in-progress server file conversion...')
        const intervalId = setInterval(function pollServer() {
            $.ajax({
                type: "POST",
                url: "/checkConversion/{{thisModelName}}/{{thisOwner}}",
            }).done((data) => {
                if (!cancelled) {
                    if (data.exists === true) {
                        reload = true
                        modal.clearAndAddMessage('Waiting for an in-progress server file conversion to complete...');
                    } else if (data.exists === false) {
                        clearInterval(intervalId);
                        if (reload) {
                            reloadWrapper();
                        } else { // There was never an in-progress file conversion, so don't bother to reload the page
                            modal.hide();
                            resolve();
                        }
                    } else {
                        // There was an error? Notify the user, proceed as normal.
                        clearInterval(intervalId);
                        modal.clearAndAddMessage('An error occurred on the server during the file conversion process. You may save your feeder to prevent this message from appearing.')
                        modal.hideCancelButton();
                        modal.finish();
                        reject();
                    }
                } else {
                    clearInterval(intervalId);
                }
            }).fail(function() {
                if (!cancelled) {
                    clearInterval(intervalId);
                    modal.clearAndAddMessage('The server raised an internal exception while checking for an ongoing file operation.');
                    modal.hideCancelButton();
                    modal.finish();
                    reject();
                }
            });
            return pollServer;
        }(), 5000) // Execute pollServer immediately once, then return it to setInterval so that it continues to execute every 5 seconds
    });
}

    //buildFeeder();
    //const t0 = performance.now();

    /* 
    const t1 = performance.now();
    const time = t1 - t0;
    console.log(`Tree rendering time was ${time} ms`);
    */
    
    /*
    setTimeout(function() {
        const deleteSvgData = createDeletableSvgData(gTree.tree);
        deleteSvgData.deleteFrom(viewport);
    }, 2000);
    */

{% if showFileMenu %}
    /* Browsers don't show custom 'beforeunload' messages anymore due to spamming users, so don't bother setting it. Only set this listener if the
    user has unsaved changes */
    window.onbeforeunload = function(event) {
        if (feederNeedsSave()) {
            return "";
        }
    }
{% endif %}
</script>
{% if spec %}{{ spec | safe }}{% endif %}
