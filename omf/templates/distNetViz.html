<!DOCTYPE html>
<html>
<head>
	<meta charset="UTF-8">
	<style>
	* { font-family: Helvetica, Arial, Sans-Serif;}
	div.divButton {
		-webkit-touch-callout: none;
		-webkit-user-select: none;
		-khtml-user-select: none;
		-moz-user-select: none;
		-ms-user-select: none;
		user-select: none;
		cursor: pointer;
		cursor: hand; 
		position:fixed;
		width:30px;
		height:30px;
		text-align:center;
		font-size:30px;
		line-height:30px;
		color:white;
	}
	div#tableScroller {
		overflow-y: auto;
		overflow-x: hidden;
		position: fixed;
		width: 315px;
		top: 55px;
		right: 5px;
		max-height:90%;
	}
	table {
		width: 300px;
		border:1px solid black;
		border-collapse: collapse;
		text-align: left;
		table-layout:fixed;
	}
	body {margin:0px;}
	td {
		background:white;
		color:black;
		word-wrap:break-word;
	}
	th {
		background:black;
		color:white;
	}
	svg {
		position: absolute;
		left: 0%;
		top: 0%;
		width: 100%;
		height: 100%;
		z-index: -1;
	}
	#saveButton {
		float:right;
	}
	input {
		width:140px;
	}
	/* Load Spinner */
	.loader {
		margin: 60px auto;
		font-size: 10px;
		position: relative;
		text-indent: -9999em;
		border-top: 1.1em solid rgba(255, 255, 255, 0.2);
		border-right: 1.1em solid rgba(255, 255, 255, 0.2);
		border-bottom: 1.1em solid rgba(255, 255, 255, 0.2);
		border-left: 1.1em solid #ffffff;
		-webkit-transform: translateZ(0);
		-ms-transform: translateZ(0);
		transform: translateZ(0);
		-webkit-animation: load8 1.1s infinite linear;
		animation: load8 1.1s infinite linear;
	}
	.loader,
	.loader:after {
		border-radius: 50%;
		width: 10em;
		height: 10em;
	}
	@-webkit-keyframes load8 {
		0% {
			-webkit-transform: rotate(0deg);
			transform: rotate(0deg);
		}
		100% {
			-webkit-transform: rotate(360deg);
			transform: rotate(360deg);
		}
	}
	@keyframes load8 {
		0% {
			-webkit-transform: rotate(0deg);
			transform: rotate(0deg);
		}
		100% {
			-webkit-transform: rotate(360deg);
			transform: rotate(360deg);
		}
	}
	/* HEADER and MENU LINKS */
	div#header{ width:100%; min-width:1000px; height:25px; background:black; padding:0.6em 0 0.6em 0; }
	div#headInnerBlock{ width:1000px; height:40px; font-size:medium; color:white; margin:4px auto 0 auto; }
	div#menuLeft{ height:40px; float:left; font-size:medium; color:white; margin-left:5px;}
	div#menuRight{ height:40px; font-size:medium; color:white; float:right; display:flex; justify-content: space-between; width: 162px}
	div#arrow { font-size:8pt; position:absolute; margin-top:2px; margin-left:4px; display:inline; }
	ul.menu {
		position:absolute;
		top: 100%;
		left: 0;
		z-index: 1000;
		min-width: 100px;
		padding: 5px 0px 5px 0px;
		margin: 0px;
		list-style: none;
		display: none;
		text-align:left;
		background-color:#F8F8F8;
		padding:0;
		/*border: 1px solid #CCC;*/
		-webkit-border-radius: 5px;
		-moz-border-radius: 5px;
		border-radius: 5px 0px 5px 5px;
        -webkit-box-shadow: 0 11px 10px rgba(0, 0, 0, 0.2);
        -moz-box-shadow: 0 11px 10px rgba(0, 0, 0, 0.2);
        box-shadow: 0 11px 10px rgba(0, 0, 0, 0.2);
		-webkit-background-clip: padding-box; }
		ul.menu.right { right:0; left:auto; padding:5px 0px 5px 0px; overflow-y:auto; overflow-x:hidden; max-height:550px; }
		ul.menu.left { right:auto; left:auto; padding:0 0 0 0; }
		ul.menu.center { right:auto; left:-45%; }
		ul.menu li { padding:0px; }
		ul.menu li:hover { background:green; color:white; }
		ul.menu li:hover a { color:white; }
		ul.menu a { display:block; color:black; padding:4px; text-decoration: none }
		ul.menu a:hover {color:white;}
		ul.menu { display:block; color:black; padding:4px; }
		ul.menu ul.menu:hover, ul.menu:visited:hover { color:white; }
		div.buttonGroup { display:inline-block; position:relative; }   
		button.pill{
			-webkit-touch-callout: none;
			-webkit-user-select: none;
			-khtml-user-select: none;
			-moz-user-select: none;
			-ms-user-select: none;
			user-select: none;
			color:white;
			font-size:medium;     
			width: auto;
			height:35px;
			margin: 0px;
			margin-top:-5px;
			padding:0.3em;
            border-radius: 5px 5px 0 0;
			background-color:#E0E0E0;
			display:inline-block;
			border:none;background:transparent;-webkit-appearance:none;-moz-appearance:none;appearance:none;
			white-space: nowrap;
			display:inline-block;}
			button.pill:hover{background:transparent;}
			/* MODAL DIALOGS */
			.modal{
				display: none; /* Hidden by default */
				position: fixed; /* Stay in place */
				z-index: 1; /* Sit on top */
				left: 0;
				top: 0;
				width: 100%; /* Full width */
				height: 100%; /* Full height */
				overflow: hidden; /* If scroll is needed change to auto */
				background-color: rgb(0,0,0); /* Fallback color */
				background-color: rgba(0,0,0,0.4); /* Black w/ opacity */
			}
			.modalContent{
				background-color: #fefefe;
				margin: 15% auto; /* 15% from the top and centered */
				padding: 20px;
				border: 1px solid #888;
				width: 50%; /* Could be more or less, depending on screen size */
				border-radius: 5px;
				text-align: center;
			}
			#modalCancel{
				width:45px;
				font-size:small;
				background:seagreen;
				-webkit-border-radius: 5px;
				-moz-border-radius: 5px;
				border-radius: 5px;
				border: none;
				color: white;
				cursor:pointer; 
				padding:4px 6px 4px;
			}
			#blankModal{
				width: 300px;
			}
		</style>
		<script type='text/javascript' src='svg-pan-zoom.js'></script>
		<!-- <script id='feederLoadScript' type='text/javascript' src='./Data for Testing/testFeeder.js'></script> -->
		<!-- <script id='feederLoadScript' type='text/javascript' src='./Data for Testing/testFeeder Largest.js'></script> -->
		<!-- <script id='feederLoadScript' type='text/javascript' src='./Data for Testing/testFeeder Norfork.js'></script> -->
	</head>
	<body onkeypress='hotkeys()' style='width:100%;height:100%'>
		<!-- Start Controls (my-local branch)-->
		<div style='background:dimgrey; top:55px; left:5px' class='divButton' onclick='window.panZoom.zoomIn()' title='Zoom In'>+</div>
		<div style='background:dimgrey; top:95px; left:5px' class='divButton' onclick='window.panZoom.zoomOut()' title='Zoom Out'>-</div>
		<div style='background:dimgrey; top:135px; left:5px' class='divButton' onclick='window.panZoom.reset()' title='Reset Zoom'>R</div>
		<div style='background:dimgrey; top:175px; left:5px;' class='divButton' onclick='scaleTo(parseFloat(prompt("Scale line thickness by this multiple:", scaleLevel)))' title='Scale To'>S</div>
		<!-- <div style='background:navy; top:215px; left:5px' id='saveLink' class='divButton' onclick='saveSvg()' title='Save File' download>S</div> -->
		<!-- End Controls -->
		<svg id='svgContainer' xmlns='http://www.w3.org/2000/svg' style='width:100%;height:100%' onclick='svgClick(event)' onmousedown='mouseDown(event)' onmouseup='mouseUp(event)'>
			<style type="text/css">
			<![CDATA[
			.house {fill:blue;}
			.triplex_meter {fill:orange;}
			.underground_line {stroke:gray;}
			.transformer {stroke:orange;}
			.regulator {stroke:red;}
			line {stroke:black;}
			line.parentChild {stroke:LightGrey;}
			circle {stroke:white; fill:gray;}
			line.selected, circle.selected {stroke:lime;}
			]]>
		</style>
	</svg>
	<!-- Menu Bar -->
	<div id='header'>
		<div id='menuRight'>
            <div id='saveButton'>
				<div class='buttonGroup'>
				 	<button id='save' class='pill' onclick="downloadTextFile()">Save </button>
				 </div>
			</div>
			<div id='EditDiv'>
				<div class='buttonGroup'>
					<button id='editOps' class='pill' onclick='dropPill(this, "Edit")'>Edit ▾</button>
					<ul id='editMenu' class='menu right' style="display:none">
						<li><a href='javascript:showModal("findModal")'>Find...</a></li>
					</ul>
				</div>
			</div>
			<div id='addDiv'>
				<div class='buttonGroup'>
					<button id='addOps' class='pill' onclick='dropPill(this, "Add")'>Add ▾</button>
					<ul id='newObjectMenu' class='menu right' style="display:none">
						<li><a href='javascript:newNode()'>Node</a></li>
						<li><a href='javascript:newLink()'>Link</a></li>
					</ul>
				</div>
			</div>
		</div>
	</div>
	<!-- Modals: findModal -->
	<div id='findModal' class='modal'>
		<div class='modalContent' id='findModalContent' style='width:300px'>
			<table class='importOptions' style='padding:4px; word-wrap:break-word'>
				<tr>
					<td>Term</td>
					<td><input id='searchTerm' type='text'></td>
					<td id='searchHitCount' style='font-size:8pt; text-align:center'></td>
				</tr>
				<tr>
					<td><button style='width:75px' onclick='findPrevious()'>Previous</button></td>
					<td><button style='width:75px' onclick='findNext()'>Next</button></td>
					<td><button style='width:75px' onclick='closeModal("findModal")'>Cancel</button></td>
				</tr>
			</table>
		</div>
	</div>
	<div id='tableScroller'></div>
	<p id="loadingMessage" style="font-size:60pt; text-align:center; width:100%; display:inline-block">Feeder Loading...</p>
</body>
</html>
<script id='feederInsert'>
</script>
<script id='panZoomInsert'>
</script>
<script type='text/javascript'>
var previousTarget = {} // Global to keep track of previous selection target
var selection = [] // Global to keep track of multiple alt-selections
var downX, downY, upX, upY // Globals to keep track of mouse coordinates
var newNodeGenObj = {};
var lastElementSelected = {}// Global to keep track of last element, for use in movebus function
var searchCursor // Keeping track of search location
var scaleLevel = 1.0 // Scale that all SVG objects are drawn at

function saveSvg() {
	// Create an SVG that can be saved.
	alert('We are redirecting you to a static version of the SVG that you can save as a .svg file.')
	var svg = document.getElementById('svgContainer').outerHTML
	var win = window.open()
	win.document.write(svg)
}

function downloadTextFile() {
	// WARNING! Performance is very bad because the JSON is enormous! This can hang your browser!
	alert('We are opening a window with JSON in it that you can save as a .json file.')
	var modJson = JSON.stringify(testFeeder)
	var win = window.open()
	win.document.write(modJson)
}

function addCircle(x,y,r,id,myClass) {
	svgOb = document.getElementsByClassName('svg-pan-zoom_viewport')[0]
	aCirc = document.createElementNS('http://www.w3.org/2000/svg', 'circle')
	aCirc.setAttribute('cx', x)
	aCirc.setAttribute('cy', y)
	aCirc.setAttribute('r', r)
	aCirc.setAttribute('id', id)
	aCirc.setAttribute('class', myClass)
	aCirc.setAttribute('stroke-width', 0.5)
	svgOb.appendChild(aCirc)
}

function addLine(x1,y1,x2,y2,id,myClass) {
	svgOb = document.getElementsByClassName('svg-pan-zoom_viewport')[0]
	aLine = document.createElementNS('http://www.w3.org/2000/svg', 'line')
	aLine.setAttribute('x1', x1)
	aLine.setAttribute('y1', y1)
	aLine.setAttribute('x2', x2)
	aLine.setAttribute('y2', y2)
	aLine.setAttribute('id', id)
	aLine.setAttribute('class', myClass)
	if (myClass.indexOf('p2') !== -1) {
		w = 2
	} 
	else if (myClass.indexOf('p3') !== -1) {
		w = 3
	}
	else if (myClass.indexOf('parentChild') !== -1) {
		w = 0.5
	}
	else {
		w = 1
	}
	aLine.setAttribute('stroke-width', w)
	svgOb.appendChild(aLine)
}
function buildFeeder() {
	// Make a map objectName -> key. And while we're at it, find the size we need for the full chart.
	nameToKey = {}, maxLon = 100, maxLat = 100
	for (key in testFeeder.tree) {
		nameToKey[testFeeder.tree[key]['name']] = key
		if (testFeeder.tree[key]['longitude'] > maxLon) {maxLon = testFeeder.tree[key]['longitude']}
		if (testFeeder.tree[key]['latitude'] > maxLat) {maxLat = testFeeder.tree[key]['latitude']}
	}
	maxLon = Math.round(maxLon + 20.0)
	maxLat = Math.round(maxLat + 20.0)
	svgOb = document.getElementById('svgContainer')
	svgOb.setAttribute('width', maxLon)
	svgOb.setAttribute('height', maxLat)
	svgOb.setAttribute('viewBox','-10.0 -10.0 ' + maxLon + ' ' + maxLat)
	// Attach the pan/zoom behavior.
	window.panZoom = svgPanZoom('#svgContainer', {
		zoomEnabled: true,
		controlIconsEnabled: false,
		fit: true,
		center: true,
		minZoom: 0.5,
		maxZoom: 100
	})
	// Go through and add all lines first
	for (key in testFeeder.tree) {
		anOb = testFeeder.tree[key]
		if ('from' in anOb && 'to' in anOb) {
			fromOb = testFeeder.tree[nameToKey[anOb['from']]]
			toOb = testFeeder.tree[nameToKey[anOb['to']]]
			addLine(fromOb['longitude'],fromOb['latitude'],toOb['longitude'],toOb['latitude'],key,anOb['object'] + ' p' + phaseCount(anOb['phases']))
		}
		else if ('parent' in anOb) {
			pOb = testFeeder.tree[nameToKey[anOb['parent']]]
			addLine(pOb['longitude'],pOb['latitude'],anOb['longitude'],anOb['latitude'],pOb.name + '_' + anOb.name,'parentChild')
		}
	}
	// Add circles after all lines
	for (key in testFeeder.tree) {
		anOb = testFeeder.tree[key]
		if ('latitude' in anOb && 'longitude' in anOb && 'object' in anOb && !('from' in anOb) && !('to' in anOb)) {
			addCircle(anOb['longitude'],anOb['latitude'],2,key,anOb['object'])
		}
	}
}

function mouseDown(event) {
	downX = event.pageX
	downY = event.pageY
}
function mouseUp(event) { 
	upX = event.pageX
	upY = event.pageY
}

function svgClick(event) {
	// Listener on the SVG object that handles user clicks.
	if (downX !== upX || downY !== upY) {
		// Ignore drags, those should be handled by svz-panzoom.
		return
	}
	if (!event.altKey) {
		// Not holding alt and clicking the canvas, so clear the selection.
		for (i=0; i<selection.length; i++) {
			selection[i].classList.remove('selected')
		}
		selection = []
		tableDestroy()
	}
	if (event.target.id != 'svgContainer' && selection.indexOf(testFeeder.tree[event.target.id]) === -1 && testFeeder.tree[event.target.id] !== undefined) {
		// Clicking on an item selects it.
		lastElementSelected = (event.target)
		event.target.classList.add('selected')
		tableDestroy()
		tableCreate(testFeeder.tree[event.target.id])
		selection.push(event.target)
	}
	// Alt for multiple selection.
	if (selection.length >= 2) {
		tableDestroy()
		multiSelectionTable()
	}
	previousTarget = event.target
}

function phaseCount(p) {
	// Return the number of phases a line has.
	total = 0
	if (p.search('A') > -1) {total++}
	if (p.search('B') > -1) {total++}
	if (p.search('C') > -1) {total++}
	return total
}

function hotkeys() {
	// Handle hotkey presses.
	if (window.event) {
		// IE8 and earlier
		var x = event.keyCode
	} else if (event.which) {
		// IE9/Firefox/Chrome/Opera/Safari
		var x = event.which
	}
	var keychar = String.fromCharCode(x);
	if (event.target.type != 'text') {
		// Dispatch the key:
		if (keychar == '-') {
			window.panZoom.zoomOut()
		} else if (keychar == '=') {
			window.panZoom.zoomIn()
		} else if (keychar =='m') {
			moveNode()
		}
	}
}

function tableCreate(inputObject) {
	// Show the object table that a user has selected.
	var tabScroll = document.getElementById('tableScroller')
	var tbl = document.createElement('table')
	// Put in the header.
	var headRow = document.createElement('tr')
	if ((inputObject.from || inputObject.to) == undefined){
		headRow.innerHTML = '<th><button onclick="tablePlus(this)">+</button><button onclick="moveNode()">Move</button></th>'
	}
	else if((inputObject.from || inputObject.to) !== undefined){
		headRow.innerHTML = '<th><button onclick="tablePlus(this)">+</button>'
	}
	headRow.innerHTML += '<th><button id="saveButton" onclick="tableSave(this)">Save</button><button onclick="deleteOb()">Delete Object</button></th>'
	tbl.appendChild(headRow)
	// Put the object in.
	for (key in inputObject) {
		row = document.createElement('tr')
		row.innerHTML = '<td><button onclick="tableDel(this)">&#215;</button><input style="width:112px" value=' + key + '></input></td>'
		row.innerHTML += '<td><input value="' + inputObject[key] + '"></input></td>'
		tbl.appendChild(row)
	}
	tabScroll.appendChild(tbl)
}

function tableDel(me) {
	// Delete button functionality in object table.
	myRow = me.parentElement.parentElement
	myTable = myRow.parentElement
	myTable.removeChild(myRow)
}

function tablePlus(me) {
	// Add attribute button functionality in object table.
	myTable = me.parentElement.parentElement.parentElement
	newRow = myTable.insertRow(1)
	newRow.innerHTML = '<td><button onclick="tableDel(this)">&#215;</button><input style="width:112px"></input></td>'
	newRow.innerHTML += '<td><input></input></td>'
}

function tableSave(me) {
	// Update tree data structure with changes made in object table.
	tbl = me.parentElement.parentElement.parentElement
	var toJson = {}
	// convert HTML table to JSON
	for (i = 1; i < tbl.rows.length; i++) {
		key = tbl.rows[i].cells[0].lastElementChild.value
		if (key !== '') {
			toJson[key] = tbl.rows[i].cells[1].lastElementChild.value
		}
	}
	// Update tree with new values
	for (key in toJson) {
		testFeeder.tree[previousTarget.id][key] = toJson[key]
	}
	// Delete properties from tree
	for (key in testFeeder.tree[previousTarget.id]) {
		if (!toJson.hasOwnProperty(key)) {
			delete testFeeder.tree[previousTarget.id][key]
		}
	}
	// Update SVG
	if (previousTarget.tagName === 'circle') {
		// Update Circle
		previousTarget.setAttribute('cx', toJson['longitude'])
		previousTarget.setAttribute('cy', toJson['latitude'])
		// Update Line
		for (i = 0, limit = Object.keys(testFeeder.tree).length; i < limit; i++) {
			if (testFeeder.tree[i]['from'] === testFeeder.tree[previousTarget.id]['name']) {
				document.getElementById(i).setAttribute('x1', toJson['longitude'])
				document.getElementById(i).setAttribute('y1', toJson['latitude'])
			}
			else if (testFeeder.tree[i]['to'] === testFeeder.tree[previousTarget.id]['name']) {
				document.getElementById(i).setAttribute('x2', toJson['longitude'])
				document.getElementById(i).setAttribute('y2', toJson['latitude'])
			}
		}
	}
	tableDestroy()
	tableCreate(toJson)
	alert('Updated object: ' + testFeeder.tree[previousTarget.id].name)
}

function tableDestroy() {
	// Hide the object table.
	tabScroll = document.getElementById('tableScroller')
	kid = tabScroll.children[0]
	if (!(kid === undefined)) {tabScroll.removeChild(kid)}
}

function deleteOb() {
	// Delete Lines
	if (previousTarget.tagName === 'line') {
		previousTarget.remove()
		testFeeder.tree[previousTarget.id] = {}
	}
	// Delete Circles
	if (previousTarget.tagName === 'circle') {
		// Check for connected lines
		lines = 0
		for (i = 0, limit = Object.keys(testFeeder.tree).length; i < limit; i++) {
			if ( (testFeeder.tree[i]['from'] === testFeeder.tree[previousTarget.id]['name'])
				|| (testFeeder.tree[i]['to'] === testFeeder.tree[previousTarget.id]['name']) ) {
				lines++
			}
		}
		if (lines > 0) {
			alert('Cannot delete circles with lines still connected')
		} 
		else {
			previousTarget.remove()
		}
	}
	// Hide the object table.
	tableDestroy()
}

function scaleTo(x) {
	// Scale the thickness of all lines and size of all circles. This helps user see details.
	scaleLevel = x
	if (!x) {
		return
	}
	circles = document.getElementsByTagName('circle')
	lines = document.getElementsByTagName('line')
	// Scale Circles
	for (i = 0; i < circles.length; i++) {
		circles[i].setAttribute('r', 2*x)
		circles[i].setAttribute('stroke-width', 0.5*x)
	}
	// Scale Lines
	for (i = 0; i < lines.length; i++) {
		if (lines[i].getAttribute('class').indexOf('p2') !== -1) {
			lines[i].setAttribute('stroke-width', 2*x)
		}
		else if (lines[i].getAttribute('class').indexOf('p3') !== -1) {
			lines[i].setAttribute('stroke-width', 3*x)
		}
		else if (lines[i].getAttribute('class').indexOf('parentChild') !== -1) {
			lines[i].setAttribute('stroke-width', 0.5*x)
		}
		else {
			lines[i].setAttribute('stroke-width', x)
		}
	}
}

function dropPill(thisButton, name) {
	// This function is used to make the dropdown menus work.
	thisButton.style.color= 'black'
	thisButton.style.background= '#F8F8F8'
	thisButton.style.textAlign = 'left'
	thisButton.nextSibling.nextSibling.style.display = 'inline-block'
	thisButton.innerHTML = name + ' ▴'
	function clickCloseEvent() {
		thisButton.nextSibling.nextSibling.style.display = 'none'
		thisButton.innerHTML = name + ' ▾'
		this.removeEventListener('click', arguments.callee, true)
		thisButton.style.color= 'white'
		thisButton.style.background= 'transparent'
		if (window.event.toElement==thisButton) {event.stopPropagation()}
	}
	document.body.addEventListener('click', clickCloseEvent, true)
}

function clickCloseEvent(labelName, buttonName) {
	// This event allows users to close the dropdown menus.
	var thisButton = document.getElementById(buttonName);
	thisButton.nextSibling.nextSibling.style.display = 'none'
	thisButton.innerHTML = labelName + ' ▾'
	this.removeEventListener('click', arguments.callee, true)
	if (window.event.toElement==thisButton) {event.stopPropagation()}
}

function multiSelectionTable() {
	// Display the table when a user has selected multiple objects.
	tabScroll = document.getElementById('tableScroller')
	tbl = document.createElement('table')
	// Put in the header.
	headRow = document.createElement('tr')
	headRow.innerHTML = '<th>Selected Elements</th>'
	tbl.appendChild(headRow)
	// Put the object in.
	for (i = 0; i < selection.length; i++) {
		row = document.createElement('tr')
		row.innerHTML = '<td>' + testFeeder.tree[selection[i].id].name + '</td>'
		tbl.appendChild(row)
	}
	tabScroll.appendChild(tbl)
}

function clickLatLon(event) {
	//Returns real Lat/Long of a click event, used in the moveBus function
	var pan = window.panZoom.getPan();
	var sizes = window.panZoom.getSizes();
	var zoom = sizes.realZoom;
	var x, y, pt;
	var svg = document.getElementById('svgContainer');
	var pt = svg.createSVGPoint();
	pt.x = event.clientX;
	pt.y = event.clientY;
	pt = pt.matrixTransform(svg.getScreenCTM().inverse());
	x = pt.x;
	y = pt.y;
	x = (x - pan.x) / zoom;
	y = (y - pan.y) / zoom;
	return [x,y];
}

function newNode() {
	// Start creation of new node.
	var newTreeId = Object.keys(testFeeder.tree).length
	var newTreeNode = {
		longitude: 0,
		latitude: 0,
		name: 'newNode' + String(newTreeId),
		nominal_voltage: 1000,
		object: 'node',
		phases: 'A'
	}
	// Save to tree
	testFeeder.tree[newTreeId] = newTreeNode
	// Click location to add
	clickTarget = document.getElementById('svgContainer')
	clickTarget.addEventListener('click', newNodeListener, false)
	document.body.style.cursor = 'crosshair'
}

function newNodeListener() {
	// Click handler for location of new node.
	var xloc = event.pageX
	var yloc = event.pageY
	var newTreeId = (Object.keys(testFeeder.tree).length)-1
	coords = clickLatLon(event)
	xloc = coords[0]
	yloc = coords[1]
	testFeeder.tree[newTreeId].longitude = xloc
	testFeeder.tree[newTreeId].latitude = yloc
	// Draw new node on svg
	x = testFeeder.tree[newTreeId].longitude
	y = testFeeder.tree[newTreeId].latitude
	r = 2
	id = newTreeId
	myClass = testFeeder.tree[newTreeId].object
	addCircle(x,y,r,id,myClass)
	scaleTo(scaleLevel)
	clickTarget.removeEventListener('click', newNodeListener, false)
	document.body.style.cursor = 'auto'
}

function newLink() {
	// Create new link object.
	nodeTypes = ['node','load','house','meter','triplex_meter','triplex_node','triplex_load','waterheater','ZIPload']
	if (selection.length === 2){
		if ((nodeTypes.indexOf(testFeeder.tree[selection[0].id].object)), (nodeTypes.indexOf(testFeeder.tree[selection[1].id].object))
				 !== -1)    { 
			// Connect the 2 selected nodes.
			var newTreeId = Object.keys(testFeeder.tree).length
			var newLink = {
				//creates newlink variable in testFeeder.tree
				name: 'newLink' + String(newTreeId),
				object: 'overhead_line',
				phases: 'A',
				configuration: 'configuration',
				from: testFeeder.tree[selection[0].id].name,
				to: testFeeder.tree[selection[1].id].name
			}
			// Save to tree
			testFeeder.tree[newTreeId] = newLink
			// Draw on svg
			x1 = testFeeder.tree[selection[0].id].longitude
			y1 = testFeeder.tree[selection[0].id].latitude
			x2 = testFeeder.tree[selection[1].id].longitude
			y2 = testFeeder.tree[selection[1].id].latitude
			id = newTreeId
			myClass = testFeeder.tree[newTreeId].object
			addLine(x1,y1,x2,y2,id,myClass)
			//then below fixes the build order so cirlces come in last
			selection[0].remove()
			selection[1].remove()
			addCircle(x1,y1,2,selection[0].id,testFeeder.tree[selection[0].id].object)
			addCircle(x2,y2,2,selection[1].id,testFeeder.tree[selection[1].id].object)
			scaleTo(scaleLevel)
			selection = []
		}
		else if (((nodeTypes.indexOf(testFeeder.tree[selection[0].id].object)) || (nodeTypes.indexOf(testFeeder.tree[selection[1].id].object))== -1)) {
			alert("Please only select nodes")
			for (i=0; i<selection.length; i++) {
			selection[i].classList.remove('selected')
			}
			selection = []
			tableDestroy()
		}
	}
	else {
		alert("Please hold down the 'alt' key and select two nodes to connect.")
		for (i=0; i<selection.length; i++) {
			selection[i].classList.remove('selected')
			}
			selection = []
			tableDestroy()
	}	
}

function moveNode() {
	// When user clicks drag, add a listener to effect the movement on next click.
	document.body.style.cursor = 'crosshair'
	clickTarget = document.getElementById('svgContainer')
	clickTarget.addEventListener('click', moveNodeListener, false)
}

function moveNodeListener() {
	// Listener to allow a node to move once the user clicks the target location.
	// Define local variables.
	var currSelId = lastElementSelected.id
	var currSel = testFeeder.tree[currSelId]
	var newLat = clickLatLon(event)[1]
	var newLon = clickLatLon(event)[0]
	var currSelP = currSel.parent
	// Update the coordinate values on the object.
	currSel["longitude"] = newLon
	currSel["latitude"] = newLat
	//Runs through testFeeder lines (links) determines if clicked node is an end or target for any line in feeder
	for (num in testFeeder.tree) {
		var treeOb = testFeeder.tree[num]
		// Move line between clicked node and its treeOb child.
		if (treeOb.parent == currSel.name) {
			document.getElementById(currSel.name + "_" + treeOb.name).remove()
			addLine(newLon,newLat,treeOb.longitude,treeOb.latitude,currSel.name + "_" + treeOb.name,'parentChild')
			document.getElementById(num).remove()
			addCircle(treeOb.longitude,treeOb.latitude,2,num,treeOb.object)
			document.getElementById(currSelId).remove()
			addCircle(newLon,newLat,2,currSelId,currSel.object)
		}
		// Move line between clicked node and its treeOb parent (if it is a child).
		if (currSelP != undefined && currSelP == treeOb.name && treeOb.from == undefined && treeOb.to == undefined) {
			document.getElementById(treeOb.name + "_" + currSel.name).remove()
			addLine(newLon,newLat,treeOb.longitude,treeOb.latitude,treeOb.name + "_" + currSel.name,'parentChild')
			document.getElementById(num).remove()
			addCircle(treeOb.longitude,treeOb.latitude,2,num,treeOb.object)
			document.getElementById(currSelId).remove()
			addCircle(newLon,newLat,2,currSelId,currSel.object)
		}
		if (treeOb.from !== undefined && treeOb.to !== undefined){
			// Move all lines from or to the clicked node.
			if (treeOb.from == currSel.name || treeOb.to == currSel.name) {
				// If the current object is a line connected to the current node, move it.
				document.getElementById(num).remove()
				for (subEl in testFeeder.tree) {
					// Find the coordinates on the other end of the moving line.
					if (treeOb.from == testFeeder.tree[subEl].name) {
						x1 = testFeeder.tree[subEl]['longitude']
						y1 = testFeeder.tree[subEl]['latitude']
						numf = subEl
						myClassf = testFeeder.tree[subEl].object
					} else if (treeOb.to == testFeeder.tree[subEl].name) {
						x2 = testFeeder.tree[subEl]['longitude']
						y2 = testFeeder.tree[subEl]['latitude']
						numt = subEl
						myClasst = testFeeder.tree[subEl].object
					}
				}
				// Draw the line.
				addLine(x1,y1,x2,y2,num,treeOb['object'] + ' p' + phaseCount(treeOb['phases']))
				// Redraw nodes after line so they aren't below the newly drawn lines. Up to 3 nodes for case where we are moving node between 2 from-to lines.
				if (treeOb.from == currSel.name) {
					addCircle(x2,y2,2,numt,myClasst)
					document.getElementById(numt).remove()
				}
				if (treeOb.to == currSel.name) {
					addCircle(x1,y1,2,numf,myClassf)
					document.getElementById(numf).remove()
				}
				// Finally, draw the clicked node in its new location.
				document.getElementById(currSelId).remove()
				addCircle(newLon,newLat,2,currSelId,testFeeder.tree[currSelId].object)
			}
		}
	}
	// Fix scaling of new objects.
	scaleTo(scaleLevel)
	// Return the cursor to its default.
	document.body.style.cursor = 'auto'
	clickTarget.removeEventListener('click', moveNodeListener, false)
}

function showModal(element){
	// Make a modal dialog visible.
	document.getElementById(element).style.display = 'block'
}

function closeModal(element){
	// Hide a modal dialog.
	document.getElementById(element).style.display = 'none'
}

function findNext() {
	// Find the next object matching the user input.
	var term = document.getElementById('searchTerm').value
	var hits = findElementsViaString(term)
	document.getElementById('searchHitCount').innerHTML = hits.length + ' Hits'
	// If we can't find anything, stop.
	if (hits.length == 0) {
		alert('No objects found containing term.')
		return false
	}
	// Clear the current selection.
	for (i=0; i<selection.length; i++) {
		selection[i].classList.remove('selected')
	}
	selection = []
	tableDestroy()
	// Find the tree index of the next item.
	if (searchCursor == undefined) {
		searchCursor = 0
	} else {
		searchCursor = (searchCursor + 1) % hits.length
	}
	var hitId = hits[searchCursor]
	// Find the location to zoom to.
	var svgOb = document.getElementById(hitId.toString())
	var cx = svgOb.getAttribute('cx')
	var cy = svgOb.getAttribute('cy')
	if (cx !== null && cy !== null) {
		// Circle object, just get cx and cy
		var x = cx
		var y = cy
	} else {
		// Line object, get midpoint to zoom to
		var x = (parseFloat(svgOb.getAttribute('x1')) + parseFloat(svgOb.getAttribute('x2'))) / 2
		var y = (parseFloat(svgOb.getAttribute('y1')) + parseFloat(svgOb.getAttribute('y2'))) / 2
	}
	// Pan to the next hit.
	window.panZoom.pan({x:0, y:0})
	var realZoom = window.panZoom.getSizes().realZoom
	var width = window.panZoom.getSizes().width / 2
	var height = window.panZoom.getSizes().height / 2
	window.panZoom.pan({x:width - (x * realZoom), y:height - (y * realZoom)})
	// TODO: Zoom in close
	// Udpate the selection.
	svgOb.classList.add('selected')
	selection.push(svgOb)
	tableCreate(testFeeder.tree[hitId])
}

function findPrevious() {
	var term = document.getElementById('searchTerm').value
	var hits = findElementsViaString(term)
	if (searchCursor == undefined) {
		findNext()
	} else if (searchCursor == 0) {
		// Wrapped around.
		searchCursor = (hits.length) - 2
		findNext()
	} else {
		searchCursor -= 2
		findNext()
	}
}

function findElementsViaString(inString) {
	var results = []
	for (key in testFeeder.tree) {
		subIndex = JSON.stringify(testFeeder.tree[key]).indexOf(inString)
		if (subIndex != -1 && testFeeder.tree[key]['object'] != 'player' && (testFeeder.tree[key].hasOwnProperty('object') || testFeeder.tree[key].hasOwnProperty('module'))) {
			results.push(key)
		}
	}
	return results
}

function fixPhases () {
	// Todo: complete this to walk the tree and fix phasing.
	for (i in testFeeder.tree){
		if (testFeeder.tree[i].name != undefined) {
			nodeName = testFeeder.tree[i].name
			for (j in testFeeder.tree) {
				if (testFeeder.tree[j].from != undefined) {
					linkFrom = testFeeder.tree[j].from
					if (nodeName == linkFrom) {
						node = testFeeder.tree[i]
						link = testFeeder.tree[j]
						nodePhase = node.phases.split('').sort().join('').trim()
						linkPhase = link.phases.split('').sort().join('').trim()
						if (linkPhase.length > nodePhase.length) {
							linkPhase==nodePhase
						}
					}
				}
			}
		}
	}
}

function loadingStuff() {
	// Start the feeder building and when it's done, remove the loading message.
	buildFeeder();
	document.getElementById('loadingMessage').style.display = 'none'
}

// Run loading stuff.
setTimeout(loadingStuff,100)
</script>