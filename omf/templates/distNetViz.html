<!DOCTYPE html>
<html>
	<head>
		<meta charset="UTF-8">
		<style>
            /* Define global css variables */
            /* I have to subtract 4px or so from the svgContainer to prevent the scrollbar from appearing. Making the header height less does not appear to change anything. */
            :root {
                --header-height: 35px;
                --header-padding-top: 8px;
                --header-padding-bottom: 8px;
            }
			* { 
                font-family: Helvetica, Arial, Sans-Serif;
            }
			div.divButton {
				-webkit-touch-callout: none;
				-webkit-user-select: none;
				-khtml-user-select: none;
				-moz-user-select: none;
				-ms-user-select: none;
				user-select: none;
				cursor: pointer;
				cursor: hand;
				position:fixed;
				width:30px;
				height:30px;
				text-align:center;
				font-size:30px;
				line-height:30px;
				color:white;
                background-color: dimgrey;
                left: 5px;
			}
            #scaleButton {
                top: 175px;
            }
			body {
                /*width: 100%;
                height: 100%;*/
                margin:0px;
            }
			a {
				text-decoration: none;
                color: mediumseagreen;
                /*color: black;*/
			}
            /*a:visited {
                color: seagreen;
            }*/

            /* SVG */

            #interfaceContainer {
                position: relative;
            }

            /* This is the element that acts as a hook for svg-pan-zoom.js to attach a viewport, which it creates itself */
            /* overflow: hidden is set by svg-pan-zoom.js itself. No need to change that here. */
			#svgContainer {
                /* width must be 100%, meaning 100% of the document */
				width: 100%; 
                /* height must be manually set to a hard value */
				/*height: calc(100vh - var(--header-height) - var(--header-padding-bottom) - var(--header-padding-top));*/
				height: calc(100vh - var(--header-height) - var(--header-padding-bottom) - var(--header-padding-top) - 4px);
			}
			#saveButton {
				float:right;
			}

            div#loadingMessage {
                width: 100%;
                height: 100%;
				/*background-color: rgba(0,0,0,0.4); */
                background-color: white;
                position: fixed;
                top: 0px;
            }

            /**************************************************
            // Header and menu links
            **************************************************/

			#header {
				width:100%;
				height: var(--header-height);
				padding-top: var(--header-padding-top);
				padding-bottom: var(--header-padding-bottom);
				background:black;
                display: flex;
                justify-content: space-between;
                align-items: center;
			}
            #menuLeft h4 {
                margin: 0px 0px 4px 20px;
            }
            #menuLeft p {
                margin: 0px 0px 0px 20px;
            }
            #menuRight { 
              display:flex;
                      align-items: center;
            }
            .white {
                color: #F8F8F8;
            }
            .menuHeading {
                margin: 0px;
                padding: 5px;
                border-radius: 5px 5px 0px 0px;
            }
            .expandedHeading {
                color: black;
                background: #F8F8F8;
            }
            .headerGroup {
                position: relative; /* set to relative in order to correctly align the ul.menu */
                margin-right: 15px;
                cursor: pointer;
            }
            ul.menu {
                list-style: none; /* remove bullet points from menu */
                margin: 0px;
                padding: 0px;
                position: absolute; /* remove the menu from the document flow */
                background-color: #F8F8F8;
                right: 0px; /* align the menu to the left */
                box-shadow: 0 11px 10px rgba(0, 0, 0, 0.2); /* add shadow to the menu */
                border-radius: 5px 0 0 0; /* round the top left corner of the menu */
                max-height: 550px; /* Limit the length of the component list */
                overflow: auto;
                white-space: nowrap;
            }
            ul.menu li { 
                padding: 4px; 
            }
            ul.menu li:hover {
                background:green; color:white; 
            }
            /**************************************************
            // Modal Dialogs
            **************************************************/

            #loadModalTable {
                width: 890px;
            }
            /*#milsoftInput {
                width: 100%;
            }*/
            #progressModalCancel {
                background-color: crimson;
            }
            #progressModal {
                z-index: 1;
            }
            #massAddModal .modalContent {
                width: 400px;
            }
            #climateModal label {
                white-space: nowrap;
            }
            #anonymizeModal {
                white-space: nowrap;
            }
			.modal {
                position: fixed;
                top: 0px;
                width: 100%;
                height: 100%;
                display: flex;
                justify-content: center;
                align-items: center;
				background-color: rgba(0,0,0,0.4); /* Black w/ opacity */
			}
	 		.modalContent {
                padding: 20px;
                border-radius: 10px;
				background-color: #fefefe;
                max-height: 80vh;
                overflow: auto;
			}
            .right {
                float: right;
            }
            .centered {
                text-align: center;
            }
            .modalHeading {
                text-align: center;
            }
            .modalInput {
                font-size: medium;
                border: 0px;
                background-color: gainsboro;
                width: 100%;
            }
            .modalInputLine {
                font-size: medium;
                border: 0px;
                background-color: gainsboro;
            }
            .vertFlex {
                display: flex;
                flex-direction: column;
            }
            .legendFlex {
                display: flex;
                height: 40vh;
            }
            .legendGradiant {
                height: 100%;
                width: 5vw;
            }
            .legendAxis {
                height: 100%;
                margin: 0px 0px 0px 20px;
                justify-content: space-between;
            }
            .legendAxis p {
                margin: 0px;
            }
            .modalTableHeader {
                margin: 20px 0px 0px 0px;
            }
            .modalButton {
                font-size: medium;
                background-color: seagreen;
                -webkit-border-radius: 5px;
                -moz-border-radius: 5px;
                border-radius: 5px;
                border: none;
                color: white;
                cursor: pointer;
                padding: 4px 6px 4px;
            }
            #cancelButton {
                background-color: crimson;
            }
            .leftText {
                text-align: left;
            }
            .modalTableRow {
                width: 50%;
            }
            .scrollableList {
                overflow: auto;
                height: 240px;
                list-style-type: none;
                /*margin: 0px 0px 0px 20px;*/
                margin: 0px;
                padding: 0;
                cursor: pointer;
            }
            .feederItem {
                padding: 5px 0px 5px 0px;
                margin: 10px 0px 10px 0px;
            }
            .feederItem:hover {
                color: white;
                background-color: green;
            }
            /*
            input:valid {
                border: 1px solid white; 
            }
            */
            input:invalid {
                /*Aborder: 1px solid red;*/
            }            

            /* Tree tables */

            .buttonRow {
                /*text-align: center;*/
            }
            .buttonRow button {
                margin-right: 5px;
            }
            /*
            .treeTable {
                background-color: white; 
            }
            .treeTable tr {
            }
            .treeTable tr:last-child {
                border: 0px;
            }
            */
            thead td {
                
            }
            .tableInput {
                font-size: small;
                background-color: gainsboro;
                padding: 3px;
                border: 0px;
            }
            .deleteButton {
                background-color: #CC0000;
                /*padding: 1px 7px 1px 7px;*/
            }
            /* TODO: might need to delete this rule */
            .editButton {
                font-size: small;
                /*width: 100%;*/
            }

			/* dataTable */

            .floatingTables {
                position: absolute;
                top: 0px;
                height: 0px;
            }

            #descriptionTables { }

            #selectionTable { }

            .formContainer {
				/*position: fixed;*/
				/*top: 55px;*/
                height:0px;
				/*right: 5px;*/
            }

            /* Don't set overflow-y to hidden */
			.dataTable {
                position: fixed;
				top: 55px;
				border:1px solid black;
				border-collapse: collapse;
                display: inline-block;
                overflow-x: hidden;
				max-height: 90vh;
                right: 10px;
			}
            .dataTable tr {
                border-bottom: 1px solid black;
            }
            .dataTable tr:last-child {
                border: 0px;
            }
            /*.dataTable p {
                margin: 0px;
            }*/
            .tableTitle {
                background-color: black;
                color: white;
            }
			tbody {
				/*border: 1px solid black;*/
                border-collapse: collapse;
			}
			td {
				background:white;
				/*padding: 5px 0px 5px 0px;*/
				border-collapse: collapse;
			}
            .verticalPadded {
				padding: 5px 0px 5px 0px;
            }
            .fullPadded {
				padding: 5px;
            }
			th {
				/*font-weight: normal;*/
				/*background:black;*/
				/*color:white;*/
				/*padding: 5px 0px 5px 0px;*/
			}
			/*
            #editButtonRow button {
				font-size: small;
				color: white;
				background: seagreen;
				padding: 5px;
				border-radius: 5px;
				width: 100%;
			}
            */
            /*
			#editButtonRow button:hover {
				outline:0;
				outline: none; 
				background:mediumseagreen;
			}
            */

            /* SVG Styling */

            line { stroke: rgb(0,0,0); } /* black */
            line.parentChild { stroke: rgb(211,211,211); } /* LightGray */
            circle {
                stroke: rgb(255,255,255); /* white */
                fill: rgb(128,128,128); /* gray */
            }
            .house { fill: rgb(0,0,255); } /* blue */
            .triplex_meter { fill:rgb(255,165,0); } /* orange */
            .underground_line { stroke: rgb(128,128,128);} 
            .transformer { stroke:rgb(255,165,0); }
            .regulator { stroke: rgb(255,0,0) ;} /* red */
            .undefined,.regulator_configuration,.transformer_configuration,.triplex_line_configuration,.line_configuration,.volt_var_control,.line_spacing,.climate,.overhead_line_conductor,.underground_line_conductor,.triplex_line_conductor,.player,.schedule { fill: rgb(191,191,191); } /* 75% lightness gray */
        </style>
        <link rel="stylesheet" href="/static/jquery-ui.min.css">
        <script type="text/javascript" src="/static/jquery.js"></script>
        <script type="text/javascript" src="/static/jquery-ui.min.js"></script>
        <script type="text/javascript" src="/static/svg-pan-zoom.js"></script>
        <script type="text/javascript" src="/static/chroma.min.js"></script>
        <script type="text/javascript" src="/static/papaparse.min.js"></script>
		{% if jasmine %}{{ jasmine | safe }}{% endif %}
		<!-- <script id='feederLoadScript' type='text/javascript' src='./Data for Testing/testFeeder.js'></script> -->
		<!-- <script id='feederLoadScript' type='text/javascript' src='./Data for Testing/testFeeder Largest.js'></script> -->
		<!-- <script id='feederLoadScript' type='text/javascript' src='./Data for Testing/testFeeder Norfork.js'></script> -->
	</head>
    <body>
        <div id="interfaceContainer">
            <div id="loadingMessage">
                <p style="font-size:60pt; text-align:center; width:100%;">Feeder Loading...</p>
            </div>
            <div id="descriptionTables" class="floatingTables"></div>
            <div id="selectionTable" class="floatingTables"></div>
            <!-- Controls -->
            <div style="top:55px;" class="divButton" onclick="window.panZoom.zoomIn()" title="Zoom In">+</div>
            <div style="top:95px;" class="divButton" onclick="window.panZoom.zoomOut()" title="Zoom Out">-</div>
            <div style="top:135px;" class="divButton" onclick="window.panZoom.reset()" title="Reset Zoom">R</div>
            <div id="scaleButton" class="divButton" title="Scale To">S</div>
            <!-- <div style='background:navy; top:215px; left:5px' id='saveLink' class='divButton' onclick='saveSvg()' title='Save File' download>S</div> -->
            <!-- Menu Bar -->
            <div id="header">
                <div id="menuLeft" class="white">
                    <h4>{{thisFeederName}}</h4>
                    <p>from "{{thisModelName}}"</p>
                </div>
                <div id="menuRight">
                    <h4 style="padding: 5px; margin-right: 15px;"><a id="helpButton" class="white" href="https://github.com/dpinney/omf/wiki/Tools-~-gridEdit" target="_blank">Help</a></h4>
                    <div class="headerGroup">
                        <h4 class="menuHeading white">Edit &#x25BE</h4>
                        <ul id="editMenu" class="menu" style="display: none;">
                            <!--<li>Zoom To Fit</li>-->
                            <!--<li>Zoom Reset</li>-->
                            <li data-web>Add AMI Profiles...</li>
                            <li data-web>Anonymization...</li>
                            <li>Attachments...</li>
                            <li data-web>Climate...</li>
                            <li>Find...</li>
                            <li>Mass Add...</li>
                            <li>Mass Edit...</li>
                            <li data-web>Scada Loadshapes...</li>
                            <li>Static Loads to Houses</li>
                            <li>Change opacity...</li>
                            <li>Color Circuit...</li>
                        </ul>
                    </div>
                    <div class="headerGroup">
                        <h4 class="menuHeading white">Add &#x25BE;</h4>
                        <ul id="componentList" class="menu" style="display: none"></ul>
                    </div>
                    {% if showFileMenu %}
                    <div class="headerGroup">
                        <h4 class="menuHeading white">File &#x25BE</h4>
                        <ul id="fileMenu" class="menu" style="display: none">
                            <li data-web>Save</li>
                            <li>View Raw Data</li>
                            <li data-web>Rename</li>
                            <li data-web>Load from Model...</li>
                            <li data-web>New Blank Feeder...</li>
                            <li data-web>Windmil Conversion...</li>
                            <li data-web>GridLAB-D Conversion...</li>
                            <li data-web>CYMDIST Conversion...</li>
                            <li data-web>View on Map</li>
                        </ul>
                    </div>
                    {% endif %}
                </div>
            </div>
            <!-- Svg container -->
            <div id="svgContainerWrapper" style="height: auto;">
                <svg id="svgContainer" xmlns="http://www.w3.org/2000/svg"></svg>
            </div>
            <!-- Modals -->
            <div id="findModal" class="modal" style="display: none">
                <div class="modalContent">
                    <table>
                        <tr>
                            <td class="fullPadded"><input id="searchInput" type="text" value="Enter a term" class="modalInput"></td>
                            <td id="searchCount" class="fullPadded"></td>
                        </tr>
                        <tr><td class="fullPadded"><input checked id="searchExactString" type="radio" name="searchMode" value="searchExactString">Exact match</td></tr>
                        <tr><td class="fullPadded"><input id="searchSubstring" type="radio" name="searchMode" value="searchSubstring">Includes term</td></tr>

                        <tr>
                            <td class="fullPadded">Key of current object:</td>
                            <td id="foundElementKey" class="fullPadded"></td>
                        </tr>
                        <tr>
                            <td class="fullPadded"><input type="checkbox" id="showTableOnFind">Show table on view</td>
                        </tr>
                        <tr>
                        <td class="fullPadded">
                            <button id="findPrevious" class="modalButton">Previous</button>
                            <button id="findNext" class="modalButton" style="margin-left:10px;">Next</button>
                        </td>
                            <td class="fullPadded"><button class="modalButton" onclick="toggleElementDisplay('findModal')">Close</button></td>
                        </tr>
                    </table>
                </div>
            </div>
            <div id="progressModal" class="modal" style="display: none">
                <div class="modalContent" style="text-align: center;">
                    <img src="/static/spinner.gif">
                    <h2>text...</h2>
                    <button class="modalButton" id="progressModalCancel">Cancel</button>
                </div>
            </div>
            <div id="loadModal" class="modal" style="display: none">
                <div class="modalContent">
                    <table id="loadModalTable">
                        <tbody>
                            <tr>
                                <th class="modalTableRow fullPadded">Public Feeders</th>
                                <th class="modalTableRow fullPadded">My Feeders</th>
                            </tr>	
                            <tr>
                                <td class="modalTableRow fullPadded"><ul id="publicFeederList" class="scrollableList"></ul></td>
                                <td class="modalTableRow fullPadded"><ul id="userFeederList" class="scrollableList"></ul></td>
                            </tr>
                        </tbody>
                    </table>
                    <div class="fullPadded">
                        <button onclick="toggleElementDisplay('loadModal')" class="modalButton fullPadded">Cancel</button>
                    </div>
                </div>
            </div>
            <div id="blankFeederModal" class="modal" style="display: none">
                <div class="modalContent">
                    <!--{{thisOwner}} is correct because this form is supposed to replace THIS feeder with a new blank one-->
                    <form onsubmit="submitForm({formId:'blankFeederForm'}); return false;" action="/newBlankFeeder/{{thisOwner}}" id="blankFeederForm">
                        <input type="hidden" name="_csrf_token" value="{{csrf_token()}}"/>
                        <input type="hidden" id="feederNum" name="feederNum" value="{{thisFeederNum}}"/>
                        <input type="hidden" id="modelName" name="modelName" value="{{thisModelName}}"/>
                        <input type="hidden" name="referrer" value="distribution"/>
                        <table>
                            <tbody>
                                <tr>
                                    <th colspan="2" class="fullPadded">New Blank Feeder</th>
                                </tr>
                                <tr>
                                    <td class="fullPadded"><label for="blankFeederInput">Name</label></td>
                                    <td class="fullPadded">
                                        <!-- TODO: add better validation than just the "required" attribute-->
                                        <input type="text" required id="blankFeederInput" name="feederNameNew" class="modalInput"/>
                                    </td>
                                </tr>
                                <tr>
                                    <td class="fullPadded"><button type="button" onclick="toggleElementDisplay('blankFeederModal')" class="modalButton">Cancel</button></td>
                                    <td class="fullPadded"><button type="submit" class="right modalButton">Create</button></td>
                                </tr>
                            </tbody>
                        </table>
                    </form>
                </div>
            </div>
            <div id="milsoftModal" class="modal" style="display: none">
                <div class="modalContent">
                    <!--I assume this is supposed to replace THIS feeder with the milsoft upload. Therefore, uniqObjName with {{thisOwner}} is correct.-->
                    <form onsubmit="submitForm({formId:'milsoftForm', pollUrl:'/checkConversion/{{thisModelName}}/{{thisOwner}}', inputId:'milsoftInput'}); return false;"
                    action="/milsoftImport/{{thisOwner}}" id="milsoftForm">
                        <input type="hidden" name="_csrf_token" value="{{csrf_token()}}"/>
                        <input type="hidden" id="feederNum" name="feederNum" value="{{thisFeederNum}}"/>
                        <input type="hidden" id="modelName" name="modelName" value="{{thisModelName}}"/>
                        <!--<input type="hidden" name="referrer" value="distribution"/>-->
                        <table>
                            <tbody>
                                <tr><th colspan="2" class="fullPadded">Milsoft Conversion</th></tr>
                                <tr>
                                    <td class="fullPadded"><label for="milsoftInput">Name</label></td>
                                    <td class="fullPadded">
                                        <!-- TODO: add better validation than just the "required" attribute-->
                                        <input type="text" required id="milsoftInput" name="feederNameM" class="modalInput"/>
                                    </td>
                                </tr>
                                <tr>
                                    <td class="fullPadded">Data File (.std)</td>
                                    <td class="fullPadded"><input type="file" required id="stdFile" name="stdFile" accept=".std" class="modalInput"/></td>
                                </tr>
                                <tr>
                                    <td class="fullPadded">Equipment File (.seq)</td>
                                    <td class="fullPadded"><input type="file" required id="seqFile" name="seqFile" accept=".seq" class="modalInput"/></td>
                                </tr>
                                <tr>
                                    <td class="fullPadded"><button type="button" onclick="toggleElementDisplay('milsoftModal')" class="modalButton">Cancel</button></td>
                                    <td class="fullPadded"><button type="submit" class="modalButton right">Import</button></td>
                                </tr>
                            </tbody>
                        </table> 
                    </form>
                </div> 
            </div>
            <div id="gridlabdModal" class="modal" style="display: none">
                <div class="modalContent">
                    <!--I assume this is supposed to replace THIS feeder with the gridlabd upload. Therefore, uniqObjName with {{thisOwner}} is correct.-->
                    <form onsubmit="submitForm({formId:'gridlabdForm', pollUrl:'/checkConversion/{{thisModelName}}/{{thisOwner}}', inputId:'gridlabdInput'}); return false;"
                    action="/gridlabdImport/{{thisOwner}}" id="gridlabdForm">
                        <input type="hidden" name="_csrf_token" value="{{csrf_token()}}"/>
                        <input type="hidden" id="feederNum" name="feederNum" value="{{thisFeederNum}}"/>
                        <input type="hidden" id="modelName" name="modelName" value="{{thisModelName}}"/>
                        <!--<input type="hidden" name="referrer" value="distribution"/>-->
                        <table>
                            <tbody>
                                <tr><th colspan="2" class="fullPadded">GridLab-D Conversion</th></tr>
                                <tr>
                                    <td class="fullPadded"><label for="gridlabdInput">Name</label></td>
                                    <td class="fullPadded">
                                        <!-- TODO: add better validation than just the "required" attribute-->
                                        <input type="text" required id="gridlabdInput" name="feederNameG" class="modalInput"/>
                                    </td>
                                </tr>
                                <tr>
                                    <td class="fullPadded">Data File (.glm)</td>
                                    <td class="fullPadded"><input type="file" required id="csvFile" name="glmFile" accept=".glm" class="modalInput"/></td>
                                </tr>
                                <tr>
                                    <td class="fullPadded"><button type="button" onclick="toggleElementDisplay('gridlabdModal')" class="modalButton">Cancel</button></td>
                                    <td class="fullPadded"><button type="submit" class="modalButton right">Import</button></td>
                                </tr>
                            </tbody>
                        </table>
                    </form>
                </div>
            </div>
            <div id="cymeModal" class="modal" style="display: none">
                <div class="modalContent">
                    <!--I assume this is supposed to replace THIS feeder with the cyme upload. Therefore, uniqObjName with {{thisOwner}} is correct.-->
                    <form onsubmit="submitForm({formId:'cymeForm', pollUrl:'/checkConversion/{{thisModelName}}/{{thisOwner}}', inputId:'cymeInput'}); return false;"
                    action="/cymeImport/{{thisOwner}}" id="cymeForm">
                        <input type="hidden" name="_csrf_token" value="{{csrf_token()}}"/>
                        <input type="hidden" id="feederNum" name="feederNum" value="{{thisFeederNum}}"/>
                        <input type="hidden" id="modelName" name="modelName" value="{{thisModelName}}"/>
                        <!--<input type="hidden" name="referrer" value="distribution"/>-->
                        <table>
                            <tbody>
                                <tr><th colspan="2" class="fullPadded">Cyme Conversion</th></tr>
                                <tr>
                                    <td class="fullPadded"><label for="cymeInput">Name</label></td>
                                    <td class="fullPadded">
                                        <!-- TODO: add better validation than just the "required" attribute-->
                                        <input type="text" required id="cymeInput" name="feederNameC" class="modalInput"/>
                                    </td>
                                </tr>
                                <tr>
                                    <td class="fullPadded">Network File (.mdb)</td>
                                    <td class="fullPadded"><input type="file" required id="mdbNetFile" name="mdbNetFile" accept=".mdb" class="modalInput"/></td>
                                </tr>
                                <tr>
                                    <td class="fullPadded"><button type="button" onclick="toggleElementDisplay('cymeModal')" class="modalButton">Cancel</button></td>
                                    <td class="fullPadded"><button type="submit" class="modalButton right">Import</button></td>
                                </tr>
                            </tbody>
                        </table>
                    </form>
                </div>
            </div>
            <div id="scadaModal" class="modal" style="display: none">
                <div class="modalContent">
                    <!--I assume this is supposed to update THIS feeder with the scada loadshape. Therefore, uniqObjName with {{thisOwner}} is correct.-->
                    <form onsubmit="submitForm({formId:'scadaForm', pollUrl:'/checkScadaLoadshape/{{thisModelName}}'}); return false;"
                    action="/scadaLoadshape/{{thisOwner}}/{{thisFeederName}}" id="scadaForm">
                        <input type="hidden" name="_csrf_token" value="{{csrf_token()}}"/>
                        <input type="hidden" id="feederNum" name="feederNum" value="{{thisFeederNum}}"/>
                        <input type="hidden" id="modelName" name="modelName" value="{{thisModelName}}"/>
                        <!--<input type="hidden" name="referrer" value="distribution"/>-->
                        <table>
                            <tbody>
                                <tr>
                                    <th class="leftText fullPadded">Scada Loadshapes</th>
                                    <th class="right fullPadded"><a href="https://github.com/dpinney/omf/wiki/Tools-~-gridEdit#scada-loadshapes" target="_blank">Format Help</a></th>
                                </tr>
                                <tr>
                                    <td class="fullPadded">File containing Scada load data (.csv)</td>
                                    <td class="fullPadded"><input type="file" required id="scadaFile" name="scadaFile" accept=".csv" class="modalInput"/></td>
                                </tr>
                                <tr><td colspan="100%" class="fullPadded">Note: Model "Simulation Start Date" should lie within the Scada load"s dates.</td></tr>
                                <tr>
                                    <td class="fullPadded"><button type="button" onclick="toggleElementDisplay('scadaModal')" class="modalButton">Cancel</button></td>
                                    <td class="fullPadded"><button type="submit" class="right modalButton">Import</button></td>
                                </tr>
                            </tbody>
                        </table>
                    </form>
                </div>
            </div>
            <div id="amiModal" class="modal" style="display: none">
                <div class="modalContent">
                    <!--I assume this is supposed to replace THIS feeder with the ami modeling. Therefore, uniqObjName with {{thisOwner}} is correct.-->
                    <form onsubmit="submitForm({formId:'amiForm', pollUrl:'/checkLoadModelingAmi/{{thisModelName}}'}); return false;"
                    action="/loadModelingAmi/{{thisOwner}}/{{thisFeederName}}" id="amiForm">
                        <input type="hidden" name="_csrf_token" value="{{csrf_token()}}"/>
                        <input type="hidden" id="feederNum" name="feederNum" value="{{thisFeederNum}}"/>
                        <input type="hidden" id="modelName" name="modelName" value="{{thisModelName}}"/>
                        <!--<input type="hidden" name="referrer" value="distribution"/>-->
                        <table>
                            <tbody>
                                <tr>
                                    <th class="leftText fullPadded">AMI Profiles</th>
                                    <th class="right fullPadded"><a href="https://github.com/dpinney/omf/wiki/Tools-~-gridEdit" target="_blank">Format Help</a></th>
                                </tr>
                                <tr>
                                    <td class="fullPadded">File containing AMI load data (.csv)</td>
                                    <td class="fullPadded"><input type="file" required id="amiFile" name="amiFile" accept=".csv" class="modalInput"/></td>
                                </tr>
                                <tr>
                                    <td colspan="100%" class="fullPadded">Note: Model "Simulation Start Date" should lie within the AMI profiles"s dates.</td>
                                </tr>
                                <tr>
                                    <td class="fullPadded"><button type="button" onclick="toggleElementDisplay('amiModal')" class="modalButton">Cancel</button></td>
                                    <td class="fullPadded"><button type="submit" class="modalButton right">Import</button></td>
                                </tr>
                            </tbody>
                        </table>
                    </form>
                </div>
            </div>
            <div id="massAddModal" class="modal" style="display: none">
                <div class="modalContent">
                    <table>
                        <tbody>
                            <tr><th colspan="2" class="fullPadded">Mass Add</th></tr>
                            <tr>
                                <td class="fullPadded">Add component:</td>
                                <td class="fullPadded"><select id="massAddComponentSelect"></select></td>
                            </tr>
                            <tr>
                                <td class="fullPadded">To each:</td>
                                <td class="fullPadded"><select id="massAddTargetSelect"></select></td>
                            </tr>
                            <tr>
                                <td class="fullPadded">With probability for each attachment (float between 0.0 and 1.0):</td>
                                <td class="fullPadded"><input type="text" value="1.0" class="modalInput"/></td>
                            </tr>
                            <tr>
                                <td class="fullPadded"><button onclick="toggleElementDisplay('massAddModal')" class="modalButton">Cancel</button></td>
                                <td class="fullPadded"><button data-buttonfunction="submit" class="right modalButton">Apply</button></td>
                            </tr>
                        </tbody>
                    </table>
                </div>
            </div>
            <div id="massAddSecondaryModal" class="modal" style="display: none;">
                <div class="modalContent">
                    <h3></h3>
                    <div data-tableinsert></div>
                </div>
            </div>
            <div id="massEditModal" class="modal" style="display: none">
                <div class="modalContent">
                    <table>
                        <tbody>
                            <tr><th colspan="4" class="fullPadded">Mass Edit</th></tr>
                            <tr>
                                <td class="fullPadded">For each object of type</td>
                                <td class="fullPadded"><select id="massEditTargetSelect"></select></td>
                                <td class="fullPadded">with attribute</td>
                                <td class="fullPadded"><input type="text" id="massEditAttribute" class="modalInput"></td>
                            </tr>
                            <tr>
                                <td class="fullPadded"><input type="radio" name="attributeOperation" value="addTo">Add value to attribute</td>
                                <td class="fullPadded"><input type="text" id="addToValue" pattern="^0\.\d+|1(\.0+)?$" class="modalInput"/></td>
                            </tr>
                            <tr>
                                <td class="fullPadded"><input type="radio" name="attributeOperation" value="delete">Delete Attribute</td>
                            </tr>
                            <tr>
                                <td class="fullPadded"><input type="radio" name="attributeOperation" value="change">Change attribute to</td>
                                <td class="fullPadded"><input type="text" id="changeValue" pattern="^0\.\d+|1(\.0+)?$" class="modalInput"/></td>
                            </tr>
                            </tr>
                            <tr>		
                                <td class="fullPadded"><input type="radio" name="attributeOperation" value="multiplyBy">Multiply attribute by</td>
                                <td class="fullPadded"><input type="text" id="multiplyValue" pattern="^0\.\d+|1(\.0+)?$" class="modalInput"/></td>
                                <td class="fullPadded" style="text-align: center" >and add</td>
                                <td class="fullPadded"><input type="text" id="andAddValue" pattern="^0\.\d+|1(\.0+)?$" class="modalInput"/></td>
                            </tr>
                            <tr><td class="fullPadded">Or</td></tr>
                            <tr>
                                <td class="fullPadded"><input type="radio" name="attributeOperation" value="addAttribute"> Add new attribute</td>
                                <td class="fullPadded"><input type="text" id="newAttributeKey" class="modalInput"></td>
                                <td class="fullPadded" style="text-align: center">with value</td>
                                <td class="fullPadded"><input type="text" id="newAttributeValue" pattern="^0\.\d+|1(\.0+)?$" class="modalInput"/></td>
                            </tr>
                            <tr>
                                <td class="fullPadded"><button onclick="toggleElementDisplay('massEditModal')" class="modalButton">Cancel</button></td>
                                <td colspan="3" class="fullPadded"><button onclick="massEdit();" class="right modalButton">Apply</button></td>
                            </tr>
                        </tbody>
                    </table>
                </div>
            </div>
            <div id="attachmentsModal" class="modal" style="display: none">
                <div class="modalContent">
                    <table>
                        <tbody>
                            <tr><th colspan="2" class="fullPadded">Attachments</th></tr>
                            <tr>
                                <td class="fullPadded"><select id="attachmentSelect"></select></td>
                            </tr>
                            <tr>
                                <td class="fullPadded"><button onclick="toggleElementDisplay('attachmentsModal')" class="modalButton">Cancel</button></td>
                                <td class="fullPadded"><button onclick="toggleElementDisplay('attachmentsModal'); editAttachment()" class="modalButton">Select</button></td>
                            </tr>
                        </tbody>
                    </table>
                </div>
            </div>
            <div id="editAttachmentModal" class="modal" style="display: none">
                <div class="modalContent">
                    <table>
                        <tbody>
                            <tr><td id="attachmentTd" class="fullPadded"></td></tr>
                            <tr><td class="fullPadded"><textarea rows="25" cols="80" id="editAttachmentBox"></textarea></td></tr>
                            <tr>
                                <td class="fullPadded"><button onclick="toggleElementDisplay('editAttachmentModal')" class="modalButton">Cancel</button></td>
                                <td class="fullPadded"><button onclick="saveAttachment(); toggleElementDisplay('editAttachmentModal');" class="modalButton">Save</button></td>
                            </tr>
                        </tbody>
                    </table>
                </div>
            </div>
            <div id="climateModal" class="modal" style="display: none">
                <div class="modalContent">
                    <!--I assume this is supposed to update THIS feeder with the climate data. Therefore, uniqObjName with {{thisOwner}} is correct.-->
                    <form onsubmit="submitForm({formId:'climateForm', pollUrl:'/checkClimateChange/{{thisOwner}}/{{thisModelName}}'}); return false;"
                    action="/climateChange/{{thisOwner}}/{{thisFeederName}}" id="climateForm">
                        <input type="hidden" name="_csrf_token" value="{{csrf_token()}}"/>
                        <!--<input type="hidden" id="feederNum" name="feederNum" value="{{thisFeederNum}}"/>-->
                        <input type="hidden" id="modelName" name="modelName" value="{{thisModelName}}"/>
                        <!--<input type="hidden" name="referrer" value="distribution"/>-->
                        <table>
                            <tbody>
                                <tr><th colspan="2" class="fullPadded">Climate Change</th></tr>
                                <tr>
                                    <td class="fullPadded">
                                        <input id="historicalImport" type="radio" name="climateImportOption" value="historicalImport">
                                        <label for="historicalImport">Historical Weather</label>
                                    </td>
                                </tr>
                                <tr>
                                    <td class="fullPadded"><label for="startDate">Start Date (YYYY-MM-DD):</label></td>
                                    <td class="fullPadded"><input id="startDate" type="text" name="startDate" pattern="^\d{4}-\d{2}-\d{2}$" class="modalInput"></td>
                                </tr>
                                <tr>
                                    <td class="fullPadded"><label for="endDate">End Date (YYYY-MM-DD):</label></td>
                                    <td class="fullPadded"><input id="endDate" type="text" name="endDate" pattern="^\d{4}-\d{2}-\d{2}$" class="modalInput"></td>
                                </tr>
                                <tr>
                                    <td class="fullPadded"><label for="airport">Airport Code:</label></td>
                                    <td class="fullPadded"><input id="airport" type="text" name="airport" pattern="^[A-Z]{3}$" class="modalInput"></td>
                                </tr>
                                <tr>
                                    <td class="fullPadded">
                                        <input id="tmyImport" type="radio" name="climateImportOption" value="tmyImport">
                                        <label for="tmyImport">tmy Import</label>
                                    </td>
                                </tr>
                                <tr>
                                    <td class="fullPadded"><label for="zipCode">Zip Code:</label></td>
                                    <td class="fullPadded"><input id="zipCode" type="text" name="zipCode" pattern="^\d{5}$" class="modalInput"></td>
                                </tr>
                                <tr>
                                    <td class="fullPadded"><button type="button" onclick="toggleElementDisplay('climateModal')" class="modalButton">Cancel</button></td>
                                    <td class="fullPadded"><button type="submit" class="right modalButton">Apply</button></td>
                                </tr>
                            </tbody>
                        </table>
                    </form>
                </div>
            </div>
            <div id="anonymizeModal" class="modal" style="display: none">
                <div class="modalContent">
                    <!--I assume this is supposed to anonymize THIS feeder. Therefore, uniqObjName with {{thisOwner}} is correct.-->
                    <form onsubmit="submitForm({formId:'anonymizeForm', pollUrl:'/checkAnonymize/{{thisOwner}}/{{thisModelName}}'}); return false;" action="/anonymize/{{thisOwner}}/{{thisFeederName}}" id="anonymizeForm">
                        <input type="hidden" name="_csrf_token" value="{{csrf_token()}}"/>
                        <!--<input type="hidden" id="feederNum" name="feederNum" value="{{thisFeederNum}}"/>-->
                        <input type="hidden" id="modelName" name="modelName" value="{{thisModelName}}"/>
                        <!--<input type="hidden" name="referrer" value="distribution"/>-->
                        <table>
                            <tbody>
                                <tr><th class="fullPadded">Anonymization</th></tr>
                                <tr><th class="leftText fullPadded">Names and labels:</th></tr>
                                <tr>
                                    <td class="fullPadded">
                                        <select name="anonymizeNameOption">
                                            <option value="noChange">No change</option>
                                            <option value="pseudonymize">Pseudonymize</option>
                                            <option value="randomize">Randomize</option>
                                        </select>
                                    </td>
                                </tr>
                                <tr><th class="leftText fullPadded">Locations:</th></tr>
                                <tr>
                                    <td class="fullPadded">
                                        <input type="radio" id="noChange" name="anonymizeLocationOption" value="noChange" checked>
                                        <label for="noChange">No Change</label>
                                    </td>
                                </tr>
                                <tr>
                                    <td class="fullPadded">
                                        <input type="radio" id="randomize" name="anonymizeLocationOption" value="randomize">
                                        <label for="randomize">Randomize</label>
                                    </td>
                                </tr>
                                <tr>
                                    <td class="fullPadded">
                                        <input type="radio" id="forceLayout" name="anonymizeLocationOption" value="forceLayout">
                                        <label for="forceLayout">Force Layout</label>
                                    </td>
                                </tr>
                                <tr>
                                    <td class="fullPadded">
                                        <input type="radio" id="translation" name="anonymizeLocationOption" value="translation">
                                        <label for="translation">Translate</label>
                                    </td>
                                </tr>
                                <tr><td class="fullPadded"><input type="text" pattern="^[+-]?\d+(\.\d+)?$" name="translateRight" class="modalInputLine"> [ft] to the right and</td></tr>
                                <tr><td class="fullPadded"><input type="text" pattern="^[+-]?\d+(\.\d+)?$" name="translateUp" class="modalInputLine"> [ft] up with a</td></tr>
                                <tr><td class="fullPadded"><input type="text" pattern="^[+-]?\d+(\.\d+)?$" name="rotate" class="modalInputLine"> [degree] rotation.</td></tr>
                                <tr><th class="leftText fullPadded">Electrical properties:</th></tr>
                                <tr>
                                    <td class="fullPadded">
                                        <input type="checkbox" id="modifyLengthSize" name="modifyLengthSize" value="modifyLengthSize">
                                        <label for="modifyLengthSize">Modify conductor length and cable size</label>
                                    </td>
                                </tr>
                                <tr>
                                    <td class="fullPadded">
                                        <input type="checkbox" id="smoothLoadGen" name="smoothLoadGen" value="smoothLoadGen">
                                        <label for="smoothLoadGen">Smooth AMI Loadshapes</label>
                                    </td>
                                </tr>
                                <tr>
                                    <td class="fullPadded">
                                        <input type="checkbox" id="shuffleLoadGen" name="shuffleLoadGen" value="shuffleLoadGen">
                                        <label for="shuffleLoadGen">Shuffle loads and generators:</label>
                                        <!--<input type="text" name="shufflePerc" class="modalInputLine"> [%]</label>-->
                                        <!--Commented both of these out because I think the server expects a fractional decimal number-->
                                        <input type="text" pattern="^[+-]?\d+(\.\d+)?$" name="shufflePerc" class="modalInputLine"> [%]</label>
                                    </td>
                                </tr>
                                <tr>
                                    <td class="fullPadded">
                                        <input type="checkbox" id="addNoise" name="addNoise" value="addNoise">
                                        <label for="addNoise">Add noise:</label>
                                        <!--<input type="text" name="noisePerc" class="modalInputLine"> [%]</label>-->
                                        <input type="text" pattern="^[+-]?\d+(\.\d+)?$" name="noisePerc" class="modalInputLine"> [%]</label>
                                    </td>
                                </tr>
                                <tr>
                                    <td class="fullPadded">
                                        <button type="button" onclick="toggleElementDisplay('anonymizeModal')" class="modalButton">Cancel</button>
                                        <button type="submit" class="right modalButton">Apply</button>
                                    </td>
                                </tr>
                            </tbody>
                        </table>
                    </form>
                </div>
            </div>
            <div id="opacityModal" class="modal" style="display: none">
                <div class="modalContent">
                    <div data-tableinsert></div>
                    <div class="centered fullPadded">
                        <button onclick="toggleElementDisplay('opacityModal');" class="modalButton">Close</button>
                        <button onclick="gOpacityManager.reset();" class="modalButton">Reset</button>
                    </div>
                </div>
            </div>
            <div id="colorModal" class="modal" style="display: none">
                <div class="centered modalContent">
                    <h3>Color Circuit</h3>
                    <div class="fullPadded"><input type="file" multiple accept=".csv" class="modalInput"></div>
                    <div data-tableinsert class="leftText vertFlex fullPadded"></div>
                    <div class="fullPadded">
                        <button onclick="toggleElementDisplay('colorModal');" class="modalButton">Close</button>
                        <button data-buttonfunction="reset" class="modalButton">Reset</button>
                    </div>
                </div>
            </div>
            <div id="colorLegends" class="floatingTables"></div>
            <!--Modals-->
        </div>
	</body>
</html>
<script id="feederInsert">let gReadFeeder = {% if thisFeederData %}{{ thisFeederData | safe }}{% else %}null{% endif %}; 
</script>
<style id="jqueryCssInsert">
</style>
<script id="jqueryInsert">
</script>
<script id="jqueryUiInsert">
</script>
<script id="panZoomInsert">
</script>
<script id="chromaInsert">
</script>
<script id="papaParseInsert">
</script>
<script type="text/javascript">

//**************************************************
// global variables
//**************************************************

"use strict";
let gThisFeederName = "{% if thisFeederName %}{{ thisFeederName | safe }}{% else %}null{% endif %}";
const gThisFeederNum = {% if thisFeederNum %}{{ thisFeederNum | safe }}{% else %}null{% endif %}; 
const gThisModelName = "{% if thisModelName %}{{ thisModelName | safe }}{% else %}null{% endif %}"; 
const gThisOwner = "{% if thisOwner %}{{ thisOwner | safe }}{% else %}null{% endif %}"; 
const gCurrentUser = "{% if currentUser %}{{ currentUser | safe }}{% else %}null{% endif %}"
const gPublicFeeders = {% if publicFeeders %}{{ publicFeeders | safe }}{% else %}null{% endif %};
const gUserFeeders = {% if userFeeders %}{{ userFeeders | safe }}{% else %}null{% endif %}; 
const gWriteFeeder = deepCopy(gReadFeeder);
let gTree; // A wrapper around the gWriteFeeder.tree data structure. Has methods for accessing and modifying the data.
let gComponentManager; // A wrapper around all component.json objects.
let gSelection;
let gViewport; 
let gOpacityManager;
let gAddManager;
let gMinLon; // The minimum longitude found among all the gWriteFeeder.tree objects. Used to transform and flip how the graph is drawn.
let gMaxLat; // The maximum latitude found among all the gWriteFeeder.tree objects. Used to transform and flip how the graph is drawn.
let gDrawScaleFactor; // A number that scales all graph data to fit within a 1000 x 1000 viewport size so the graph draws nicely.
let gDownX;
let gDownY;
const gViridisColors = ["#440154FF", "#481567FF", "#482677FF", "#453781FF", "#404788FF", "#39568CFF", "#33638DFF", "#2D708EFF", "#287D8EFF", "#238A8DFF", "#1F968BFF", "#20A387FF", "#29AF7FFF", "#3CBB75FF", "#55C667FF", "#73D055FF", "#95D840FF", "#B8DE29FF", "#DCE319FF", "#FDE725FF"];
let gScaleLevel = 1.0; // Scale that all SVG objects are drawn at

//**************************************************
// Tree class
//**************************************************

const treePrototype = {

    /* Public methods */

    /**
     * tested.
     */
    getObject(key) {
        const obj = this.tree[key];
        if (obj == null) throw new Error(`getObject() failed. The object with the key "${key}" does not exist in the Tree.`);
        return this.tree[key];
    },

    /**
     * not tested. 
     */
    getParent(childKey) {
        const parentKey = this.treeMap.getParentKey(childKey);
        if (parentKey == null) return;
        return this.getObject(parentKey);
    },

    /**
     * not tested.
     */
    getToNodeKey(lineKey) {
        const sourceName = this.tree[lineKey].to;
        if (sourceName == null) return;
        let key;
        try {
            key = this.treeMap.getKey(sourceName);
        } catch (e) {
            console.error(`The line object named "${this.getObject(lineKey).name}" has a nonexistent source node named "${sourceName}". The line was not drawn.`);
        }
        return key;
    },

    /**
     * not tested.
     */
    getToNode(lineKey) {
        const sourceKey = this.getToNodeKey(lineKey);
        if (sourceKey == null) return;
        return this.getObject(sourceKey);
    },

    /**
     * not tested.
     */
    getFromNodeKey(lineKey) {
        const targetName = this.tree[lineKey].from;
        if (targetName == null) return;
        let key;
        try {
            key = this.treeMap.getKey(targetName);
        } catch (e) {
            console.error(`The line object named "${this.getObject(lineKey).name}" has a nonexistent target node named "${targetName}". The line was not drawn.`);
        }
        return key;
    },

    /**
     * not tested.
     */
    getFromNode(lineKey) {
        const targetKey = this.getFromNodeKey(lineKey);
        if (targetKey == null) return;
        return this.getObject(targetKey);
    },

    /**
     * not tested.
     */
    getPairedNodeKeys(nodeKey) {
        const pairedNodes = [];
        const lineKeys = this.treeMap.getLineKeys(nodeKey);
        if (lineKeys == null) return;
        lineKeys.forEach(key => {
            if (this.getToNodeKey(key) === nodeKey) {
                pairedNodes.push(this.getFromNodeKey(key));
            } else {
                pairedNodes.push(this.getToNodeKey(key));
            }
        });
        return pairedNodes;
    },

    /**
     * tested.
     */
    insert(treeObject) {
        this.tree[treeObject.key] = treeObject.data;
        this.treeMap.add(treeObject.key);
    },

    /** 
     * tested.
     */
    isDeletable(key) {
        this.getObject(key);
        const children = this.treeMap.getChildKeys(key);
        if (children != null) return false;
        const lines = this.treeMap.getLineKeys(key);
        if (lines != null) return false;
        return true;
    },

    /**
     * not tested.
     * @param {Array} keys
     */
    delete(keys) {
        this.treeMap.remove(keys);
        keys.forEach(key => {
            this.getObject(key);
            delete this.tree[key];
        });
    },

    /** 
     * tested.
     * Return an array of keys that need to be deleted as a result of deleting a tree object.
     * 
     * @param {string} key - the key of the tree object for which to find its deletable subtree.
     * @param {Array} visited - contains keys of tree objects that have already been visited so the method dosen't * recurse infinitely in case of a cycle.
     * @return {Array}
     */
    getSubtreeToDelete(key, visited = []) {
        if (!Array.isArray(visited)) throw new Error("Visited argument must be an array");
        visited.push(key);
        const keySet = new Set();
        const lines = this.treeMap.getLineKeys(key);
        const children = this.treeMap.getChildKeys(key);
        if (lines != null) lines.forEach(key => keySet.add(key));
        if (children != null) children.forEach(key => keySet.add(key));
        keySet.forEach(outerKey => {
            if (!visited.includes(outerKey)) {
                this.getSubtreeToDelete(outerKey, visited).forEach(innerKey => keySet.add(innerKey));
            }
        });
        return Array.from(keySet);
    },

    /* Private methods */
};

/**
* tested.
*/
function createTree(tree = {}) {
    const invalidKeys = [];
    const invalidCoordinateKeys = [];
    Object.keys(tree).forEach(key => {
        if (!isNumberString(key)) invalidKeys.push(key);
        ["longitude", "latitude"].forEach(prop => {
            if (tree[key][prop] != null) {
                if (isNumberString(tree[key][prop])) {
                    tree[key][prop] = parseFloat(tree[key][prop])
                } else if (typeof tree[key][prop] !== "number") {
                    invalidCoordinateKeys.push(key);
                }
            }
        });
    });
    if (invalidKeys.length !== 0) {
        throw new Error(`Interface could not be built. The following object keys aren't numbers: "${invalidKeys}".`);
    }
    if (invalidCoordinateKeys.length !== 0) {
        throw new Error(`Interface could not be built. The following object keys have objects with non-numeric longitude or latitude values: "${invalidCoordinateKeys.join(", ")}".`);
    }
    const treeWrapper = Object.create(treePrototype);
    treeWrapper.tree = tree;
    treeWrapper.treeMap = createTreeMap(tree);
    return treeWrapper;
}

//**************************************************
// TreeMap class
//**************************************************

const treeMapPrototype = {

    /* Public methods */

   /**
    * not tested.
    */
    add(key) {
        this.mapName(key);
        this.mapChild(key);
        this.mapLine(key);
    },

   /**
    * not tested.
    * @param {Array} keys
    */
    remove(keys) {
        keys.forEach(key => {
            this.unmapLine(key);
            this.unmapChild(key);
        });
        keys.forEach(key => {
            this.unmapName(key);
        });
    },

   /**
    * not tested.
    * This should throw an Error. If I provide what I believe is a valid name, I expect to get a key!
    */
    getKey(name) {
        if (name == null) {
            throw new Error(`getKey() failed. The name: "${name}" is invalid.`);
        }
        const key = this.names[name];
        if (key === undefined) {
            throw new Error(`getKey() failed. Did not find the name "${name}" in this.names.`);
        }
        return key;
    },

   /**
    * not tested.
    */
    getChildKeys(key) {
        return this.children[key];
    },

   /**
    * not tested.
    */
    getLineKeys(key) {
        return this.lines[key];
    },

   /**
    * not tested.
    */
    getParentKey(childKey) {
        const parentName = this.tree[childKey].parent;
        if (parentName === undefined) return;
        let parentKey;
        try {
            parentKey = this.getKey(parentName);
        } catch (e) {
            console.error(`The child object named "${this.tree[childKey].name}" has a nonexistent parent object named "${parentName}". The parent-child line was not drawn.`);
            return;
        }
        return parentKey;
    },

    /* Private TreeMap methods */

    /**
    * not tested.
    */
    getNodeEndKeys(lineKey) {
        const sourceName = this.tree[lineKey].to;
        const targetName = this.tree[lineKey].from;
        let sourceKey, targetKey;
        if (sourceName === undefined && targetName === undefined) return {};
        if (sourceName !== undefined && targetName !== undefined) {
            try {
                sourceKey = this.getKey(sourceName);
                targetKey = this.getKey(targetName);
            } catch(e) {
                //Commented out because this message is redundant and less helpful than other error messages
                //console.error(`The line object named "${this.tree[lineKey].name}" has nonexistent 'to' and/or 'from' nodes.`);
                return {};
            }
        } else {
            console.error(`The line object named "${this.tree[lineKey].name}" is missing a 'to' or 'from' property.`);
            return {};
        }
        return {sourceKey: sourceKey, targetKey: targetKey};
    },

   /**
    * not tested. 
    */
    mapName(key) {
        const name = this.tree[key].name;
        if (name == null) return; // TODO: Do I allow names to be null at all?
        const lowercaseName = String(name).toLowerCase();
        if (lowercaseName === "null" || lowercaseName === "undefined") return;
        this.names[name] = key;
    },

   /**
    * not tested.
    */
    unmapName(key) {
        const name = this.tree[key].name;
        if (name == null) return;
        delete this.names[name];
    },

    /**
    * not tested.
    */
    mapChild(childKey) {
        const parentKey = this.getParentKey(childKey);
        if (parentKey == null) return;
        if (this.children[parentKey] == null) {
            this.children[parentKey] = [childKey];
        } else if (!this.children[parentKey].includes(childKey)) {
            this.children[parentKey].push(childKey);
        } 
    },

   /**
    * not tested.
    */
    unmapChild(childKey) {
        const parentKey = this.getParentKey(childKey);
        if (parentKey == null) return;
        const idx = this.children[parentKey].indexOf(childKey);
        if (idx >= 0) {
            this.children[parentKey].splice(idx, 1);
            if (this.children[parentKey].length === 0) {
                delete this.children[parentKey];
            }
        } else {
            console.error(`Could not unmap child with key "${childKey}" from parent with key ${parentKey}.`);
        }
    },

   /**
    * not tested. 
    */
    mapLine(lineKey) {
        let {sourceKey, targetKey} = this.getNodeEndKeys(lineKey);
        if (sourceKey == null || targetKey == null) return;
        if (this.lines[sourceKey] == null) {
            this.lines[sourceKey] = [lineKey];
        } else if (!this.lines[sourceKey].includes(lineKey)) {
            this.lines[sourceKey].push(lineKey);
        }
        if (this.lines[targetKey] == null) {
            this.lines[targetKey] = [lineKey];
        } else if (!this.lines[targetKey].includes(lineKey)) {
            this.lines[targetKey].push(lineKey);
        }
    },

   /**
    * not tested.
    */
    unmapLine(lineKey) {
        let {sourceKey, targetKey} = this.getNodeEndKeys(lineKey);
        if (sourceKey == null || targetKey == null) return;
        [sourceKey, targetKey].forEach(key => {
            const idx = this.lines[key].indexOf(lineKey);
            if (idx >= 0) {
                this.lines[key].splice(idx, 1);
                if (this.lines[key].length === 0) {
                    delete this.lines[key];
                }
            } else {
                console.error(`Could not unmap line with key "${lineKey}" from node with key "${key}".`);
            }
        });
    },
};

/**
 * tested.
 */
function createTreeMap(tree) {
    const map = Object.create(treeMapPrototype);
    map.tree = tree;
    map.names = {};
    map.children = {};
    map.lines = {};
    //map.objectTypes = {};
    const keys = Object.keys(tree);
    keys.forEach(key => {
        map.mapName(key);
    });
    keys.forEach(key => {
        map.mapChild(key);
        map.mapLine(key);
    });
    return map;
}

//**************************************************
// ComponentManager class
//**************************************************

const componentManagerPrototype = {

    /* Public methods */

    /**
     * tested.
     */
    insert(component) {
        if (component.object == null) {
            alert(`The component ${JSON.stringify(component)} was invalid.`);
            return;
        }
        if (component.name == null) component.name = component.object;
        let objectMap = this.components[component.object];
        if (objectMap == null) {
            this.components[component.object] = {};
            objectMap = this.components[component.object];
        }
        if (objectMap[component.name] != null) {
            component.name = this.getUniqueName(objectMap, component.name);
        }
        objectMap[component.name] = component;
    },

    /**
     * @return {Array} - an array of component types.
     */
    getTypes() {
        return Object.keys(this.components);
    },

    /**
     * @return {Array|undefined} - an array of component names of the specified type, or undefined.
     */
    getNamesOfType(objectType) {
        const objects = this.components[objectType];
        return objects == null ? undefined : Object.keys(objects);
    },

    get(objectType, name) {
        const objectMap = this.components[objectType];
        return objectMap == null ? undefined : objectMap[name];
    },

    getAny(objectType) {
        const names = this.getNamesOfType(objectType);
        return names == null ? undefined : this.components[objectType][names[0]];
    },

    /* Private methods */

    getUniqueName(objectMap, name) {
        const originalName = name;
        let count = 0;
        while (objectMap[name] != null) {
            count++;
            name = `${originalName}_${count}`;
        }
        return name;
    }
}

function createComponentManager() {
    const cm = Object.create(componentManagerPrototype);
    cm.components = {};
    return cm;
}

// Insert the components into the gComponentManager
(() => {
    const components = {% if components %}{{ components | safe }}{% else %}null{% endif %};
    gComponentManager = createComponentManager();
    Object.values(components).forEach(c => {
        gComponentManager.insert(c);
    });
})();

//**************************************************
// addManager class
//**************************************************

const addManagerPrototype = {

    /* Public methods */

    /**
     * not tested.
     */ 
    massAdd() {
        const component = this.component;
        const targetObject = this.target;
        const probability = this.probability;
        if (component.object == null) {
            alert("Please select a component to add.");
            return;
        }
        else if (targetObject === "") {
            alert("Please select an object to add to.");
            return;
        }
        if (component.object === "recorder" || getRelationship(gComponentManager.getAny(targetObject)) !== "line") {
            const newObjects = [];
            const pm = new ProgressModal(`Adding a "${component.object}" object to every "${targetObject}" object. This could take a few seconds.`);
            pm.show();
            setTimeout(() => {
                Object.keys(gTree.tree).forEach(key => {
                    if (gTree.getObject(key).object === targetObject && Math.random() < probability) {
                        const tObject = createTreeObject(component, gTree);
                        tObject.setupChildNode(key);
                        gTree.insert(tObject);
                        newObjects.push(tObject.key);
                    }
                });
                createSvgData(newObjects).draw(gViewport);
                pm.hide();
                alert(`${newObjects.length} "${component.name}" objects added to the feeder`);
                toggleElementDisplay("massAddModal");
            }, 10);
        } else {
            alert("Mass add failed. No object can be added as a child of a line, except for recorder objects.");
        }
    },

    /**
     * TODO: implement formatting function and test on this table.
     * @param {string} type - The type of the object to view.
     * @param {boolean} massAdd - Whether or not this is a mass add operation.
     */ 
    buildSecondaryModal(type, massAdd=false) {
        const that = this;
        const modal = document.getElementById("massAddSecondaryModal");     
        modal.removeAttribute("style");
        const tableDiv = modal.querySelector("[data-tableinsert]");
        Array.from(tableDiv.children).forEach(child => {
            child.parentElement.removeChild(child);
        });
        modal.querySelector("h3").textContent = type;
        const table = document.createElement("table");
        const tBody = document.createElement("tbody");
        table.append(tBody);

        const names = gComponentManager.getNamesOfType(type);
        names.forEach(name => {
            const tr = document.createElement("tr");
            let td = document.createElement("td");
            tr.append(td);
            const component = gComponentManager.get(type, name);
            let button;
            if (massAdd === false) {
                button = getTableButton("Add", () => {
                    modal.style.display = "none";
                    getAddComponentFunction(component)();
                });
            } else {
                button = getTableButton("Select", () => {
                    modal.style.display = "none";
                    that.component = component;
                });
            }
            td.append(button);
            td = document.createElement("td");
            td.textContent = name;
            tr.append(td);
            tBody.append(tr);
        });
        formatModal(modal);
        formatTable(table);
        tableDiv.append(table);
    },

    /**
     * Not tested.
     */
    setupTargetSelect() {
        const select = document.getElementById("massAddTargetSelect");
        select.innerHTML = "";
        select.innerHTML += `<option value=${""}>${""}</option>`;
        const types = []
        const relationships = getExistingRelationships();
        Object.keys(relationships).forEach(key => {
            if (key !== "configurationNode") {
                relationships[key].forEach(type => {
                    types.push(type);
                });
            }
        });
        const that = this;
        types.map(type => type.toLowerCase()).sort().forEach(lowercaseType => {
            const key = gComponentManager.getTypes().includes(lowercaseType) ? lowercaseType : getMixedCaseKey(gComponentManager.components, lowercaseType);
            const option = document.createElement("option");
            option.textContent = key;
            option.value = key;
            // Don't add event listeners to option elements, add them to the select element.
            select.append(option);
        });
        select.onchange = function() {
            that.target = this.value;
        }
    },

    /* Private methods */

    /**
     * I don't need to build the primary modal, but I do need to set it up.
     * When "close" is clicked, this instance of addManager never goes away (memory leak) because of the reference to the primary modal. Also because the document elements have event listeners that link to the addManager. Easy solution is just to have one global addManager. It would be interesting to test this memory leak hypothesis. Also I'm adding multiple event listeners to the same element right?
     */
    setupPrimaryModal() {
        const primaryModal = document.getElementById("massAddModal");
        const input = primaryModal.querySelector("input");
        const that = this;
        // Don't want to add an event listener every time this is set up.
        input.onchange = function() {
            that.setProbability(this);
        }
        const applyButton = primaryModal.querySelector("button[data-buttonfunction=submit]");
        applyButton.onclick = function() {
            that.massAdd();
            that.reset();
        }
    },

    /**
     * The components never change, so don't bother updating. We can only add child components.
     */
    setupComponentSelect() {
        const select = document.getElementById("massAddComponentSelect");
        select.innerHTML += `<option value=${""}>${""}</option>`;// TODO: add blank item
        const that = this;
        gComponentManager.getTypes().forEach(type => {
            //TODO: alphabetize
            if (getRelationship(gComponentManager.getAny(type)) === "childNode") {
                const names = gComponentManager.getNamesOfType(type);
                const option = document.createElement("option");
                select.append(option);
                if (names.length === 1) {
                    //TODO: show the name in the modal
                    option.value = "finish";
                    option.textContent = type;
                } else {
                    option.value = "continue";
                    option.textContent = `${type}...`;
                }
            }
        });
        select.addEventListener("change", function() {
            const value = this.options[this.selectedIndex].value;
            if (value === "") {
                that.component = {};
            }
            else {
                let type = this.options[this.selectedIndex].textContent;
                if (value === "finish") {
                    const name = gComponentManager.getNamesOfType(type)[0];
                    that.component = gComponentManager.get(type, name);
                } else if (value === "continue"){
                    type = type.replace(/[.]{3}/, "");
                    that.buildSecondaryModal(type, true);
                }
            }
        });
    },

    setComponent() {

    },

    //add on change anonymous listener to input
    setProbability(input) {
        let float = input.value;
        if (!isNumberString(float) || parseFloat(float) > 1.0 || parseFloat(float) < 0) {
            alert("Please enter a valid number for attachment probability.");
            input.value = this.probability;
        } else {
            this.probability = parseFloat(float)
        }
    },

    reset() {
        const modal = document.getElementById("massAddModal");
        modal.querySelectorAll("select").forEach(s => {
            s.selectedIndex = 0;
        });
        modal.querySelector("input").value = 1.0;
        this.target = "";
        this.component = {};
        this.probability = 1;
    }
}

function createAddManager() {
    const am = Object.create(addManagerPrototype);
    am.probability = 1.0; //default so there's never an invalid value
    am.target = "";
    am.component = {}; //need to display component.name
    am.setupComponentSelect();
    am.setupPrimaryModal();
    return am;
}

//**************************************************
// Selection Interface
//**************************************************

const selectionPrototype = {

    /* Public methods */

    hasId(id) {
        if (this.selectedElements.find(e => e.id === id) != null) return true;
        return false;
    },
    remove(element) {
        const elements = this.selectedElements.filter(e => e.id === element.id);
        if (elements.length === 0) throw new Error(`Remove operation failed. The element "${element.tagName}" does not exist in this selection.`);
        elements.forEach(e => {
            e.classList.remove("selected");
            Array.from(e.children).forEach(child => {
                e.removeChild(child);
            })
            this.selectedElements.splice(this.selectedElements.indexOf(e), 1);
        });
    },
    add(element) {
        if (this.selectedElements.includes(element)) {
            throw new Error("Add operation failed. The element argument already exists in this selection.");
        } else if (element.classList.contains("selected")) {
            throw new Error("Add operation failed. The element argument already has the 'selected' class.");
        }
        element.classList.add("selected");
        this.addAnimation(element);
        this.selectedElements.push(element);
    },
    empty() {
        this.selectedElements.forEach(e => {
            e.classList.remove("selected");
            Array.from(e.children).forEach(child => {
                e.removeChild(child);
            });
        });
        this.selectedElements = [];
    },
    getKeys() {
        return this.selectedElements.map(element => {
            return element.id;
        });
    },

    /* Private methods */

    /** 
     * An <animate> element points to exactly one other element. If there is no 'href' attribute, then the element is the direct parent of the <animate> element. I cannot apply a single <animate> element to multiple elements.
     * @param {HTMLElement} e
     */
    addAnimation(e) {
        e.innerHTML = `<animate id="anim1${e.id}" attributeName="stroke" values="#FFFFFF;#00FF00;#FFFFFF" dur="0.6s" repeatCount="indefinite"/>`;
    },
}

function createSelection() {
    const obj = Object.create(selectionPrototype);
    obj.selectedElements = [];
    return obj;
}

function saveSvg() {
	// Create an SVG that can be saved.
	alert("We are redirecting you to a static version of the SVG that you can save as a .svg file.")
	var svg = document.getElementById("svgContainer").outerHTML
	var win = window.open()
	win.document.write(svg)
}

function downloadTextFile() {
	// WARNING! Performance is very bad because the JSON is enormous! This can hang your browser!
	alert("We are opening a window with JSON in it that you can save as a .json file.")
	var modJson = JSON.stringify(gWriteFeeder);
	var win = window.open();
	win.document.write(modJson);
}

function scaleGraphForVisualAppearance(objectCount) {
    if (objectCount < 100) {
        gScaleLevel = 4;
    } else if (objectCount < 1000) {
        gScaleLevel = .7;
    } else {
        gScaleLevel = .5;
    }
}

/**
 * TODO: add unit tests
 * Get dimensions with: panZoom.getSizes()
 * scale of .0000004 displays real lat/lon fairly well
 */
function createViewport(tree, svgContainer) {
    const keys = Object.keys(tree);
    const firstKey = keys.find(key => tree[key].longitude != null && tree[key].latitude != null);
    if (firstKey == null) {
        // There were no coordinates, so insert some!
        const objects = Object.values(tree);
        insertCoordinates(objects, 0, 0, 50);
        scaleGraphForVisualAppearance(keys.length)
    }
    const minMax = getMinMax({objectContainer: tree, properties: ["longitude", "latitude"]});
    let {latitude: {min: minLat}} = minMax;
    let {latitude: {max: maxLat}} = minMax;
    let {longitude: {min: minLon}} = minMax;
    let {longitude: {max: maxLon}} = minMax;
    /* Longitude is not reversed, so I want the minimum longitude to use as the offset. Latitude IS reversed, so I want the maximum latitude to use as the offset. */
    const longitudeRange = maxLon - minLon;
    const latitudeRange = maxLat - minLat;
    gMinLon = minLon;
    gMaxLat = maxLat;
    /* Multiply by the gDrawScaleFactor when drawing. Divide by the gDrawScaleFactor when storing. 
    We use the larger of the range values to set the gDrawScaleFactor to make the graph fit in the viewport initially.
    */
    if (longitudeRange > latitudeRange) {
        gDrawScaleFactor = 1000/longitudeRange;
    } else {
        gDrawScaleFactor = 1000/latitudeRange;
    }
    svgContainer.setAttribute("viewBox",`0 0 ${1000} ${1000}`);
    /* Uncomment below to make gScaleFactor go away */
    //gDrawScaleFactor = 1;
    //svgContainer.setAttribute("viewBox",`0 0 ${longitudeRange} ${latitudeRange}`);
    /* Uncomment above to make gScaleFactor go away */
	window.panZoom = svgPanZoom("#svgContainer", {
        /* Override the default values set by "optionsDefaults" in svg-pan-zoom.js */
        dblClickZoomEnabled: false,
        zoomScaleSensitivity: 0.2,
        minZoom: 0.1,
		maxZoom: 500
    });
}

//**************************************************
// Click event functions
//**************************************************

/**
 * TODO: add unit tests, this should only handle selection objects. creating tables is a special listener attached to svgContainer,
 * not svgContainerWrapper
 * Listener on the SVG object that handles user clicks.
 */
function handleSelection(event) {
    if (detectDrag(event)) return;
    const element = event.target;
    if (event.altKey && (element.tagName === "circle" || element.tagName === "line") && !element.classList.contains("parentChild")) {
        if (gSelection.hasId(element.id)) {
            gSelection.remove(element);
            //Copied from rowPrototype.delete(). Refactor needed
            const table = document.getElementById(`descriptionTable_${element.id}`);
            if (table != null) {
                document.getElementById("descriptionTables").removeChild(table);
            }
        } else {
            gSelection.add(element);
        }
        rebuildSelectionTable();
    } else if (!event.altKey) {
        gSelection.empty();
        destroyTables(["descriptionTables", "selectionTable"]);
        //destroyTables(["selectionTable"]);
        if ((element.tagName === "circle" || element.tagName === "line") && !element.classList.contains("parentChild")) {
            gSelection.add(element);
            const table = createDescriptionTable(element.id);
            table.id = `descriptionTable_${element.id}`;
            document.getElementById("descriptionTables").appendChild(table);
        } 
    }
}

//function hotkeys() {
//	// Handle hotkey presses.
//	let x;
//	if (window.event) {
//		// IE8 and earlier
//		x = event.keyCode
//	} else if (event.which) {
//		// IE9/Firefox/Chrome/Opera/Safari
//		x = event.which
//	}
//	var keychar = String.fromCharCode(x);
//	if (event.target.type !== 'text') {
//		// Dispatch the key:
//		if (keychar == '-') {
//			window.panZoom.zoomOut()
//		} else if (keychar == '=') {
//			window.panZoom.zoomIn()
//		} else if (keychar =='m') {
//            attachMoveSelectionListener();
//		}
//	}
//}

/**
 * Scale the thickness of all lines and size of all circles. This helps user see details.
 * @param {number} x
 */
function scaleTo(x) {
    gScaleLevel = x;
	const circles = document.getElementsByTagName("circle")
	const lines = document.getElementsByTagName("line")
	// Scale Circles
	for (let i = 0; i < circles.length; i++) {
		circles[i].setAttribute("r", 2*x)
		circles[i].setAttribute("stroke-width", 0.5*x)
	}
	// Scale Lines
	for (let i = 0; i < lines.length; i++) {
		if (lines[i].getAttribute("class").indexOf("p2") !== -1) {
			lines[i].setAttribute("stroke-width", 2*x)
		}
		else if (lines[i].getAttribute("class").indexOf("p3") !== -1) {
			lines[i].setAttribute("stroke-width", 3*x)
		}
		else if (lines[i].getAttribute("class").indexOf("parentChild") !== -1) {
			lines[i].setAttribute("stroke-width", 0.5*x)
		}
		else {
			lines[i].setAttribute("stroke-width", x)
		}
	}
}

//Returns real Lat/Long of a click event, used in the moveBus function
function clickLatLon(event) {
	const pan = window.panZoom.getPan();
    const zoom = panZoom.getSizes().realZoom;
	const svg = document.getElementById("svgContainer");
	let pt = svg.createSVGPoint();
	pt.x = event.clientX;
	pt.y = event.clientY;
	pt = pt.matrixTransform(svg.getScreenCTM().inverse());
	let x = pt.x;
	let y = pt.y;
	const coords = {
		x: (x - pan.x) / zoom,
		y: (y - pan.y) / zoom
	};
	return coords;
}

//**************************************************
// Find modal interface
//**************************************************

function searchTerm() {
    let keys;
    let operation = document.querySelector("input[name=searchMode]:checked").value;
    if (operation === "searchExactString") {
        keys = findExactString(this.value.trim());
    } else if (operation === "searchSubstring") {
        keys = findSubstring(this.value.trim());
    }
    prepareFoundKeys.bind(this)(keys);
}
/**
 * @param {Array} keys
 */
function prepareFoundKeys(keys) {
    document.getElementById("searchCount").textContent = `hits: ${keys.length}`;
    const nextButton = document.getElementById("findNext");
    const previousButton = document.getElementById("findPrevious");
    if (keys.length === 0 || this.value === "") {
        alert(`No results found for term: "${this.value}".`)
        const feedback = function() {
            alert("Please enter a new term to search for."); 
        }
        nextButton.onclick = feedback;
        previousButton.onclick = feedback;
        document.getElementById("foundElementKey").textContent = "";
        return;
    }
    const upperIndex = keys.length - 1;
    let idx = 0;
    viewElement(keys[idx]);
    nextButton.onclick = function() {
        idx++;
        if (idx > upperIndex) idx = 0;
        viewElement(keys[idx]);
    }
    previousButton.onclick = function() {
        idx--;
        if (idx < 0) idx = upperIndex;
        viewElement(keys[idx]);
    }
}

function findExactString(string) {
    const keys = [];
    if (string === "") return keys;
    const tree = gTree.tree;
    for (let key in tree) {
        if (key === string) keys.push(key);
        for (let propertyKey in tree[key]) {
            let propertyVal = tree[key][propertyKey];
            if (typeof(propertyVal) !== "string") propertyVal += "";
            if (propertyKey.toLowerCase() === string.toLowerCase()) {
                keys.push(key);
                break;
            } else if (propertyVal.toLowerCase() === string.toLowerCase()) {
                keys.push(key);
                break;
            }
        }
    }
    return keys;
}

/**
 * TODO: add unit tests
 */
function findSubstring(substring) {
    const keys = [];
    if (substring === "") return keys;
    const tree = gTree.tree;
    for (let key in tree) {
        if (key.includes(substring)) keys.push(key);
        for (let propertyKey in tree[key]) {
            let propertyVal = tree[key][propertyKey];
            if (typeof(propertyVal) !== "string") propertyVal += "";
            if (propertyKey.toLowerCase().includes(substring.toLowerCase())) {
                keys.push(key);
                break;
            } else if (propertyVal.toLowerCase().includes(substring.toLowerCase())) {
                keys.push(key);
                break;
            }
        }
    }
    return keys;
}

/** 
 * TODO: add unit tests
 */
function viewElement(key) {
    destroyTables(["descriptionTables"]);
    if (document.getElementById("showTableOnFind").checked) {
        document.getElementById("descriptionTables").appendChild(createDescriptionTable(key));
    }
    document.getElementById("foundElementKey").textContent = key;
    gSelection.empty();
    const element = document.getElementById(key);
    gSelection.add(element);
    let x, y;
    if (element.getAttribute("cx") != null && element.getAttribute("cy") != null) {
        x = element.getAttribute("cx");
        y = element.getAttribute("cy");
    } else {
		x = (parseFloat(element.getAttribute("x1")) + parseFloat(element.getAttribute("x2"))) / 2;
		y = (parseFloat(element.getAttribute("y1")) + parseFloat(element.getAttribute("y2"))) / 2;
    }
    // I can"t make this work 
    //panZoom.zoomAtPoint(2, {x: x, y: y});
    // Do this instead 
	panZoom.pan({x:0, y:0})
	var realZoom = window.panZoom.getSizes().realZoom
	var width = window.panZoom.getSizes().width / 2
	var height = window.panZoom.getSizes().height / 2
    panZoom.pan({x:width - (x * realZoom), y:height - (y * realZoom)})
    panZoom.zoom(20/gScaleLevel);
}

//**************************************************
// jQuery handling for distNetViz.py
//**************************************************

/** 
 * TODO: add unit tests?
 * If this interface is being used as a file, we can't import jQuery with <script> so we can't use jQuery
 * styling. This function is only called when jQuery is available.
 */
 function applyJQueryStyles() {
    // Make stuff draggable
    $("#findModal .modalContent").draggable();
    $("#progressModal .modalContent").draggable();
    $("#loadModal .modalContent").draggable();
    $("#blankFeederModal .modalContent").draggable();
    $("#milsoftModal .modalContent").draggable();
    $("#gridlabdModal .modalContent").draggable();
    $("#cymeModal .modalContent").draggable();
    $("#scadaModal .modalContent").draggable();
    $("#amiModal .modalContent").draggable();
    $("#massAddModal .modalContent").draggable();
    $("#massEditModal .modalContent").draggable();
    $("#attachmentsModal .modalContent").draggable();
    $("#colorModal .modalContent").draggable();
    // Position the description table depending on whether or not it is draggable
    //document.getElementById("descriptionTable").removeAttribute("style");
    //document.getElementById("descriptionTable").style.left = "70vw";
}

/** 
 * Ajax requests depend on jQuery, so any function that uses $.ajax() cannot be used if this interface
 * is loaded as a file. This function is called when jQuery isn't available.
 */
function disableJQueryFunctionality() {
    //Hide stuff that doesn't work in distNetViz.py
    Array.from(document.querySelectorAll("[data-web]")).forEach(li => {
        li.remove();
    });
    //document.getElementById("findModal").style.justifyContent = "left";
}

//**************************************************
// Header menu functions
//**************************************************



//delete this eventually
function insertIndependentComponent(component) {
    alert("Please click a location on the graph to insert this component.");
    const svgContainer = document.getElementById("svgContainer");
    svgContainer.setAttribute("style", "cursor: crosshair");
    svgContainer.onclick = function(event) {
        if (detectDrag(event)) return;
        const tObject = createTreeObject(component, gTree);
        insertCoordinates([tObject.data], 0, 0, 0);
        getMoveNodesFunction([tObject.data])(event);
        gTree.insert(tObject);
        createSvgData([tObject.key]).draw(gViewport);
    }
}

//delete this eventually
function insertChildComponent(keys, component) {
    const svgContainer = document.getElementById("svgContainer");
    if (keys.length === 0) {
        alert("Please click on another circle that is not a configuration node to add this component as a child.");
        svgContainer.setAttribute("style", "cursor: crosshair");
        svgContainer.onclick = function(event) {
            if (detectDrag(event)) return;
            event.stopPropagation();
            detachListener();
            let parent;
            try {
                parent = gTree.getObject(event.target.id);
                if (parent != null && getRelationship(parent) !== "configurationNode") {
                    if (component.object === "recorder" || getRelationship(parent) !== "line") {
                        const tObject = createTreeObject(component, gTree);
                        tObject.setupChildNode(event.target.id);
                        gTree.insert(tObject);
                        createSvgData([tObject.key]).draw(gViewport);
                    } else {
                        alert("Insertion failed. You clicked on a line. Only meter recorders can be children of lines.");
                    }
                } else {
                    alert("Insertion failed. You clicked on a configuration node.");
                }
            } catch (e) {
                alert("Insertion failed. You click on an invalid object");
            }
        }
    } else {
        const newObjects = [];
        keys.forEach(key => {
            const tObject = createTreeObject(component, gTree);
            tObject.setupChildNode(key);
            gTree.insert(tObject);
            newObjects.push(tObject.key);
        });
        createSvgData(newObjects).draw(gViewport); 
    }
}

// delete this eventually
function insertLineComponent(keys, component) {
    const svgContainer = document.getElementById("svgContainer");
    if (keys.length === 0) {
        alert("Please click on two circles that are not configuration nodes to add this line.");
        const nodes = [];
        svgContainer.setAttribute("style", "cursor: crosshair");
        svgContainer.onclick = function(event) {
            if (detectDrag(event)) return;
            event.stopPropagation();
            try {
                const node = gTree.getObject(event.target.id);
                const relationship = getRelationship(node);
                if (relationship === "childNode" || relationship === "independentNode") {
                    if (!gSelection.hasId(event.target.id)) {
                        gSelection.add(event.target);
                        nodes.push(event.target.id);
                    }
                } else {
                    alert(`You clicked on a "${relationship}" type object. Please click on a circle that is not a configuration node.`);
                    return;
                }
            } catch (e) {
                alert(`You clicked on an invalid object. Please click on a circle that is not a configuration node.`);
                return;
            }
            if (nodes.length === 2) {
                const tObject = createTreeObject(component, gTree);
                tObject.setupLine(nodes[0], nodes[1]);
                gTree.insert(tObject);
                createSvgData([tObject.key]).draw(gViewport)
                gSelection.empty();
                detachListener();
            }
        }
    } else {
        const newObjects = [];
        for (let i = 0; i < keys.length - 1; i++) {
            let tObject = createTreeObject(component, gTree);
            tObject.setupLine(keys[i], keys[i + 1]);
            gTree.insert(tObject);
            newObjects.push(tObject.key);
        }
        createSvgData(newObjects).draw(gViewport);
    }
}

//**************************************************
// Handler functions
//**************************************************

function attachHandlers() {
    componentHandlers();
    fillFeederList(document.getElementById("publicFeederList"), gPublicFeeders, "public");
    fillFeederList(document.getElementById("userFeederList"), gUserFeeders, gCurrentUser);
    fileMenuHandlers();
    editMenuHandlers();
    mouseHandler();
    keyHandler();
    headerHandlers();
}

function headerHandlers() {
    Array.from(document.querySelectorAll("div.headerGroup")).forEach(h => {
        h.addEventListener("click", toggleHeader);
    });
}

function toggleHeader() {
    const heading = this.querySelector(".menuHeading");
    if (heading.classList.contains("expandedHeading")) {
        // Close this header if it was open
        closeHeader.call(this);
    } else {
        // Open this header and close all other headers
        expandHeader.call(this);
        const that = this;
        Array.from(document.querySelectorAll("div.headerGroup")).forEach(div => {
            if (div !== that) {
                closeHeader.call(div);
            }
        });
    }
}

function expandHeader() {
    const heading = this.querySelector(".menuHeading");
    const headingName = heading.textContent.split(" ")[0];
    if (!heading.classList.contains("expandedHeading")) {
        heading.classList.add("expandedHeading");
        heading.innerHTML = headingName + " &#x25B4;";
        this.querySelector("ul").removeAttribute("style");
    }
}

function closeHeader() {
    const heading = this.querySelector(".menuHeading");
    const headingName = heading.textContent.split(" ")[0];
    if (heading.classList.contains("expandedHeading")) {
        heading.classList.remove("expandedHeading");
        heading.innerHTML = headingName + " &#x25BE;";
        this.querySelector("ul").style.display = "none";
    }
}

/** 
 * TODO: add a click listener instead of doing it backwards!
 * Fill menu of "Add" button and add its handler functions.
 */
/* How do I handle component variations within the select? 
*/
function componentHandlers() {
	const ul = document.getElementById("componentList");
    const keys = gComponentManager.getTypes().map(type => type.toLowerCase()).sort();
    keys.forEach(key => {
		const li = document.createElement("li");
        ul.appendChild(li);
        let names = gComponentManager.getNamesOfType(key);
        if (names == null) {
            key = getMixedCaseKey(gComponentManager.components, key);
            names = gComponentManager.getNamesOfType(key);
        }
        if (names.length === 1) {
            li.textContent = key;
            const component = gComponentManager.get(key, names[0]);
            const func = getAddComponentFunction(component);
            li.addEventListener("click", func);
        } else {
            li.textContent = `${key}...`;
            li.addEventListener("click", function() {
                gAddManager.buildSecondaryModal(key);
            });
        }
    });
}

//TODO: move to add manager
function getAddComponentFunction(component) {
    let func;
    const relationship = getRelationship(component);
    switch (relationship) {
        case "independentNode":
        case "configurationNode":
            func = function() {
                if (isValidForAdd(gSelection.getKeys(), component)) {
                    insertIndependentComponent(component);
                }
            }
            //li.addEventListener("click", function() {
            //    if (isValidForAdd(gSelection.getKeys(), component)) {
            //        insertIndependentComponent(component);
            //    }
            //});
            break;
        case "childNode":
            func = function() {
                if (isValidForAdd(gSelection.getKeys(), component)) {
                    insertChildComponent(gSelection.getKeys(), component);
                }
            }
            //li.addEventListener("click", function() {
            //    if (isValidForAdd(gSelection.getKeys(), component)) {
            //        insertChildComponent(gSelection.getKeys(), component);
            //    }
            //});
            break;
        case "line":
            func = function() {
                if (isValidForAdd(gSelection.getKeys(), component)) {
                    insertLineComponent(gSelection.getKeys(), component);
                }
            }
            //li.addEventListener("click", function() {
            //    if (isValidForAdd(gSelection.getKeys(), component)) {
            //        insertLineComponent(gSelection.getKeys(), component);
            //    }
            //});
            break;
    }
    return func;
}

/** 
 * TODO: add unit-tests
 * @param {Element} ul - An html element where the list will be attached.
 * @param {Array} feeders - An array of objects, where each object has properties "model" and "name", or null. 
 * @param {string} owner - Either "public" or the current user.
 */
function fillFeederList(ul, feeders, owner=null) {
    if (!feeders) return;
    const sortedNames = feeders.map(feeder => feeder.name.toLowerCase()).sort();
    sortedNames.forEach(lowercaseName => {
        const feeder = feeders.find(feeder => {
            return feeder.name.toLowerCase() === lowercaseName;
        });
        if (feeder.name != gThisFeederName) {
            const li = document.createElement("li");
            li.classList.add("feederItem");
            li.innerHTML = `<strong>${feeder.name}</strong> from <br>"${feeder.model}"`;
            li.addEventListener("click", function() {
                /* What is the feeder.model for a public feeder? It's "publicFeeders". Do feeders not have their own owner property? No they don't */
                loadFeeder(feeder.name, feeder.model, owner);
            });
            ul.append(li);
        }
    });
}

/**
 * Doesn't need unit tests
 */
function fileMenuHandlers() {
    const menu = document.getElementById("fileMenu");
    if (menu == null) {
        return;
    }
    const items = Array.from(menu.children);
    if (items.length !== 9) {
        throw new Error("Please update this function to ensure the correct handlers are attached");
    }
    items[0].addEventListener("click", function() {
        saveFeeder(gWriteFeeder);
    });
    items[1].addEventListener("click", downloadTextFile);
    items[2].addEventListener("click", renameFeeder);
    items[3].addEventListener("click", () => { toggleElementDisplay("loadModal"); });
    items[4].addEventListener("click", () => { toggleElementDisplay("blankFeederModal"); });
    items[5].addEventListener("click", () => { toggleElementDisplay("milsoftModal"); });
    items[6].addEventListener("click", () => { toggleElementDisplay("gridlabdModal"); });
    items[7].addEventListener("click", () => { toggleElementDisplay("cymeModal"); });
    items[8].addEventListener("click", displayMap);
}

/** 
 * 
 */
function editMenuHandlers() {
    const menu = document.getElementById("editMenu");
    const items = Array.from(menu.children);
    if (items.length != 11) {
        throw new Error("Please update this function to ensure the correct handlers are attached");
    }
    //items[0].addEventListener("click", zoomToFit);
    //items[1].addEventListener("click", zoomReset);
    items[0].addEventListener("click", function() { toggleElementDisplay("amiModal"); });
    items[1].addEventListener("click", function() { toggleElementDisplay("anonymizeModal"); });
    items[2].addEventListener("click", function() {
        loadAttachments(); 
        toggleElementDisplay("attachmentsModal");
    });
    items[3].addEventListener("click", function() { toggleElementDisplay("climateModal"); });
    items[4].addEventListener("click", function() {
        toggleElementDisplay("findModal"); 
        document.getElementById("searchInput").focus(); 
    });
    items[5].addEventListener("click", function() {
        gAddManager.setupTargetSelect();
        toggleElementDisplay("massAddModal");
    });
    items[6].addEventListener("click", function() {
        updateAttachTargets("massEditTargetSelect", gTree.tree);
        toggleElementDisplay("massEditModal");
    });
    items[7].addEventListener("click", function() { toggleElementDisplay("scadaModal"); });
    items[8].addEventListener("click", convertStaticLoadsIntoHouses);
    items[9].addEventListener("click", function() {
        gOpacityManager.update();
        gOpacityManager.buildOpacityModal();
    });
    items[10].addEventListener("click", () => { toggleElementDisplay("colorModal"); });
}

function mouseHandler() {
    const svgContainerWrapper = document.getElementById("svgContainerWrapper");
    svgContainerWrapper.addEventListener("click", function(event) {
        handleSelection(event);
    });
    svgContainerWrapper.addEventListener("mousedown", function(event) {
        gDownX = event.clientX;
    });
    svgContainerWrapper.addEventListener("mouseup", function(event) {
        gDownY = event.clientY;
    });
    svgContainerWrapper.addEventListener("click", function() {
        Array.from(document.querySelectorAll("div.headerGroup")).forEach(div => {
            closeHeader.call(div);
        });
    });
    document.getElementById("scaleButton").addEventListener("click", function() {
        const userScale = prompt("Scale line thickness by this multiple:", gScaleLevel);
        if (isNumberString(userScale)) {
            scaleTo(parseFloat(userScale));
        }
    });
}

function keyHandler() {
    document.body.addEventListener("keydown", function(event) {
        if (event.target.tagName.toLowerCase() !== "input") {
            switch (event.key) {
                case "m":
                    destroyTables(["descriptionTables"]);
                    attachMoveListener(gSelection.getKeys());
                    break;
                case "-":
                    panZoom.zoomOut();
                    break;
                case "=":
                    panZoom.zoomIn();
                    break;
                case "Escape":
                    const svgContainer = document.getElementById("svgContainer");
                    if (svgContainer.onclick != null) {
                        alert("Operation cancelled");
                        detachListener();
                    }
                    break;
            }
        }
    });
}

/** 
 * TODO: add unit tests
 * If an element isn't displayed, set it's inline display value to the default browser value.
 * If the element is displayed, then hide it.
 */
function toggleElementDisplay(id) {
    const element = document.getElementById(id);
    if (element.style.display === "none") {
        element.removeAttribute("style");
    } else {
        element.style.display = "none";
        if (id === "findModal") {
            return;
        }
        // When we hide a modal, set any of the text fields to empty. Actually I don't always want this.
        const queryString = `#${id} input[type=text]`;
        document.querySelectorAll(queryString).forEach(input => {
            input.value = "";
        });
    }
}

//**************************************************
// Edit menu interface
//**************************************************
/*
Don't touch existing houses or their loads
Don't ever replace regular load objects
1) Delete triplex nodes (have NO parent) and replace them with houses that have randomly generated loads
2) Replace triplex loads (have parent) with houses that have randomly generated loads

triplex_loads AND triplex_nodes CAN have parents, but triplex_node usually won't
triplex_load always has a parent

-There are no files with both triplex loads and triplex nodes.
-File with triplex loads: ./omf/data/Model/public/Demo gridlabMulti scadaCalibration/Calibrated Feeder.omd
-File with triplex nodes: 
    ./omf/data/Model/public/Demo gridlabMulti scadaCalibration/Uncalibrated Feeder.omd
    ./omf/data/Model/public/Demo superModel/superModel Today.omd
*/
function convertStaticLoadsIntoHouses() {
    const keys = Object.keys(gTree.tree).filter(key => {
        const object = gTree.getObject(key).object;
        return object === "triplex_load" || object === "triplex_node";
    });
    if (keys.length === 0) {
        alert(`This data has no triplex load or triplex node objects that can be converted into houses.`);
        return;
    }
    const pm = new ProgressModal(`Converting every triplex load and/or triplex node into a house with children. This could take a few seconds.`);
    pm.show();
    setTimeout(function() {
        keys.forEach(key => { replaceLoadOrNodeWithHouse(key); });
        createSvgData(keys).draw(gViewport);
        pm.hide();
    }, 10);
}

/**
 * Keep: longitude, latitude, parent (if it doesn't have it, set it to null)
 * Change: name, object 
 * Delete: all of the old properties, old name in treeMap.name
 * Insert: all of the properties of house, new name in treeMap.name
 * Edit: 'parent' attribute of children (if any), 'from/to' attribute of lines (if any)
 * Don't touch: TreeMap is fine because it uses keys
 */
function replaceLoadOrNodeWithHouse(key) {
    const oldLoad = gTree.getObject(key);
    const house = deepCopy(gComponentManager.get("house", "R1_SingleFamilyHome_1990-2005"));
    house.longitude = oldLoad.longitude;
    house.latitude = oldLoad.latitude;
    if (oldLoad.parent == null) {
        delete house.parent;
    } else {
        house.parent = oldLoad.parent;
    }
    house.name = "house" + key; // might need to change this
    const children = gTree.treeMap.getChildKeys(key);
    if (children != null) children.forEach(key => { gTree.getObject(key).parent = house.name; });
    const lines = gTree.treeMap.getLineKeys(key);
    if (lines != null) {
        lines.forEach(key => {
            const line = gTree.getObject(key);
            if (line.to === oldLoad.name) {
                line.to = house.name;
            } else if (line.from === oldLoad.name) {
                line.from = house.name;
            }
        });
    }
    gTree.treeMap.remove([key]);
    gTree.tree[key] = house;
    gTree.treeMap.add(key);
    addLoadsToHouse(key);
}

function addLoadsToHouse(key) {
    // Insert water heater
    let tObject = createTreeObject(gComponentManager.get("waterheater", "waterheater"), gTree);
    tObject.setupChildNode(key)
    gTree.insert(tObject);
    // Insert responsive ZIPload
    tObject = createTreeObject(gComponentManager.get("ZIPload", "ZIPload"), gTree);
    tObject.setupChildNode(key);
    let responsiveBasePower = Math.random();
    responsiveBasePower = responsiveBasePower < .5 ? responsiveBasePower + .5 : responsiveBasePower;
    tObject.data["base_power"] = `responsive_loads*${responsiveBasePower}`;
    gTree.insert(tObject);
    // Insert unresponsive ZIPload
    tObject = createTreeObject(gComponentManager.get("ZIPload", "ZIPload"), gTree);
    tObject.setupChildNode(key);
    let unresponsiveBasePower = Math.random() + 1.5;
    tObject.data["base_power"] = `unresponsive_loads*${unresponsiveBasePower}`;
    gTree.insert(tObject);
}

/*
function massAdd() {

    // Don't need to check if the component is a child node, since that is done elsewhere
	const componentName = document.getElementById("componentSelect").value;
    // Don't need to check if the attachObject is a configuration node, since that is done elsewhere. This is built correctly
    const attachObject = document.getElementById("massAddTargetSelect").value;
    
    if ()

    if ({} === "recorder" || {} !== "line") {
    //if (gComponents[componentName].object === "recorder" || getRelationship(gComponents[attachObject]) !== "line") {
        const newObjects = [];
        const pm = new ProgressModal(`Adding a "${componentName}" object to every "${attachObject}" object. This could take a few seconds.`);
        pm.show();
        percent = parseFloat(percent);
        setTimeout(() => {
            Object.keys(gTree.tree).forEach(key => {
                if (gTree.getObject(key).object === attachObject && Math.random() < percent) {
                    //const tObject = createTreeObject(gComponents[componentName], gTree);
                    const tObject = {};
                    tObject.setupChildNode(key);
                    gTree.insert(tObject);
                    newObjects.push(tObject.key);
                }
            });
            createSvgData(newObjects).draw(gViewport);
            pm.hide();
            alert(`${newObjects.length} "${componentName}" objects added to the feeder`);
            toggleElementDisplay("massAddModal");
        }, 10);

    } else {
        alert("Mass add failed. Only meter recorder objects can be added as children of lines.");
    }
}
*/

/**
 * The user could have added a new component to the graph that they now wish to attach to. That's why I have to update the attach targets.
 */
/**
 * Can you mass edit configuration nodes? Don't want to edit timezone objects. Disqualify all objects with no "object" property. Climate objects have "climate"
 * as object, but there is no "climate" component. There is no reason why we can't mass edit configuration objects. I'm only editing existing objects, so it
 * has nothing to with components.
 */
function updateAttachTargets(id, tree) {
    document.getElementById(id).innerHTML = "";
	const attachList = [];
	for (let key in tree) {
        if (tree[key].object != null && !attachList.includes(tree[key].object) ) {
            attachList.push(tree[key].object);
        }
    }
    attachList.map(objectType => objectType.toLowerCase()).sort().forEach(lowercaseObject => {
        let key;
        try {
            key = gComponentManager.hasOwnProperty(lowercaseObject) ? lowercaseObject : getMixedCaseKey(gComponentManager.components, lowercaseObject); 
        } catch (e) {
            key = lowercaseObject;
        }
        document.getElementById(id).innerHTML += `<option value=${key}>${key}</option>`;
    });
}

// keep this, rename it
function getKeysOfObjectsWithoutNumericValues(keys, attributeKey) {
    const tree = gTree.tree;
    const invalidKeys = keys.filter(key => {
        let value = tree[key][attributeKey];
        if (typeof value !== "string") {
            value = String(tree[key][attributeKey]);
        }
        if (!isNumberString(value)) {
            return true;
        }
    });
    return invalidKeys;
}

//only toggle upon successful completion of operation
function massEdit() {
    let operation = document.querySelector("input[name=attributeOperation]:checked");
    if (operation == null) {
        alert("Please select an operation with radio buttons on the 'Mass Edit' menu.");
        return;
    }
    operation = operation.value;
    const objectType = document.getElementById("massEditTargetSelect").value;
    const keys = Object.keys(gTree.tree).filter(key => gTree.getObject(key).object === objectType)
    if (operation === "addAttribute") {
        massAddAttribute(keys, objectType);
        return;
    }
    const attributeKey = document.getElementById("massEditAttribute").value.trim();
    //Make sure the attribute exists
    let invalidKeys = [];
    for (let key of keys) {
        if (gTree.getObject(key)[attributeKey] === undefined) {
            invalidKeys.push(key);
        }
    }
    if (invalidKeys.length > 0) {
        alert(`Mass edit failed. The attribute "${attributeKey}" is missing from one or more objects:\nObject names: "${invalidKeys.map(key => gTree.getObject(key).name).join(", ")}".\nObject keys: "${invalidKeys.join(", ")}".`);
        return;
    }
    //Make sure the attribute exists
    switch (operation) {
        case "addTo":
        case "multiplyBy":
        case "change":
            if (nonModifiableProperties.includes(attributeKey)) {
                alert(`Mass edit failed. The following properties cannot be modified: "${nonModifiableProperties.join(", ")}".`);
                return;
            }
            if (operation === "addTo" || operation === "multiplyBy") {
                invalidKeys = getKeysOfObjectsWithoutNumericValues(keys, attributeKey);
                if (invalidKeys.length > 0) {
                    alert(`Mass edit failed. The attribute "${attributeKey}" does not have a numeric value in the following objects: \nObject names: "${invalidKeys.map(key => gTree.getObject(key).name).join(", ")}".\nObject keys: "${invalidKeys.join(", ")}".`);
                    return;
                }
                if (operation === "addTo") {
                    massAddition(keys, attributeKey, objectType);
                } else if (operation === "multiplyBy") {
                    massMultiplication(keys, attributeKey, objectType);
                }
            } else if (operation === "change") {
                massChange(keys, attributeKey, objectType);
            }
            break;
        case "delete":
            if (nonDeletableProperties.includes(attributeKey)) {
                alert(`Mass edit failed. The properties "${nonDeletableProperties.join(", ")}" cannot be deleted.`);
                return;
            }
            for (let key of keys) {
                delete gTree.getObject(key)[attributeKey];
            }
            alert(`${keys.length} ${objectType} objects had the "${attributeKey}" attribute deleted.`);
            toggleElementDisplay("massEditModal");
            createSvgData(Object.keys(gTree.tree)).quickDraw(gViewport);
            break;
    }
}

/* For the recorder special case, I need to know if the object under consideration is a recorder or not */
/**
 * @param {string} name - the name of the object that is being considered as a parent.
 * @param {string} object - the type of the object that needs the parent. Only matters for the "recorder" special case
 */
function isValidParentName(name, object) {
    try {
        const relationship = getRelationship(gTree.getObject(gTree.treeMap.getKey(name)));
        if (relationship === "configurationNode"  || (relationship === "line" && object !== "recorder")) return false; 
    } catch (e) {
        return false;
    }
    return true;
}

function isValidToOrFromNode(name) {
    const invalidTypes = ["configurationNode", "line"];
    try {
        const relationship = getRelationship(gTree.getObject(gTree.treeMap.getKey(name)));
        if (invalidTypes.includes(relationship)) {
            return false;
        }
    } catch (e) {
        return false;
    }
    return true;
}

function massAddAttribute(keys, objectType) {
    const newKey = document.getElementById("newAttributeKey").value.trim();
    if (newKey === "") {
        alert(`Mass edit failed. Please enter a name for the attribute you want to add.`);
        return;
    }
    if (nonModifiableProperties.includes(newKey)) {
        alert(`Mass edit failed. The properties "${nonModifiableProperties.join(", ")}" cannot be overwritten.`);
        return;
    }
    if (newKey === "to" || newKey === "from" || newKey === "parent") {
        alert(`Mass edit failed. Cannot add the attributes 'to', 'from', or 'parent'.`);
        return;
    }
    const newValue = document.getElementById("newAttributeValue").value;
    for (let key of keys) {
        gTree.getObject(key)[newKey] = newValue;
    }
    alert(`${keys.length} ${objectType} objects had the "${newKey}" attribute added.`);
    toggleElementDisplay("massEditModal");
    createSvgData(Object.keys(gTree.tree)).quickDraw(gViewport);
}

/**
 * @param {keys} - the keys of the objects to be changed
 * @param {attributeKey} - the attribute that is being changed
 * @param {objectType} - The "object" property of every object that is being changed
 */
function massChange(keys, attributeKey, objectType) {
    let newValue = document.getElementById("changeValue").value.trim();
    switch (attributeKey) {
        case "parent":
            if (!isValidParentName(newValue, objectType)) {
                alert(`Mass change failed. The name "${newValue}" is not a valid parent name.`);
                return;
            }
        case "to":
        case "from":
            if (!isValidToOrFromNode(newValue)) {
                alert(`Mass change failed. The name "${newValue}" is not a valid name for a source or target of a line.`);
                return;
            }
    }
    if (["longitude", "latitude"].includes(attributeKey)) {
        if (!isNumberString(newValue)) {
            alert(`Please enter a valid number to edit "latitude" or "longitude".`);
            return;
        } else {
            newValue = parseFloat(newValue);
        }
    }
    const treeObjectCopies = [];
    keys.forEach(key => {
        treeObjectCopies.push(createTreeObject(key, gTree));
    });
    createSvgData(keys).delete(gViewport);
    let count = keys.length;
    const unedited = [];
    treeObjectCopies.forEach(tObject => {
        if (attributeKey === "to") {
            if (tObject.data.from !== newValue) {
                tObject.data[attributeKey] = newValue;
            } else {
                count--;
                unedited.push(tObject.key);
            }
        } else if (attributeKey === "from") { 
            if (tObject.data.to !== newValue) {
                tObject.data[attributeKey] = newValue;
            } else {
                count--; 
                unedited.push(tObject.key);
            }
        } else {
            tObject.data[attributeKey] = newValue;
        }
        gTree.insert(tObject);
    });
    let msg = `${count} ${objectType} objects had the "${attributeKey}" attribute changed.`;
    msg = unedited.length === 0 ? msg : msg + ` The following objects did not have their "${attributeKey}" attribute changed: "${unedited.map(key => gTree.getObject(key).name).join(", ")}".`
    alert(msg);
    toggleElementDisplay("massEditModal");
    createSvgData(Object.keys(gTree.tree)).quickDraw(gViewport);
}

function massAddition(keys, attributeKey, objectType) {
    let operand = document.getElementById("addToValue").value.trim();
    if (!isNumberString(operand)) {
        alert("Mass edit failed. Please enter a valid number if you choose 'Add to Value'.");
        return;
    }
    operand = parseFloat(operand);
    for (let key of keys) {
        gTree.getObject(key)[attributeKey] = parseFloat(gTree.getObject(key)[attributeKey]) + operand;
    }
    alert(`${keys.length} ${objectType} objects had their "${attributeKey}" attribute edited.`);
    toggleElementDisplay("massEditModal");
    createSvgData(Object.keys(gTree.tree)).quickDraw(gViewport);
}

function massMultiplication(keys, attributeKey, objectType) {
    let multiplyOperand = document.getElementById("multiplyValue").value.trim();
    let addOperand = document.getElementById("andAddValue").value.trim() === "" ? "0" : document.getElementById("andAddValue").value.trim();
    if (!isNumberString(multiplyOperand) || !isNumberString(addOperand)) {
        alert("Mass edit failed. Please enter valid operands if you choose 'Multiply attribute by'.");
        return;
    }
    multiplyOperand = parseFloat(multiplyOperand);
    addOperand = parseFloat(addOperand);
    for (let key of keys) {
        gTree.getObject(key)[attributeKey] = parseFloat(gTree.getObject(key)[attributeKey]) * multiplyOperand + addOperand;
    }
    alert(`${keys.length} ${objectType} objects had their "${attributeKey}" attribute edited.`);
    toggleElementDisplay("massEditModal");
    createSvgData(Object.keys(gTree.tree)).quickDraw(gViewport);
}

function loadAttachments() {
    const selectElement = document.getElementById("attachmentSelect");
    selectElement.innerHTML = "";
	for (let key in gWriteFeeder.attachments) {
        selectElement.innerHTML += `<option value=${key}>${key}</option>`;
    }
}

function editAttachment() {
	//document.body.style.cursor = "wait"
	//setTimeout(function(){
		toggleElementDisplay("editAttachmentModal");
		let name =  document.getElementById("attachmentSelect").value; //get the select. attachmentsList = attachmentSelect
		document.getElementById("attachmentTd").innerHTML = name;  //get the td. attachmentSelect = attachmentTd
		document.getElementById("editAttachmentBox").innerHTML = gWriteFeeder.attachments[name];
		//document.body.style.cursor = "auto"
	//}, 100);
}

function saveAttachment() {
	let name = document.getElementById("attachmentSelect").value;
	gWriteFeeder.attachments[name] = document.getElementById("editAttachmentBox").value;
}

//**************************************************
// File menu interface
//**************************************************
{% if showFileMenu %}

/** 
 * Used to save the new changes or undo an operation by resaving the old changes.
 */ 
function saveFeeder(feeder) {
    const formData = new FormData();
    formData.set("feederObjectJson", JSON.stringify(feeder));
    const postRequest = $.ajax({
        type: "POST",
        url: `/saveFeeder/${gThisOwner}/${gThisModelName}/${gThisFeederName}`,
        data: formData,
        processData: false,
        contentType: false,
    });
    let cancelled = false;
    let progressModal;
    if (feeder === gReadFeeder) {
        progressModal = new ProgressModal("Cancelling the previous operation...", "", false);
        postRequest.done(function() {
            progressModal.hide();
            alert("Success. Previous operation was canceled");
        });
    } else if (feeder === gWriteFeeder) {
        progressModal = new ProgressModal("Saving changes to your file...", "You have canceled the save.", true);
        progressModal.button.addEventListener("click", function() {
            cancelled = true;
            progressModal.header.textContent = progressModal.cancelMessage;
            progressModal.button.style.display = "none";
        });
        postRequest.done(function() {
            if (cancelled) {
                saveFeeder(gReadFeeder);
            } else {
                progressModal.hide();
                alert("Success. Your data was saved.");
                // Need to do this to make sure rename doesn't break if the user saves and remains on the page.
                gReadFeeder = deepCopy(gWriteFeeder);
            }
        });
    }
    progressModal.show();
}

/**
 * TODO: This function has a lot of problems because of how the web routes are written.
 */
/**
 * serverFeederName: The name of the feeder I want to load, e.g. "ABEC Columbia"
 * serverModelName: Either "publicFeeders" or something like "Simple Market System Indy Solar"
 * 
 * @param {string} owner - either "public" or the current user.
 */
async function loadFeeder(serverFeederName, serverModelName, owner) {
    let submitForm = false;
    await $.ajax({
        // I need to check if a user's feeder still exists.
        url: `/uniqObjName/Feeder/${owner}/${serverFeederName}/${serverModelName}`//good
    }).done(function(data) {
        if (data.exists) {
            submitForm = true;
        } else {
            alert("This feeder no longer exists. Please refresh the page, or select another feeder.");
        }
    });
    if (submitForm === false) {
        return;
    }
    let formData = new FormData();
    formData.set("referrer", "distribution");
    const progressModal = new ProgressModal("Loading feeder from server...", "You have canceled loading the feeder.", true);
    let cancelled = false;
    progressModal.button.addEventListener("click", function() {
        cancelled = true;
        progressModal.header.textContent = progressModal.cancelMessage;
        progressModal.button.style.display = "none";
    });
    progressModal.show();
    $.ajax({
        type: "POST",
        // {owner} is correct. {owner} is either "public" to load from public feeders or <current user> to load from the users feeders. {gThisOwner} is correct because I am overwriting THIS feeder file, which is either publicly owned or owned by the current user. {gThisOwner} cannot be {gCurrentUser} because then I can't overwrite public files as the admin.
        url: `/loadFeeder/${serverFeederName}/${serverModelName}/${gThisModelName}/${gThisFeederNum}/${owner}/${gThisOwner}`,
        data: formData,
        processData: false,
        contentType: false,
    }).done(function() {
        if (cancelled) {
            saveFeeder(gReadFeeder);
        } else {
            reloadWrapper();
        }
    });
}

/** 
 * TODO: add back ability to cancel these operations
 */
async function submitForm({formId, pollUrl, inputId}) {
    let submitForm = true;
    if (inputId !== undefined) {
        // inputId was defined, therefore we need to check the file name on the server before submitting the form
        submitForm = false;
        const fileName = document.getElementById(inputId).value;
        // Check if the file exists, using the user-provided fileName
        await $.ajax({
            url: `/uniqObjName/Feeder/${gThisOwner}/${fileName}/${gThisModelName}`//good
        }).done(function(data) {
            //console.log(data);
            if (data.exists === true) {
                alert(`You already have a feeder named "${fileName}". Please choose a different name.`);
            } else {
                // The file does not exist. Submit the form.
                submitForm = true;
            }
        });
    }
    if (submitForm === false) {
        return;
    }
    const form = document.getElementById(formId);
    const formData = new FormData(form);
    const submitModal = new ProgressModal("Submitting your file...", "", false);
    submitModal.show();
    // Submit the form to the server with an ajax request
    const formRequest = $.ajax({
        type: "POST",
        url: form.action,
        data: formData,
        processData: false,
        contentType: false,
    });
    if (pollUrl === undefined) {
        // We don't want to poll the server. Just reload the page.
        formRequest.done(function() {
            reloadWrapper();
        });
    } else {
        formRequest.done(function(data) {
            let cancelled = false;
            const pollModal = new ProgressModal("Converting your file...", "You canceled the file conversion.", true);
            pollModal.button.addEventListener("click", function() {
                cancelled = true;
                pollModal.header.textContent = pollModal.cancelMessage;
                pollModal.button.style.display = "none";
            });
            pollModal.show();
            // Poll the server
            const intervalId = setInterval(function() {
                $.ajax({
                    url: pollUrl
                }).done(function(data) {
                    if (cancelled) {
                        clearInterval(intervalId);
                        pollModal.hide();
                        alert("You cancelled the operation");
                        saveFeeder(gReadFeeder);
                    }
                    if (data.exists === true) {
                        //processing is ongoing 
                    } else if (data.exists === false) {
                        // The pollModal isn"t hidden before the alert happens. This has nothing to do with the reload wrapper.
                        clearInterval(intervalId);
                        pollModal.hide();
                        alert("Conversion complete");
                        reloadWrapper();
                    } else if (data === "milError") {
                        clearInterval(intervalId);
                        pollModal.hide()
                        alert("The .std and .seq files used are incorrectly formatted.");
                        //TODO: submit the gReadFeeder
                    } else if (data === "glmError") {
                        clearInterval(intervalId);
                        pollModal.hide()
                        alert("The .glm file used is incorrectly formatted.");
                        //TODO: submit the gReadFeeder
                    } else {
                        console.log(data);
                        clearInterval(intervalId);
                        pollModal.hide()
                        alert("There was a problem. Operation was cancelled");
                    }
                });
            }, 5000);
        });
    }
}

async function renameFeeder() {
	if (JSON.stringify(gReadFeeder) !== JSON.stringify(gWriteFeeder)){
		alert("You have unsaved changes. Please save the feeder before proceeding.")
	} else {
		let newName = prompt("Rename the feeder to", `${gThisFeederName}`);
		while (! /^[\w\s]+$/.test(newName) || /^\s+$/.test(newName)) {
			newName = prompt("Only letters, digits and underscore are allowed.\nPlease enter a different name", `${gThisFeederName}`);
		}
		if (newName){
            let submitRequest = false;
            await $.ajax({
                url: `/uniqObjName/Feeder/${gThisOwner}/${newName}/${gThisModelName}`//good because of course I am renaming THIS feeder file
            }).done(function(data) {
                if (data.exists) {
                    alert(`You already have a feeder named "${newName}". Please choose a different name.`);
                } else {
                    submitRequest = true;
                }
            });
            if (submitRequest === false) {
                return;
            }
            $.ajax({
                url: `/renameFeeder/${gThisOwner}/${gThisModelName}/${gThisFeederName}/${newName}/${gThisFeederNum}`
            }).done(function() {
                gThisFeederName = newName;
                document.getElementById("menuLeft").querySelector("h4").textContent = newName;
                alert("Feeder file was successfully renamed.");
            })
		}
	} 
}

function displayMap(){
    window.open(`/displayMap/${gThisOwner}/${gThisModelName}/${gThisFeederNum}`, '_blank');
}

{% endif %}

/** This is done for testing reasons.
 */
function reloadWrapper() {
    /* Force the client to always request new files from the server without using the browser cache. 
    */
    window.location.reload(true);
}

function ProgressModal(message, cancelMessage, showButton) {
    this.self = document.getElementById("progressModal");
    this.button = this.self.getElementsByTagName("button")[0];
    this.header = this.self.getElementsByTagName("h2")[0];
    this.message = message;
    this.cancelMessage = cancelMessage;
    this.showButton = showButton;
}

ProgressModal.prototype.show = function() {
    this.header.textContent = this.message;
    this.self.removeAttribute("style");
    if (this.showButton) {
        this.button.removeAttribute("style");
    } else {
        this.button.style.display = "none";
    }
}

ProgressModal.prototype.hide = function() {
    this.self.style.display = "none";
}


/**
 * Return true if this TreeWrapper can be moved, otherwise return false;
 * @return {boolean}
 */
function isValidForMove(objects) {
    if (objects.length === 0) {
        alert(`Please select at least one circle to move.`);
        return false
    }
    const names = getNamesOfTypes(objects, "line");
    if (names.length !== 0) {
        alert(`Lines cannot be moved. Please unselect the following lines: ${names.join(", ")}.`);
        return false
    }
    return true
}

/**
 * This cannot be used directly for placing new components, because this function assumes that all objects
 * that are being moved already exist in the data. Its only acceptable for this function to be canceled
 * if the objects have already all been drawn.
 * @param {Array} keys
 */
function attachMoveListener(keys, tBody=null, tObject=null) {
    const objects = [];
    keys.forEach(key => {
        objects.push(gTree.getObject(key));
    });
    if (isValidForMove(objects)) {
        const element = document.getElementById("svgContainer");
        element.setAttribute("style", "cursor: crosshair");
        const moveNodes = getMoveNodesFunction(objects, tBody, tObject);
        element.onclick = function(event) {
            moveNodes(event);
            createSvgData(keys).draw(gViewport);
        }
    }
}

/**
 * Translate the 'longitude' and 'latitude' properties of all nodes in this TreeWrapper according
 * to the arguments.
 * 
 * These x, y coordinate arguments are relative to the viewport, which means they have a minimum
 * value of 0 and that the gMinLon and gOffsetY must be added to them before they are real 
 * coordinates to be stored in the tree.
 * @param {number} x - an x coordinate relative to the viewport, usually created with a click on the screen.
 * @param {number} y - a y coordinate relative to the viewport, usually created with a click on the screen.
 */
function move(objects, {x, y}) {
    let offsetX = gMinLon, offsetY = gMaxLat, scaleFactor = gDrawScaleFactor;
    if (arguments[2] != null) {// needed for testing
        offsetX = arguments[2].offsetX;
        offsetY = arguments[2].offsetY;
        scaleFactor = arguments[2].scaleFactor;
    }
    const nodes = [];
    let avgLon = 0;
    let avgLat = 0;
    objects.forEach(obj => {
        if (getRelationship(obj) !== "line") {
            nodes.push(obj);
            avgLon += obj.longitude;
            avgLat += obj.latitude;
        }
    });
    if (nodes.length === 0) return;
    avgLon /= nodes.length;
    avgLat /= nodes.length;
    nodes.forEach(node => {
        node.longitude = node.longitude - avgLon + offsetX + x/scaleFactor;
        //node.latitude = node.latitude - avgLat + offsetY + y/scaleFactor;
        node.latitude = node.latitude - avgLat + offsetY - y/scaleFactor;
    });
}

/**
 * TODO: do some sort of pre-scan to find an empty square in the graph to insert the configuration objects.
 * Parse this TreeWrapper.tree and insert longitude and latitude properties if a non-line type object does not contain them.
 * @param {number} initX - the longitude of the top left corner of the square.
 * @param {number} initY - the latitude of the top left corner of the square.
 * @param {number} spacing - how far apart the nodes should be spaced from one another
 * 
 * @param {Array} objects - the objects that need coordinates
 */
function insertCoordinates(objects, initX, initY, spacing) {
    let gen = getCoordinates(initX, initY, spacing);
    objects.forEach(obj => {
        if (getRelationship(obj) !== "line" && (obj.longitude == null || obj.latitude == null)) {
            let coords = gen.next().value;
            obj.longitude = coords.longitude;
            obj.latitude = coords.latitude;
        }
    });
}

/**
 * TODO: rename this function or delete it
 * @param {Object[]} objects
 * @param {string[]} types
 * @return string[]
 */
function getNamesOfTypes(objects, ...types) {
    return objects.filter(obj => {
        const relationship = getRelationship(obj);
        return types.includes(relationship);
    }).map(obj => obj.name !== undefined ? obj.name : Object.values(obj)[0]);
}

/**
 * good. No unit tests need.
 * @param {Object[]} selection
 * @param {Object} component
 * @return {boolean}
 */
function isValidForAdd(keys, component) {
    const selection = keys.map(key => gTree.getObject(key));
    const relationship = getRelationship(component);
    const configNames = getNamesOfTypes(selection, "configurationNode");
    const lineNames = getNamesOfTypes(selection, "line");
    const errorMsgStart = `This component "${component.object}" `;
    const errorMsgConfig = `Please unselect the following configuration nodes: "${configNames.join(", ")}" before trying to add this component again.`;
    const errorMsgLine = `Please unselect the following lines: "${lineNames.join(", ")}" before trying to add this component again.`;
    switch (relationship) {
        case "independentNode":
        case "configurationNode":
            if (selection.length !== 0) {
                alert(errorMsgStart + "cannot be inserted using other objects. Please unselect all objects before adding this component again.");
                return false;
            }
            break;
        case "childNode":
            if (configNames.length > 0) {
                alert(errorMsgStart + "cannot be added as a child of a configuration node. " + errorMsgConfig);
                return false;
            }
            if (lineNames.length > 0 && component.object !== "recorder") {
                alert(errorMsgStart + "cannot be added as a child of a line. " + errorMsgLine);
                return false;
            }
            break;
        case "line":
            if (selection.length === 1) {
                alert("Please select at least 2 circles to add this line.");
                return false;
            } else if (configNames.length > 0) {
                alert(errorMsgStart + "cannot be connected to configuration nodes. " + errorMsgConfig);
                return false;
            } else if (lineNames.length > 0) {
                alert(errorMsgStart  + "cannot be connected to lines. " + errorMsgLine);
                return false;
            } 
            /* If any nodes in the selection already have a line between them, fail. special case will require refactor of this method */
            for (let i = 0; i < keys.length; i++) {
                const pairedNodes = gTree.getPairedNodeKeys(keys[i]);
                if (pairedNodes != null) {
                    let previouslyConnectedNodes = pairedNodes.filter(key => keys.includes(key));
                    if (previouslyConnectedNodes.length > 0) {
                        alert(`Insertion failed. The node named "${gTree.getObject(keys[i]).name}" is already connected to nodes "${previouslyConnectedNodes.map(key => gTree.getObject(key).name).join(", ")}".`);
                        return false;
                    }
                }
            }
            break;
    }
    return true;
}

//**************************************************
// Public utility functions
//**************************************************

/**
 * There are 4 relationships of objects: lines, child nodes, independent nodes, and configuration nodes.
 * The line between a parent and child doesn't exist in the data itself, it's merely shown in the svg
 * to demonstrate the relationship between two nodes.
 */

/**
 * Return true if the string is a valid number, otherwise return false. Thanks stackoverflow.
 * @param {string}
 * @return {boolean}
 */
function isNumberString(str) {
    if (typeof str !== "string" || /\s/.test(str)) {
        //console.error(`Expected "${str}" to be a string without whitespace, but it was not.`);
        return false;
    } 
    if (isNaN(str) || isNaN(parseFloat(str))) {
        //console.error(`Expected "${str}" to be a string that could be parsed to a number, but it was not.`);
        return false;
    }
    return true;
}

/**
 * Return the relationship of the object with regard to this interface.
 * 
 * This function is important because the order in which an object is checked matters. For example, an object could be both a 'line' relationship and a 'configurationNode' relationship, but the 'line' relationship should take precedence over the 'configurationNode' relationship, so 'line' should be returned.
 * @param {Object} obj
 * @return {string}
 */
function getRelationship(obj) {
    if (isLine(obj)) {
        return "line";
    } else if (isConfigurationNode(obj)) {
        return "configurationNode";
    } else if (isChildNode(obj)) {
        return "childNode";
    }
    return "independentNode"
}

/** 
 * Return an object that is a copy of the argument object.
 * 
 * @param {Object} oldObject - the object to copy.
 * @return {Object} - a copy of the oldObject.
 */
 function deepCopy(oldObject) {
    if (Object.getPrototypeOf(oldObject) !== Object.prototype) {
        throw new Error("This function cannot be used to copy objects that are not plain JavaScript objects.");
    }
    const properties = Object.getOwnPropertyNames(oldObject);
    const keys = Object.keys(oldObject);
    for (let key of keys) {
        if (typeof(oldObject[key]) === "function") {
            throw new Error("This function cannot be used to copy objects with methods.");
        } else if (oldObject[key] === undefined) {
            // JSON.stringify will not copy a property of an object with an undefined value.
            throw new Error("JSON.stringify silently ignores properties with undefined values, so this function cannot handle undefined values.");
        }
    }
    return JSON.parse(JSON.stringify(oldObject));
}

/**
 * TODO: add unit tests, refactor to allow testing any tree
 * @return {Array} - contains all of the object types that exist in the graph.
 */
function getExistingRelationships() {
    const relationships = {};
    Object.values(gTree.tree).forEach(obj => {
        const type = obj.object;
        const relationship = getRelationship(obj);
        if (type != null) {
            if (relationships[relationship] == null) relationships[relationship] = [];
            if (!relationships[relationship].includes(type)) relationships[relationship].push(type);
        }
    });
    return relationships;
}

/**
 * Doesn't need unit tests.
 */
function enableDrag(table) {
    if (window.jQuery != null) {
        table.style.left = "50vw";
        $(table).draggable();
    }
}

//not optimal, but it works
function getMixedCaseKey(object, lowercaseKey) {
    const keys = Object.keys(object);
    for (let i = 0; i < keys.length; i++) {
        if (keys[i].toLowerCase() === lowercaseKey) {
            return keys[i];
        }
    }
    throw new Error(`key "${lowercaseKey}" not found in object.`);
}

/**
 * Return the minimum and maximum values inside of an object or an object of objects.
 * 
 * @param {Object} object - the object within which to find the minimum and maximum values.
 * @param {Object} objectContainer - an object which has other objects as properties.
 * @param {Array} properties - the properties to scan for min and max values across all objects in the objectContainer.
 * @return {Object}
 */
function getMinMax({object=null, objectContainer=null, properties=null}) {
    if (object != null) {
        let min, max;
        const values = Object.values(object);
        values.forEach(val => {
            val = parseFloat(val);
            if (!isNaN(val)) {
                if (min == null) {
                    min = val;
                    max = val;
                } else {
                    if (val < min) min = val;
                    if (val > max) max = val;
                }
            }
        });
        return {
            min: min,
            max: max
        }
    }
    if (objectContainer != null && properties != null) {
        const minMax = {};
        const objects = Object.values(objectContainer);
        properties.forEach(prop => minMax[prop] = {});
        objects.forEach(obj => {
            properties.forEach(prop => {
                const propVal = parseFloat(obj[prop]);
                if (!isNaN(propVal)) {
                    if (minMax[prop].min == null) {
                        minMax[prop].min = propVal;
                        minMax[prop].max = propVal;
                    } else {
                        if (propVal < minMax[prop].min) minMax[prop].min = propVal;
                        if (propVal > minMax[prop].max) minMax[prop].max = propVal;
                    }
                }
            });
        });
        return minMax;
    }
}

/**
 * Doesn't need unit tests.
 * @param {HTMLElement} e
 */
 function getStyleAttribute(e) {
    const tagName = e.tagName.toLowerCase();
    return tagName === "circle" ? "fill" : "stroke";
}

/**
 * TODO: add unit tests
 * @param {string} rgba
 * @return {string|undefined}
 */
function getAlpha(rgba) {
    if (/rgba\(/.test(rgba)) {
        return rgba.match(/\d[^,]*\d(?=\))/)[0];
    }
}

/**
 * Doesn't need unit tests
 * @param {string} className
 * @return {string}
 */
function getDefaultFill(className) {
    const cssRule = getCSSRule(className);
    return cssRule.style.fill;
}

/**
 * Doesn't need unit tests.
 * @param {string} className
 * @return {string}
 */ 
function getDefaultStroke(className) {
    const cssRule = getCSSRule(className);
    return cssRule.style.stroke;
}

/**
 * @param {string} rgb
 * @param {number} alpha
 * @return {string}
 */
function insertAlpha(rgb, alpha) {
    if (!/rgb\(/.test(rgb)) throw new Error("rgb argument must be an 'rgb' string, not an 'rgba' string");
    return rgb.replace(")", `, ${alpha})`).replace("b", "ba");
}

/**
 * Doesn't need unit tests. Tested via color().
 * @param {HTMLElement} e - the HTMLElement to color.
 * @param {string|Object} rgb - either an "rgb()" string or an instance of custom class from chroma.js
 */
function preserveAlphaWithNewColor(e, rgb) {
    if (typeof rgb === "string") {
        if (!/rgb\(/.test(rgb)) throw new Error("rgb argument must be an 'rgb' string, not an 'rgba' string");
    } else {
        rgb = rgb.css().replace(/,/g, ", ");
    }
    const firstThreeNumbers = /(\d+[^\d]+){2}\d+/;
    const styleAttribute = getStyleAttribute(e);
    const oldColor = e.style[styleAttribute];
    const alpha = getAlpha(oldColor);
    const defaultColorValues = (styleAttribute === "fill" ? getDefaultFill(e.classList[0]) : getDefaultStroke(e.classList[0])).match(firstThreeNumbers)[0];
    if (alpha != null) {
        e.style[styleAttribute] = insertAlpha(rgb, alpha);
        //e.style[styleAttribute] = rgb.replace(")", `, ${alpha})`).replace("b", "ba");
        return;
    }
    if (rgb.match(firstThreeNumbers)[0] === defaultColorValues) {
        e.removeAttribute("style");
        return;
    }
    e.style[styleAttribute] = rgb;
    return;
}

/**
 * Doesn't need unit tests. Tested via setAlpha().
 * Set the style of the HTMLElement to either its exisitng inline color with a new alpha value, or the default CSS coloring with the alpha value.
 * @param {HTMLElement} e
 * @param {number} alpha
 */
function preserveColorWithNewAlpha(e, alpha) {
    if (typeof alpha !== "number") throw new Error("New alpha value must be a number");
    if (alpha > 1 || alpha < 0) throw new Error("New alpha value must be between 0 and 1, inclusive.");
    const firstThreeNumbers = /(\d+[^\d]+){2}\d+/;
    const styleAttribute = getStyleAttribute(e);
    let inlineColorValues = e.style[styleAttribute].match(firstThreeNumbers);
    if (inlineColorValues == null) {
        if (alpha === 1) {
            e.removeAttribute("style");
            return;
        } else {
            let rgba = styleAttribute === "fill" ? getDefaultFill(e.classList[0]) : getDefaultStroke(e.classList[0]);
            rgba = insertAlpha(rgba, alpha);
            //rgba = rgba.replace(")", `, ${alpha})`).replace("b", "ba");
            e.style[styleAttribute] = rgba;
            return;
        }
    } 
    inlineColorValues = inlineColorValues[0];
    const defaultColorValues = (styleAttribute === "fill" ? getDefaultFill(e.classList[0]) : getDefaultStroke(e.classList[0])).match(firstThreeNumbers)[0];
    if (inlineColorValues === defaultColorValues && alpha === 1) {
        e.removeAttribute("style");
        return;
    } else {
        e.style[styleAttribute] = `rgba(${inlineColorValues}, ${alpha})`;
        return;
    }
}

//**************************************************
// Private utility functions
//**************************************************

/**
 * Return true if the object has a 'parent' property, otherwise return false.
 * @param {Object} obj
 * @return {boolean}
 */
function isChildNode(obj) {
    return obj.parent !== undefined;
}

/**
 * Return true if the object has 'from' and 'to' properties, otherwise return false.
 * @param {Object} obj
 * @return {boolean}
 */
function isLine(obj) {
    return obj.from !== undefined && obj.to !== undefined;
}

/**
 * Return true if the object is a configuration node.
 * @param {Object} obj
 * @return {boolean}
 */
function isConfigurationNode(obj) {
    if (obj.object == null || configurationTypes.includes(obj.object)) return true;
    return false;
}

/**
 * TODO: add unit tests!
 * Return the document CSSStyleRule that applies to the class name.
 * @param {string} className
 * @return {CSSStyleRule}
 */
function getCSSRule(className) {
    const cssRules = document.styleSheets[0].cssRules;
    const keys = Object.keys(cssRules);
    let key = keys.find(key => {
        const selectorString = cssRules[key].selectorText;
        if (selectorString == null) return false;
        const ary = selectorString.split(",").map(string => string.trim());
        return ary.includes(`.${className}`);
    });
    if (key == null) {
        let relationship;
        try {
            // Need try-catch because player objects have an "object" property but don't exist in components
            relationship = getRelationship(gComponentManager.getAny(className));
        } catch (e) {
            relationship = "not a line";
        }
        if (relationship === "line") {
            key = keys.find(key => cssRules[key].selectorText === "line");
        } else {
            key = keys.find(key => cssRules[key].selectorText === "circle");
        }
    }
    return cssRules[key];
}

/**
 * Return a generator that will provide the longitude and latitude for an object.
 * 
 * @param {number} initX - the longitude of the top left corner of the square.
 * @param {number} initY - the latitude of the top left corner of the square.
 * @param {number} spacing - how far apart to space a node from adjacent nodes in the square.
 * @return {Generator}
 */
function * getCoordinates(initX, initY, spacing) {
    yield {
        longitude: initX,
        latitude: initY
    }
    let x = 0;
    let y = 0;
    let dimension = 1;
    while (true) {
        if (x <= dimension) {
            yield {
                longitude: initX + (x++ * spacing),
                latitude: initY + (dimension * spacing)
            }
        } else {
            yield {
                longitude: initX + (dimension * spacing),
                latitude: initY + (y++ * spacing)
            }
        }
        if (y === dimension) {
            dimension++;
            x = 0;
            y = 0;
        }
    }
}

//**************************************************
// OpacityManager class
//**************************************************

const opacityManagerPrototype = {

    /* Public methods */

    /**
     * Doesn't need unit tests.
     * Fill the document opacity modal HTMLElement with content.
     */
    buildOpacityModal() {
        const opacityModal = document.getElementById("opacityModal");
        const tableDiv = opacityModal.querySelector("[data-tableinsert]");
        Array.from(tableDiv.children).forEach(child => {
            child.parentElement.removeChild(child);
        });
        const table = document.createElement("table");
        const titleRow = document.createElement("tr");
        ["", "Object", "Opacity"].forEach(str => {
            const td = document.createElement("td");
            td.classList.add("centered");
            td.classList.add("fullPadded");
            const h = document.createElement("h3");
            h.textContent = str;
            td.append(h);
            titleRow.append(td);
        });
        table.append(titleRow);
        const keys = Object.keys(this.types).map(key => key.toLowerCase()).sort();
        keys.forEach(key => {
            const objectType = this.types[key] != null ? key : getMixedCaseKey(this.types, key);
            const tr = document.createElement("tr");
            let td = document.createElement("td");
            td.classList.add("fullPadded");
            const btn = getTableButton("Highlight", () => this.highlight(objectType));
            td.append(btn);
            tr.append(td);
            td = document.createElement("td");
            td.classList.add("fullPadded");
            td.textContent = objectType;
            tr.append(td);
            td = document.createElement("td");
            td.classList.add("fullPadded");
            const input = document.createElement("input");
            input.classList.add("modalInput");
            input.dataset.objecttype = objectType;
            const that = this;
            input.addEventListener("change", function() {
                that.setAlpha({className: objectType, input: this});
            });
            input.value = this.types[objectType];
            td.append(input);
            tr.append(td);
            table.append(tr);
        });
        tableDiv.append(table);
        opacityModal.removeAttribute("style");
        if (window.jQuery != null) {
            $("#opacityModal .modalContent").draggable();
        }
    },

    /**
     * Set the alpha value on all HTMLElements with the specified class name.
     * @param {string} className
     * @param {HTMLInputElement} input
     * @param {string} value
     */
    setAlpha({className, input, value=null}) {
        let alpha;
        if (input != null) {
            alpha = input.value;
        } else if (value != null) {
            alpha = value;
        }
        if (isNumberString(alpha)) {
            alpha = parseFloat(alpha);
            if (alpha < 0 || alpha > 1) {
                alert("The opacity value must be between 0 and 1, inclusive.");
                input.value = this.types[className];
                return;
            }
        } else {
            alert("Please enter a valid number between 0 and 1, inclusive.");
            input.value = this.types[className];
            return;
        }
        this.types[className] = alpha; //record the alpha in the gOpacityManager for the case of adding new elements.
        const elements = Array.from(document.getElementsByClassName(className));
        elements.forEach(e => {
            preserveColorWithNewAlpha(e, alpha);
        });
    },

    /**
     * Doesn't need unit tests.
     * Update the OpacityManager to always display existing object types.
     */
    update() {
        const existingObjectTypes = [];
        Object.values(getExistingRelationships()).forEach(ary => {
            ary.forEach(type => existingObjectTypes.push(type));
        });
        existingObjectTypes.forEach(type => {
            if (this.types[type] == null) {
                // User added a new objectType, so add it
                this.types[type] = 1.0;
            }
        });
        Object.keys(this.types).forEach(type => {
            if (!existingObjectTypes.includes(type)) {
                // User deleted all of a previously existing objectType, so delete it
                delete this.types[type];
            }
        });
    },

    /* Private methods */

    /**
     * Set the alpha of every other object type to 0.1.
     * @param {string} className
     */
    highlight(className) {
        Object.keys(this.types).forEach(key => {
            if (key !== className) {
                this.types[key] = 0.1;
                this.setAlpha({className: key, value: "0.1"});
            } else {
                this.types[key] = 1;
                this.setAlpha({className: key, value: "1"});
            }
        });
        const opacityModal = document.getElementById("opacityModal");
        const classInput = opacityModal.querySelector(`input[data-objecttype=${className}`);
        Array.from(opacityModal.querySelectorAll("input[data-objecttype]")).forEach(input => {
            if (input !== classInput) {
                input.value = 0.1;
            } else {
                input.value = 1;
            }
        }); 
    },

    /**
     * Set the alpha of every object type to 1.
     */
    reset() {
        Object.keys(this.types).forEach(key => {
            this.types[key] = 1.0;
            this.setAlpha({className: key, value: "1.0"});
        });
        Array.from(document.getElementById("opacityModal").querySelectorAll("input[data-objecttype]")).forEach(input => {
            input.value = 1.0;
        });
    },
};

/**
 * An OpacityManager is really setting alpha values on HTMLElements, but the term "opacity" is more straightforward.
 */
function createOpacityManager() {
    const om = Object.create(opacityManagerPrototype);
    om.types = {};
    const relationships = getExistingRelationships();
    Object.keys(relationships).forEach(key => {
        relationships[key].forEach(objectType => {
            om.types[objectType] = 1.0;
            //om[type] = 1.0;
        });
    });
    return om;
}

//**************************************************
// Coloring classes
//**************************************************

const colorMapPrototype = {

    /* Public methods */

    /**
     * Apply a color to each HTMLElement that maps to an object that exists in this ColorMap. If any element had an alpha value, preserve it.
     */ 
    color() {
        const invalidNames = [];
        Object.keys(this.colorMap).forEach(name => {
            try {
                const key = gTree.treeMap.getKey(name);
                const e = document.getElementById(key);
                preserveAlphaWithNewColor(e, this.colorMap[name]);
            } catch (e) {
                invalidNames.push(name);
            }
        });
        if (invalidNames.length > 0) {
            alert(`Unable to color the following objects because they weren't found in this graph: "${invalidNames.join(", ")}".`);
        } else {
            alert(`Successfully colored all objects according to the specified column "${this.title}" in the specified csv file "${this.parentTitle}".`);
        }
    },

    /**
     * TODO: break up into smaller methods?
     * Doesn't need unit tests.
     * Create a legend for the color map and append it to the "colorLegends" div.
     */
    appendLegend() {
        const masterDiv = document.createElement("div");
        masterDiv.classList.add("modalContent");
        masterDiv.classList.add("centered");
        masterDiv.style.border = "1px solid black";
        masterDiv.style.alignContent = "center";
        masterDiv.setAttribute("data-colorfile", this.parentTitle);
        masterDiv.setAttribute("data-colormap", this.title);
        let h = document.createElement("h2");
        h.textContent = this.parentTitle;
        masterDiv.append(h);
        h = document.createElement("h3");
        h.textContent = this.title;
        masterDiv.append(h);
        const flexbox = document.createElement("div");
        flexbox.classList.add("legendFlex");
        let div = document.createElement("div");
        div.classList.add("legendGradiant");
        div.style.background = `linear-gradient(0deg,${gViridisColors.join(",")})`;
        flexbox.append(div);
        div = document.createElement("div");
        div.classList.add("vertFlex");
        div.classList.add("legendAxis");
        div.classList.add("leftText");
        const increment = (this.max - this.min) / 7;
        for (let i = 0; i < 8; i++) {
            let p = document.createElement("p");
            let val;
            if (i === 0) {
                val = this.min;
            } else if (i === 7) {
                val = this.max;
            } else {
                val = this.min + i * increment;
            }
            val = val.toString();
            let decimalIdx = val.indexOf(".");
            if (decimalIdx !== -1) {
                val = val.slice(0, decimalIdx + 5);
            }
            p.textContent = val;
            div.prepend(p);
        }
        flexbox.append(div);
        masterDiv.append(flexbox);
        div = document.createElement("div");
        div.style.margin = "20px 0px 0px 0px";
        const button = getTableButton("Close", () => {
            const legendDiv = document.getElementById("colorLegends");
            const legend = legendDiv.querySelector(`div[data-colorfile='${this.parentTitle}'],[data-colormap='${this.title}']`);
            legend.parentElement.removeChild(legend);
        });
        div.append(button);
        masterDiv.append(div);
        document.getElementById("colorLegends").append(masterDiv);
        enableDrag(masterDiv);
    },

    /* private methods */

    /**
     * Create a color map by mapping the 'viridis' color scale to the data inside of this.colorMap.
     */
    buildColorScale() {
        const {min, max} = getMinMax({object: this.colorMap});
        this.min = min;
        this.max = max;
        const f = chroma.scale(gViridisColors).domain([min, max]);
        Object.keys(this.colorMap).forEach(key => {
            this.colorMap[key] = f(this.colorMap[key]);
        });
        this.colorScale = f;
    }
}

/**
 * Doesn't need unit tests.
 * A ColorMap is a wrapper around an object that maps tree object names to colors.
 * @param {string} title - the header of the column in the csv that this color map is representing.
 * @param {ColorFile} parent - the ColorFile that contains this ColorMap. 
 * @return {ColorMap}
 */
function createColorMap(title, parentTitle) {
    const obj = Object.create(colorMapPrototype);
    obj.title = title;
    obj.parentTitle = parentTitle;
    obj.colorMap = {};
    return obj;
}

const colorFilePrototype = {
    
    /* Public methods */

    /* Doesn't need unit tests */
    getTable() {
        const table = document.createElement("table");
        let tr = document.createElement("tr");
        let td = document.createElement("td");
        let h = document.createElement("h4");
        h.classList.add("modalTableHeader");
        h.textContent = this.title;
        td.append(h);
        tr.append(td);
        table.append(tr);
        tr = document.createElement("tr");
        td = document.createElement("td");
        td.classList.add("fullPadded");
        const select = document.createElement("select");
        select.setAttribute("data-colorfile", this.title);
        td.append(select);
        tr.append(td);
        table.append(tr);
        this.colorMaps.forEach(cm => {
            select.innerHTML += `<option value=${cm.title}>${cm.title}</option>`
        });
        tr = document.createElement("tr");
        td = document.createElement("td");
        td.classList.add("fullPadded");
        const button = getTableButton("Color", () => {
            const colorMapName = document.getElementById("colorModal").querySelector(`select[data-colorfile='${this.title}']`).value;//need quotes around the dataset value because of the '.' in the file name.
            const colorMap = this.colorMaps.find(cm => cm.title === colorMapName);
            //If the graph hasn't been desaturated, then it needs to be. If is has been desaturated, then do nothing
            if (this.parent.graphIsDesaturated === false) {
                this.parent.desaturateGraph();
            }
            colorMap.color();
            colorMap.appendLegend();
        });
        td.append(button);
        tr.append(td);
        table.append(tr);
        return table;
    },

    /* Private methods */

    /**
     * TODO: add unit tests
     * Build an array of ColorMaps by parsing the csv file and return the array.
     * @param {File} file
     * @return {Promise}
     */
    buildColorMaps(file) {
        const that = this;
        return new Promise(function(resolve, reject) {
            Papa.parse(file, {
                dynamicTyping: true,
                complete: function(results, file) {
                    const colorMaps = [];
                    try {
                        const headerRow = results.data[0];
                        for (let i = 1; i < headerRow.length; i++) {
                            colorMaps.push(createColorMap(headerRow[i], that.title));
                        }
                        for (let i = 1; i < results.data.length; i++) {
                            let row = results.data[i];
                            for (let j = 1; j < row.length; j++) {
                                colorMaps[j - 1].colorMap[row[0]] = row[j];
                            }
                        }
                        colorMaps.forEach(cm => cm.buildColorScale());
                        resolve(colorMaps);
                    } catch (e) {
                        reject();
                    }
                }
            });
        });
    }
}

/**
 * A ColorFile is a grouping of associated ColorMap objects.
 * @param {File} file - a csv file that maps the name of an object in this tree data to other data.
 * @return {ColorFile}
 */
async function createColorFile(file, parent) {
    const obj = Object.create(colorFilePrototype);
    obj.title = file.name;
    obj.parent = parent;
    obj.colorMaps = await obj.buildColorMaps(file);
    return obj;
}

const colorManagerPrototype = {

    /* Public methods */

    /**
     * Doesn't need unit tests.
     * Load the CSV files into ColorFile objects and fill the color modal HTML with content.
     * 
     * @param {FileList} files - the CSV files to be used to color the graph.
     */
    async buildHTML(files) {
        this.colorFiles = await this.buildColorFiles(Array.from(files));
        const tableDiv = document.getElementById("colorModal").querySelector("div[data-tableinsert]");
        while (tableDiv.firstChild) {
            tableDiv.removeChild(tableDiv.firstChild);
        }
        this.colorFiles.forEach(cf => {
            tableDiv.append(cf.getTable());
        });
    },

    /**
     * Remove all colors that were applied by all ColorMaps from all HTMLElements. If any element had an inline alpha value, preserve it.
     */
    removeColors() {
        Object.keys(gTree.tree).forEach(key => {
            const e = document.getElementById(key);
            // Need to watch out for objects that weren't drawn, like lines with non-existent node ends
            if (e != null) {
                const color = e.tagName.toLowerCase() === "circle" ? getDefaultFill(e.classList[0]) : getDefaultStroke(e.classList[0]);
                preserveAlphaWithNewColor(e, color);
            }
        });
        this.graphIsDesaturated = false;
    },

    /**
     * Prepare the graph to handle multiple overlapping ColorMap colorings by removing all special default colors from nodes and lines. For example, houses will go from blue to gray and transformers will go from yellow to gray.
     */
    desaturateGraph() {
        const cssRules = document.styleSheets[0].cssRules;
        const keys = Object.keys(cssRules);
        const circleFill = cssRules[keys.find(key => cssRules[key].selectorText === "circle")].style.fill;
        const lineStroke = cssRules[keys.find(key => cssRules[key].selectorText === "line")].style.stroke;
        Object.keys(gTree.tree).forEach(key => {
            const e = document.getElementById(key);
            // Need to watch out for data objects that weren't drawn, like lines with non-existent nodes
            if (e != null) {
                const color = e.tagName.toLowerCase() === "circle" ? circleFill : lineStroke;
                preserveAlphaWithNewColor(e, color)
            }
        });
        this.graphIsDesaturated = true;
    },

    /* Private methods */

    /**
     * Doesn't need unit tests.
     * Asynchronously create an array of ColorFiles and return it inside of a Promise.
     * @param {Array} files
     * @return {Promise}
     */
    buildColorFiles(files) {
        const that = this;
        return new Promise(async function(resolve, reject) {
            const colorFiles = [];
            for (let file of files) {
                try {
                    const cf = await createColorFile(file, that);
                    colorFiles.push(cf);
                } catch (e) {
                    alert(`We could not parse the CSV file "${file.name}" that you provided.`);
                }
            }
            resolve(colorFiles);
        });
    }
}

/**
 * Doesn't need unit tests.
 * A ColorManager object contains ColorFile objects.
 * @return {ColorManager}
 */
function createColorManager() {
    const obj = Object.create(colorManagerPrototype);
    obj.graphIsDesaturated = false;
    //obj.colorFiles = await obj.buildColorFiles(Array.from(files));
    return obj;
}

//**************************************************
// SVG classes
//**************************************************

const circlePrototype = {
    /**
     * good. doesn't need tests
     */
    getNewInstance() {
        const circle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
        this.update(circle);
        return circle; 
    },
    /**
     * good. doesn't need tests
     */
    update(circle) {
        if (circle.classList.contains("selected")) {
            circle.setAttribute("class", `${this.class} selected`);
        } else {
            circle.setAttribute("class", this.class);
        }
        circle.setAttribute("id", this.id);
        circle.setAttribute("r", this.r);
        circle.setAttribute("stroke-width", this["stroke-width"]);
        circle.setAttribute("cx", this.cx);
        circle.setAttribute("cy", this.cy);
        if (this.fill != null) {
            circle.setAttribute("style", `fill: ${this.fill}`);
        }
    }
};

/**
 * good. doesn't need unit tests
 */
function createCircle(nodeKey) {
    const circle = Object.create(circlePrototype);
    let tree = gTree;
    if (arguments[1] != null) tree = arguments[1]; // Need this for testing
    const node = tree.getObject(nodeKey);
    circle.id = nodeKey;
    circle.class = node.object;
    circle.r = 2 * gScaleLevel;
    circle["stroke-width"] = .5 * gScaleLevel;
    const lon = node.longitude;
    if (typeof lon !== "number") throw new Error(`'longitude' must be a number.`);
    const lat = node.latitude;
    if (typeof lat !== "number") throw new Error(`'latitude' must be a number.`);
    circle.cx = (lon - gMinLon) * gDrawScaleFactor;
    circle.cy = (gMaxLat - lat) * gDrawScaleFactor;
    const alpha = gOpacityManager.types[node.object];
    if (alpha != null && alpha !== 1) {
        const newFill = insertAlpha(getDefaultFill(node.object), alpha)
        circle.fill = newFill;
    }
    return circle;
}

const linePrototype = {
    /**
     * good. doesn't need tests
     */
    getNewInstance() {
        const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
        this.update(line);
        return line; 
    },

    /**
     * good. doesn't need tests
     */
    update(line) {
        if (line.classList.contains("selected")) {
            line.setAttribute("class", `${this.class} selected`);
        } else {
            line.setAttribute("class", this.class);
        }
        line.setAttribute("id", this.id);
        line.setAttribute("stroke-width", this["stroke-width"]);
        line.setAttribute("x1", this.x1);
        line.setAttribute("x2", this.x2);
        line.setAttribute("y1", this.y1);
        line.setAttribute("y2", this.y2);
        if (this.stroke != null) {
            line.setAttribute("style", `stroke: ${this.stroke}`);
        }
    }
};

/**
 * good. doesn"t need tests
 */
function createParentChildLineWithLine(lineKey, childKey) {
    let tree = gTree;
    if (arguments[2] != null) tree = arguments[2]; // Need this for testing
    const line = Object.create(linePrototype);
    const toNode = tree.getToNode(lineKey);
    const fromNode = tree.getFromNode(lineKey);
    if (toNode == null || fromNode == null) return; // The parent line could itself have nonexistent 'to' or 'from' nodes.
    const child = tree.getObject(childKey);
    line.x1 = (((toNode.longitude + fromNode.longitude)/2) - gMinLon) * gDrawScaleFactor;
    line.y1 = (gMaxLat - ((toNode.latitude + fromNode.latitude)/2)) * gDrawScaleFactor;
    line.x2 = (child.longitude - gMinLon) * gDrawScaleFactor;
    line.y2 = (gMaxLat - child.latitude) * gDrawScaleFactor;
    line.id = getParentChildLineId(lineKey, childKey, tree);    
    line.class = "parentChild";
    line["stroke-width"] = .5 * gScaleLevel;
    return line;
}

// Use to name parent-child lines like: "node18_waterheater4", but now it's just "18_4"
function getParentChildLineId(parentKey, childKey) {
    let tree = gTree;
    if (arguments[2] != null) tree = arguments[2]; // Need this for testing
    return `${parentKey}_${childKey}`;
}

/**
 * good. doesn't need tests
 */
function createParentChildLineWithNode(parentKey, childKey) {
    let tree = gTree;
    if (arguments[2] != null) tree = arguments[2]; // Need this for testing
    const line = Object.create(linePrototype);
    const parent = tree.getObject(parentKey);
    const child = tree.getObject(childKey); // Don't need to check for nonexistent parent because I already do that elsewhere
    line.x1 = (parent.longitude - gMinLon) * gDrawScaleFactor;
    line.y1 = (gMaxLat - parent.latitude) * gDrawScaleFactor;
    line.x2 = (child.longitude - gMinLon) * gDrawScaleFactor;
    line.y2 = (gMaxLat - child.latitude) * gDrawScaleFactor;
    line.id = getParentChildLineId(parentKey, childKey, tree);
    line.class = "parentChild";
    line["stroke-width"] = .5 * gScaleLevel;
    return line;
}

/**
 * good. doesn't need unit tests
 */
function createLine(lineKey) {
    let tree = gTree;
    if (arguments[1] != null) tree = arguments[1]; // Need this for testing
    const line = Object.create(linePrototype);
    const toNode = tree.getToNode(lineKey);
    const fromNode = tree.getFromNode(lineKey);
    if (toNode == null || fromNode == null) return; // A line could have nonexistent 'to' or 'from' nodes
    line.x1 = (fromNode.longitude - gMinLon) * gDrawScaleFactor;
    line.y1 = (gMaxLat - fromNode.latitude) * gDrawScaleFactor;
    line.x2 = (toNode.longitude - gMinLon) * gDrawScaleFactor;
    line.y2 = (gMaxLat - toNode.latitude) * gDrawScaleFactor;
    line.id = lineKey;
    const lineObject = tree.getObject(lineKey);
    const phaseCount = countPhases(lineObject.phases);
    line.class =  `${lineObject.object} p${phaseCount}`;
    switch (phaseCount) {
        case 2:
            line["stroke-width"] = 2 * gScaleLevel;
            break;
        case 3:
            line["stroke-width"] = 3 * gScaleLevel;
            break;
        default:
            line["stroke-width"] = gScaleLevel;
    }
    const alpha = gOpacityManager.types[lineObject.object];
    if (alpha != null && alpha !== 1) {
        const newStroke = insertAlpha(getDefaultStroke(lineObject.object), alpha);
        line.stroke = newStroke;
    }
    return line;
}

const svgDataPrototype = {

    /* Public methods */

    /**
     * good. doesn't need tests
     */
    draw(viewport) {
        this.setSubtreeToRedraw();
        this.quickDraw(viewport);
    },

    /**
     * good. doesn't need tests
     * Use this function when initializing the interface because it's a bit faster since it doesn't traverse subtrees.
     */
    quickDraw(viewport) {
        this.createData();
        this.parentChildLines.forEach(line => {
            this.appendSvg(line, viewport);
        });
        this.lines.forEach(line => {
            this.appendSvg(line, viewport);
        });
        this.circles.forEach(circle => {
            this.appendSvg(circle, viewport);
        });
    },

    /**
     * Just update existing objects. This is an optimization I can worry about later.
     */
    update() {},

    /**
     * good. Doesn't need tests.
     */
    delete(viewport) {
        this.primaryKeySet.forEach(key => {
            const obj = this.tree.getObject(key);
            const relationship = getRelationship(obj);
            if (relationship === "childNode") {
                const parentKey = this.tree.treeMap.getParentKey(key);
                if (parentKey != null) { // child could have a nonexistent parent
                    const id = getParentChildLineId(parentKey, key);
                    const e = document.getElementById(id);
                    viewport.removeChild(e);
                }
            }
            const e = document.getElementById(key);
            if (gSelection.hasId(key)) gSelection.remove(e);
            viewport.removeChild(e);
        });
        this.tree.delete(Array.from(this.primaryKeySet));
    },

    /* Private methods */

    /**
     * good. doesn't need tests
     */
    appendSvg(obj, viewport) {
        const e = document.getElementById(obj.id);
        if (e != null) {
            // Element already exists. Since we are doing a full redraw, remove it, update it, and re-append it.
            e.parentElement.removeChild(e);
            obj.update(e);
            viewport.appendChild(e);
        } else {
            viewport.appendChild(obj.getNewInstance());
        }
    },

    /**
     * good.
     */
    createData() {
        this.parentChildLines = [];
        this.lines = [];
        this.circles = [];
        this.subtreeKeySet.forEach(key => {
            const relationship = getRelationship(this.tree.getObject(key));
            switch (relationship) {
                case "line":
                    const line = createLine(key, this.tree);
                    if (line != null) this.lines.push(line);
                    break;
                case "childNode":
                    this.circles.push(createCircle(key, this.tree));
                    const parentKey = this.tree.treeMap.getParentKey(key);
                    // child could have nonexistent parent. Also, we only want parent-child lines for children of objects in the subtreeKeySet
                    if (parentKey != null && this.subtreeKeySet.has(parentKey)) {
                        const parentType = getRelationship(this.tree.getObject(parentKey));
                        if (parentType === "line") {// this is only for recorders
                            const line = createParentChildLineWithLine(parentKey, key, this.tree);
                            if (line != null) this.parentChildLines.push(line);
                        } else {
                            const line = createParentChildLineWithNode(parentKey, key, this.tree)
                            if (line != null) this.parentChildLines.push(line);
                        }
                    }
                    break;
                case "independentNode":
                case "configurationNode":
                    this.circles.push(createCircle(key, this.tree));
                    break;
            };
        });
    },

    /**
     * good.
     * Get the parent, children, connected lines, children of connected lines, paired nodes, and node ends of the object being redrawn.
     */
    setSubtreeToRedraw() {
        this.primaryKeySet.forEach(key => {
            const parentKey = this.tree.treeMap.getParentKey(key);
            if (parentKey != null) {
                this.subtreeKeySet.add(parentKey);
                if (getRelationship(this.tree.getObject(parentKey)) === "line") {
                    // If the parent line is redrawn, it will cover it's connected nodes unless I do this
                    this.subtreeKeySet.add(this.tree.getToNodeKey(parentKey));
                    this.subtreeKeySet.add(this.tree.getFromNodeKey(parentKey));
                }
            }
            const children = this.tree.treeMap.getChildKeys(key);
            if (children != null) children.forEach(childKey => this.subtreeKeySet.add(childKey));
            const lines = this.tree.treeMap.getLineKeys(key);
            if (lines != null) {
                lines.forEach(lineKey => {
                    this.subtreeKeySet.add(lineKey);
                    // Must also get the children of lines! This means only recorders
                    const lineChildren = this.tree.treeMap.getChildKeys(lineKey);
                    if (lineChildren != null) lineChildren.forEach(childKey => this.subtreeKeySet.add(childKey));
                });
            }
            const pairs = this.tree.getPairedNodeKeys(key);
            if (pairs != null) pairs.forEach(nodeKey => this.subtreeKeySet.add(nodeKey));
            // Don't forget to account for adding a line, even though lines cannot be moved!
            const toNodeKey = this.tree.getToNodeKey(key);
            if (toNodeKey != null) this.subtreeKeySet.add(toNodeKey);
            const fromNodeKey = this.tree.getFromNodeKey(key);
            if (fromNodeKey != null) this.subtreeKeySet.add(fromNodeKey); 
        });
    },
}

/**
 * good. doesn't need tests
 * @param {Array} keys
 */
function createSvgData(keys) {
    const svgData = Object.create(svgDataPrototype);
    svgData.tree = gTree;
    if (arguments[1] != null) svgData.tree = arguments[1]; // Need this for testing
    svgData.primaryKeySet = new Set();
    svgData.subtreeKeySet = new Set();
    keys.forEach(key => {
        svgData.primaryKeySet.add(key);
        svgData.subtreeKeySet.add(key)
    });
    return svgData;
}

//**************************************************
// TreeObject interface
//**************************************************

const treeObjectPrototype = {

    /* Public TreeObject methods.*/

    /**
     * good. Doesn't need unit tests
     * Set the 'parent', 'longitude', and 'latitude' properties of this TreeObject.data based on the 'parent' argument.
     * @param {Object} parent - the object to set as the parent of this child.
     */
    setupChildNode(parentKey) {
        if (getRelationship(this.data) !== "childNode") throw new Error("This TreeObject should have a relationship of 'childNode'.");
        const parent = gTree.getObject(parentKey);
        const relationship = getRelationship(parent);
        if (relationship === "configurationNode") throw new Error("The 'parent' argument cannot be a configuration node.");
        this.data.parent = parent.name;
        if (relationship === "line") {
            this.setupChildNodeWithLine(parentKey);
        } else {
            this.setupChildNodeWithNode(parentKey);
        }
    },

    /**
     * good. Doesn't need unit tests
     * Set the 'from', 'to', and 'phases' properties of this TreeObject.data based on the 'source' and 'target' arguments.
     * @param {Object} source - the starting node of the line.
     * @param {Object} target - the ending node of the line.
     */
    setupLine(sourceKey, targetKey) {
        if (getRelationship(this.data) !== "line") throw new Error("This TreeObject should have a relationship of 'line'.");
        const source = gTree.getObject(sourceKey);
        const target = gTree.getObject(targetKey);
        const sType = getRelationship(source);
        const tType = getRelationship(target);
        const types = ["childNode", "independentNode"];
        if (!types.includes(sType) || !types.includes(tType)) throw new Error("The 'source' and 'target' arguments should have a relationship of 'childNode' or 'independentNode'.");
        if (source.name == null || target.name == null) throw new Error("The 'source' and 'target' arguments should have a 'name' property.");
        if (source.phases === undefined) {
            const name = source.name !== undefined ? source.name : Object.values(source)[0]; 
            alert(`The source node of this line, "${name}", does not have a 'phases' property.`);
        } else {
            this.data.phases = source.phases;
        }
        this.data.from = source.name;
        this.data.to = target.name;
    },

    /* "Private" helper methods */

    setupChildNodeWithLine(lineKey) {
        const toNode = gTree.getToNode(lineKey);
        const fromNode = gTree.getFromNode(lineKey);
        const parentLongitude = (toNode.longitude + fromNode.longitude)/2;
        const parentLatitude = (toNode.latitude + fromNode.latitude)/2;
        const lonValue = this.getRandomOffset();
        this.data.longitude = Math.random() < 0.5 ? parentLongitude + lonValue : parentLongitude - lonValue; 
        const latValue = this.getRandomOffset();
        this.data.latitude = Math.random() < 0.5 ? parentLatitude + latValue : parentLatitude - latValue;
    },

    setupChildNodeWithNode(nodeKey) {
        const parent = gTree.getObject(nodeKey);
        const lonValue = this.getRandomOffset();
        this.data.longitude = Math.random() < 0.5 ? parent.longitude + lonValue : parent.longitude - lonValue;
        const latValue = this.getRandomOffset();
        this.data.latitude = Math.random() < 0.5 ? parent.latitude + latValue : parent.latitude - latValue;
    },

    getRandomOffset() {
        return ((Math.random() * 4) + 4)/gDrawScaleFactor; 
    }
};

/**
 * Return a key value which has not been used in tree.
 * @return {string} key
 */
function getNewTreeKey(tree) { 
	let nextKey = Object.keys(tree).length;
	while(tree.hasOwnProperty(nextKey.toString())) {
		nextKey += 1;
	}
	return nextKey.toString();
}

/**
 * good
 */
// Return the number of phases a line has.
function countPhases(str) {
	let total = 0
    if (str == null) return total;
	if (str.search("A") > -1) {total++}
	if (str.search("B") > -1) {total++}
	if (str.search("C") > -1) {total++}
	return total;
}

/** 
 * Return a TreeObject.
 * 
 * A TreeObject (which is not to be confused with a more general "tree object") is either:
 * 1) a copy of a component that is in the process of being added to the tree, OR
 * 2) a copy of an existing object in the tree.
 * 
 * @param {(string|Object)} input - either a key OR a map of properties to create this TreeObject.
 * @param {TreeWrapper} tree - the treeWrapper from which to create this TreeObject.
 * return {TreeObject} - Either a new component that does not exist in the tree, or a copy of an existing tree object inside of the treeWrapper argument.
 */
function createTreeObject(input, tree) {
    if (Object.getPrototypeOf(tree) !== treePrototype) throw new Error("'tree' argument must be an instance of the Tree class.");
    const tObject = Object.create(treeObjectPrototype);
    if (typeof(input) === "string") {
        if (isNumberString(input)) {
            const obj = tree.getObject(input);
            tObject.key = input;
            tObject.data = deepCopy(obj);
            ["longitude", "latitude"].forEach(prop => {
                if (tObject.data[prop] != null && typeof tObject.data[prop] === "string") {
                    throw new Error(`TreeObject creation failed. The tree object with key: "${input}" has a string value for its "${prop}" property.`);
                }
            });
            return tObject;
        } else {
            throw new Error(`TreeObject creation failed. If the 'input' argument is a string, it must be a numeric string.`);
        }
    } else if (typeof input === "object" && !Array.isArray(input)) {
        tObject.key = getNewTreeKey(tree.tree);
        tObject.data = deepCopy(input);
        if (tObject.data.name == null) throw new Error("TreeObject creation failed. The component lacks the 'name' property");
        tObject.data.name = `${tObject.data.name}_${tObject.key}`;
        ["longitude", "latitude"].forEach(prop => {
            if (tObject.data[prop] != null && typeof tObject.data[prop] === "string") {
                tObject.data[prop] = parseFloat(tObject.data[prop]);
            }
        });
        return tObject;
    } 
    throw new Error("TreeObject creation failed. The 'input' argument must be a string or an object.");
}

//**************************************************
// Table interface 
//**************************************************

/*
These are names of properties in most objects in gWriteFeeder.tree that should not be deleted from objects because
doing so might make that object hard to identify with reference to the rest of the data.
*/
const nonDeletableProperties = ["name", "object", "from", "to", "parent", "latitude", "longitude", "configuration"];
/* If these properties were to be modified for a given gWriteFeeder.tree object, it would require significantly modifying the 
other objects.  These properties ARE technically modifiable, but allowing the user to change them would require more work 
than I think is worth it. It is easier just to create a new node.
*/
const nonModifiableProperties = ["name", "object"];
const titleProperties = ["object"];
/* This array is used to determine if an object is a configuration node, based on the "object" property of that node. If a node
lacks the "object" property entirely, then I know its a configuration node.
Player is a configuration object. Recorder can have a parent, so it is NOT a configuration object.
*/
const configurationTypes = ["regulator_configuration", "transformer_configuration", "triplex_line_configuration", "line_configuration",
"volt_var_control", "line_spacing", "climate", "overhead_line_conductor", "underground_line_conductor", "triplex_line_conductor",
"player", "schedule"];

/**
 * @param {HTMLDivElement} - modal
 */
function formatModal(modal) {
    ["h1", "h2", "h3", "h4", "h5", "h6"].forEach(h => {
        const headings = Array.from(modal.querySelectorAll(`div.modalContent > ${h}`));
        if (headings.length > 0) {
            headings.forEach(h => {
                h.classList.add("centered");
            });
        }
    });
}

function formatTable(table) {
    Array.from(table.querySelectorAll("td")).forEach(td => {
        td.classList.add("fullPadded");
    });
}

// delete this eventually
function rebuildSelectionTable() {
    destroyTables(["selectionTable"]);
    const ids = gSelection.getKeys();
    if (ids.length > 0) {
        const table = createSelectionTable(ids, gTree);
        document.getElementById("selectionTable").appendChild(table);
    } 
}
/**
 * TODO: add unit tests, $().draggable make the text unfocusable
 * If an object has no name, just get the first property in the object.
 */
function createSelectionTable(ids, tree) {
    const table = document.createElement("table");
    const tHead = document.createElement("thead");
    const tBody = document.createElement("tbody"); 

    const titleRow = createRow({key: "Selected Elements"});
    Array.from(titleRow.self.children).forEach(td => { 
        td.classList.add("tableTitle");
        td.classList.add("fullPadded");
    });
    titleRow.self.children[1].setAttribute("colspan", "2");
    titleRow.self.children[2].remove();

    tHead.append(titleRow.self);
    table.append(tHead);
    table.append(tBody);
    table.classList.add("dataTable");

    // duplicate
    const buttonRow = document.createElement("tr");
    buttonRow.classList.add("buttonRow");
    const buttonCell = document.createElement("td");
    buttonCell.setAttribute("colspan", "3");
    buttonCell.classList.add("fullPadded");
    buttonCell.append(getTableButton("move", function() {
        destroyTables(["descriptionTables"]);
        attachMoveListener(gSelection.getKeys());
    }));
    buttonRow.append(buttonCell);
    tBody.append(buttonRow);
    // duplicate

    ids.forEach(id => {
        let obj = tree.getObject(id);
        let name = obj.name != null ? obj.name : obj.object != null ? obj.object : Object.keys(obj)[0];
        const button = getTableButton("view", getDisplayTableFunction(id));
        let row = createRow({key: name, value: button, deletable: true}, document.getElementById(id));
        Array.from(row.self.children).forEach(td => {
            td.classList.add("fullPadded");
        });
        tBody.append(row.self);
    });
    enableDrag(table);
    return table;
}

/* Helper functions */

function getDisplayTableFunction(id) {
    let displayTable = function() {
        let table = document.getElementById(`descriptionTable_${id}`);
        if (table == null) {
            const table = createDescriptionTable(id);
            table.id = `descriptionTable_${id}`;
            document.getElementById("descriptionTables").append(table);
        }           
    }
    return displayTable;
}

function getTableButton(text, func) {
    const button = document.createElement("button");
    button.textContent = text;
    button.classList.add("modalButton");
    button.addEventListener("click", func);
    return button;
}


/**
 * TODO: add unit tests, don't allow longitude and latitude to be editted for lines!,
 * turn all key inputs into plain text upon clicking save (would look nice), 
 * 
 * Bugs: $().draggable() makes text unfocusable via double click. Unfortunately,
 * this is set behavior of the library because the demo on the jQuery wesbsite behaves the same way. Users must right click
 * text in a table to select it.
 * 
 * The form element is only used to take advantage of the "required" form validation functionality that is native to the
 * browser.
 */
function createDescriptionTable(id) {
    const form = document.createElement("form");
    form.classList.add("formContainer");
    const table = document.createElement("table");
    table.classList.add("dataTable");
    const tHead = document.createElement("thead");
    const tBody = document.createElement("tbody");
    // duplicate
    const buttonRow = document.createElement("tr");
    buttonRow.classList.add("buttonRow");
    const buttonCell = document.createElement("td");
    buttonCell.classList.add("fullPadded");
    buttonCell.setAttribute("colspan", "3");
    buttonRow.append(buttonCell);
    // duplicate
    form.append(table);
    table.append(tHead);
    table.append(tBody);
    tBody.append(buttonRow);
    const tObject = createTreeObject(id, gTree);
    if (getRelationship(tObject.data) !== "line") {
        buttonCell.append(createButton({action: "move", tObject: tObject, tableBody: tBody}).self);
    }
    buttonCell.append(createButton({action: "delete", tObject: tObject, tableBody: tBody}).self);
    buttonCell.append(createButton({action: "add", tObject: tObject, tableBody: tBody}).self);
    buttonCell.append(createButton({action: "save"}).self);
    form.addEventListener("submit", function(event) {
        event.preventDefault();
        // Delete the object entirely just in case parent was changed, in order to delete the old parent-child line
        const svg = createSvgData([tObject.key]);
        svg.delete(gViewport);
        gTree.insert(tObject);// re-insert the updated object. It is remapped in the process.
        svg.draw(gViewport);
        alert("Object saved");
    });
    Object.keys(tObject.data).forEach(key => {
        let row;
        if (titleProperties.includes(key)) {
            row = createRow({key: key, tObject: tObject});
            Array.from(row.self.children).forEach(td => {
                td.classList.add("tableTitle");
                td.classList.add("fullPadded");
            });
            tHead.append(row.self);
        } else {
            row = createRow({key: key, deletable: true, tObject: tObject});
            Array.from(row.self.children).forEach(td => {
                td.classList.add("fullPadded");
            });
            tBody.appendChild(row.self);
        }
    });
    //Display key
    //row = createRow({key: "key", value: `${tObject.key}`});
    //Array.from(row.self.children).forEach(td => {
    //    td.classList.add("tableTitle");
    //});
    //tHead.append(row.self);
    //Display key
    enableDrag(table);
    return form;
}

/**
 * TODO: add unit tests
 */
 function destroyTables(ids) {
    ids.forEach(id => {
        const tableDiv = document.getElementById(id);
        Array.from(tableDiv.children).forEach(t => {
            tableDiv.removeChild(t);
        });
    });
}

const buttonPrototype = {

    /* Private helper methods */

    /**
     * TODO: update unit tests
     * Delete the TreeObject of this button from the TreeWrapper of this button
     */
    deleteObject() {
        const key = this.tObject.key;
        if (gTree.isDeletable(key)) {
            createSvgData([key]).delete(gViewport);
            rebuildSelectionTable();
        } else {
            let msg = `If you click "ok", you will delete this object and all of its connected children and/or lines. `;
            const children = gTree.treeMap.getChildKeys(key);
            if (children != null) {
                msg += `Do you want to delete "${gTree.getObject(key).name}" and its children: "${children.join(", ")}"? `;
            }
            const lines = gTree.treeMap.getLineKeys(key);
            if (lines != null) {
                msg += `Do you want to delete "${gTree.getObject(key).name}" and its lines: "${lines.join(", ")}"?`;
            }
            if (confirm(msg)) {
                const keys = gTree.getSubtreeToDelete(key);
                keys.push(key);
                createSvgData(keys).delete(gViewport);
                //console.log(document.getElementById("svgContainer").onclick);
                rebuildSelectionTable();
            }
        }
    },

    /**
     * TODO: add unit tests
     */
    validateArguments(args) {
        if (args.action === "move") {
            //if (args.tObject == null || args.tWrapper == null || args.tableBody == null) {
            //    throw new Error(`A button with a "${args.action}" action must have non-null tObject, tWrapper, and tableBody arguments`);
            //}
        } else if (args.action === "delete") {
            if (args.tObject == null || args.tableBody == null) {
                throw new Error(`A button with a "delete" action must have non-null tObject and tableBody arguments`);
            }
        } else if (args.action === "add") {
            if (args.tObject == null || args.tableBody == null) {
                throw new Error(`A button with an "add" action must have non-null tObject and tableBody arguments`);
            }
        } else if (args.action !== "save") {
            throw new Error(`The action argument must match an existing action`);
        }
    }
}

/**
 * TODO: add unit tests, DON'T remove tObject argument, remove tWrapper argument
 */
function createButton({action, tableBody=null, tObject=null}) {
    const button = Object.create(buttonPrototype);
    button.validateArguments(arguments[0]);
    button.self = document.createElement("button");
    button.self.textContent = action;
    button.self.classList.add("modalButton");
    button.tObject = tObject;
    button.tableBody = tableBody;
    button.self.type = "button";
    switch (action) {
        case "move":
            button.self.addEventListener("click", function() {
                attachMoveListener([tObject.key], tableBody, tObject);
            });
            break;
        case "delete":
            button.self.classList.add("deleteButton");
            button.self.addEventListener("click", function() {
                button.deleteObject();                
                document.getElementById("descriptionTables").removeChild(tableBody.parentElement.parentElement);
            });
            break;
        case "add":
            button.self.addEventListener("click", function() {
                const row = createRow({key: "", deletable: true, tObject: tObject});
                Array.from(row.self.children).forEach(td => {
                    td.classList.add("fullPadded");
                });
                tableBody.append(row.self);
            });
            break;
        case "save":
            button.self.type = "submit";
            break;
        default:
            throw new Error("The action argument must be a string that matches an existing action for this button.");
    }
    return button;
}

const rowPrototype = {

    /* Private helper methods */

    /**
     * Throw an error if arguments passed to createRow() were invalid.
     * @param {Object} args - an object containing the arguments that were passed to createRow().
     */
    validateArguments(args) {
        if (args.key != null && args.value != null && args.tObject != null) {
            throw new Error(`If there are key and tObject arguments, then the value of the row is determined by map[key] and passing a value
            argument is invalid`);
        } else if (args.tObject != null && args.tObject.data[args.key] === undefined && args.key !== "") {
            throw new Error("If a tObject argument is passed, the key argument should exist in that tObject.data.");
        } else if (args.key === "" && args.tObject == null) {
            throw new Error("If the key is an empty string, a tObject argument should be passed to the function");
        }
    },

    /**
     * Return false if the key already exists in the map or, otherwise return true.
     * @param {string} key - the incoming key that the user wants to write into the map belonging to this Row.
     * @return {boolean}
     */
    validateNewKey(key) {
        // These keys cannot be added becasue they would turn the object into a different type. If a user wants such an object, they should add a new one and edit its attributes.
        const invalidKeys = [undefined, "", "to", "from", "parent"];
        if (invalidKeys.includes(key)) return false;
        if (this.tObject.data[key] !== undefined) return false;
        return true;
    },

    /** 
     * Return false if the current key is an empty string, otherwise return true.
     * @return {boolean}
     */
    validateCurrentKey() {
        return this.key === "" ? false : true;
    },

    /**
     * Update a key in the map that belongs to this Row.
     * @param {HTMLInputElement} input - contains the new key that should be written to the map, if it is valid.
     */
    updateMapKey(input) {
        const newKey = input.value.trim();;
        if (this.validateNewKey(newKey)) {
            this.tObject.data[newKey] = this.tObject.data[this.key] != null ? this.tObject.data[this.key] : "";
            delete this.tObject.data[this.key];
            this.key = newKey;
        } else {
            alert(`A new attribute must not match an existing attribute. Additionally, the attributes "", "parent", "to", and "from" cannot be added.`);
            input.value = this.key;
        } 
    },
    /**
     * Return an HTMLTableCellElement.
     * @return {HTMLTableCellElement}
     */
    getKeyElement() {
        const td = document.createElement("td");
        if (this.key === "") {
            const input = document.createElement("input");
            input.classList.add("modalInput");
            td.appendChild(input);
            input.required = true;
            input.pattern = "[\\s]*[\\S]+.*";
            const that = this;
            input.addEventListener("change", function() {
                that.updateMapKey(this);
            });
        } else {
            td.textContent = this.key;
        } 
        return td;
    },

    /** 
     * Return true if the value is valid for the Row (based on the key of that Row), otherwise return false.
     * @param {string} value - a value for a corresponding key that should be validated based on the key.
     * @return {boolean}
     */
    validateNewValue(value) {
        if (this.key === "longitude" || this.key === "latitude") return isNumberString(value);
        if (this.key === "parent") {
            if (isValidParentName(value, this.tObject.object)) return true;
            return false;
        }
        if (this.key === "to" || this.key === "from") {
            if (!isValidToOrFromNode(value)) return false;
            if (this.key === "to" && this.tObject.data.from === value) return false;
            if (this.key === "from" && this.tObject.data.to === value) return false;
        }
        return true;
    },

    /** 
     * Update a value in the map that belongs to this Row.
     * @param {HTMLInputElement} input - contains the new value that should be written to the map, if the value is valid.
     */
    updateMapValue(input) {
        if (!this.validateCurrentKey()) {
            alert("Please enter a valid key for this row before entering a value.");
            input.value = "";
            return;
        }
        let newValue = input.value.trim();
        if (this.validateNewValue(newValue)) {
            if (this.key === "longitude" || this.key === "latitude") newValue = parseFloat(newValue);
            this.tObject.data[this.key] = newValue;
        } else {
            alert(`The value "${newValue}" is invalid for for the key "${this.key}" in the table.`);
            input.value = this.tObject.data[this.key];
        }
    },
    /** 
     * Return an HTMLTableRowElement.
     * @param {Array} nonModifiableProperties - a hard-coded array of properties that the user shouldn't be able to modify.
     * @return {HTMLTableRowElement}
     */
    getValueElement(nonModifiableProperties) {
        const td = document.createElement("td");
        if (typeof(this.value) === "string") {
            // Display a string with no regard to any TreeObject
            td.textContent = this.value;
            return td;
        } else if (this.value instanceof HTMLElement) {
            // Display another HTMLElement instead of a string
            td.append(this.value);
            return td;
        } else if (this.value == null) {
            if (this.tObject == null) {
                // Don't display any value
                return td;
            } else {
                // Display value within TreeObject.data
                const value = this.key === "" ? "" : this.tObject.data[this.key];
                if (nonModifiableProperties.includes(this.key)) {
                    td.textContent = value;
                } else {
                    const input = document.createElement("input");
                    if (this.key === "longitude") {
                        input.dataset.coordinate = "longitude";
                    } else if (this.key === "latitude") {
                        input.dataset.coordinate = "latitude";
                    }
                    input.classList.add("modalInput");
                    td.appendChild(input);
                    const that = this;
                    input.addEventListener("change", function() {
                        that.updateMapValue(this);
                    });
                    input.value = value;
                }
                return td;
            }
        }
        throw new Error("Invalid value was provided for this row");
    },

    /** 
     * TODO: add unit tests
     * Return an HTMLTableRowElement.
     * @param {boolean} deletable - whether or not the returned <td> should have a delete button element child.
     * @param {Array} nonDeletableProperties - a hard-coded array of properties that the user should not be able
     * to delete from a TreeObject.
     * @return {HTMLTableRowElement}
     */
    getDeleteElement(deletable, nonDeletableProperties) {
        const td = document.createElement("td");
        if (deletable === true && !nonDeletableProperties.includes(this.key)) {
            const btn = document.createElement("button");
            btn.innerHTML = "&#9587;"
            btn.setAttribute("class", "modalButton deleteButton"); 
            td.appendChild(btn);
            btn.addEventListener("click", () => { this.delete() });
        } 
        return td;
    },

    /**
     * TODO: update unit tests
     * Delete the row from the table. Delete the key from the map, if there was a map.
     */
    delete() {
        this.self.parentElement.removeChild(this.self);
        if (this.tObject != null) {
            delete this.tObject.data[this.key];
        } 
        // This is only used with the selection table rows (very confusing btw)
        if (this.element != null) {
            gSelection.remove(this.element);
            const table = document.getElementById(`descriptionTable_${this.element.id}`);
            if (table != null) {
                document.getElementById("descriptionTables").removeChild(table);
            }
            if (gSelection.getKeys().length === 0) {
                destroyTables(["selectionTable"]);
            }
        }
    },
}

/** 
 * Return a Row that can be appended to a table.
 * 
 * @param {string} key - the key of the row, which must be a property of the tObject.data argument if the tObject argument is not null.
 * @param {string|HTMLElement} - an optional value of the row.
 * @param {Object} map - an optional object that contains the data being manipulated by all of the rows. 
 * @param {?} value - either a string or an HTMLElement to be displayed outright, with no relationship to the tObject (which should be null if this argument is passed).
 * @param {boolean} deletable - whether or not the row should have a delete button.
 * @return {Row} - A wrapper object around the HTMLTableRowElement.
 */ 
function createRow({key, value=null, tObject=null, deletable=false}) {
    const obj = Object.create(rowPrototype);
    obj.validateArguments(arguments[0]);
    obj.key = key;
    obj.value = value;
    obj.tObject = tObject;
    //obj.map = map;
    obj.self = document.createElement("tr");
    obj.self.append(obj.getDeleteElement(deletable, nonDeletableProperties));
    obj.self.append(obj.getKeyElement());
    obj.self.append(obj.getValueElement(nonModifiableProperties));
    if (arguments[1] != null) {
        obj.element = arguments[1];
    }
    return obj;
}

//**************************************************
// Event listeners
//**************************************************

/**
 * TODO: add unit tests
 */
function getMoveNodesFunction(objects, tBody=null, tObject=null) {
    if (objects.length > 1 && tBody != null) throw new Error("Cannot update a description table when multiple nodes have been selected to be moved.");
    const moveNodes = function(event) {
        event.stopPropagation();
        detachListener();
        const coords = clickLatLon(event);
        move(objects, coords);
        if (tObject != null) {
            if (objects.length !== 1) throw new Error("Can only update the tObject of a description table when moving a single object!");
            tObject.data.longitude = objects[0].longitude;
            tObject.data.latitude = objects[0].latitude;
        }
        if (tBody != null) {
            Array.from(tBody.getElementsByTagName("input")).forEach(input => {
                if (input.dataset.coordinate === "latitude") {
                    input.value = gMaxLat - coords.y/gDrawScaleFactor;
                } else if (input.dataset.coordinate === "longitude") {
                    input.value = coords.x/gDrawScaleFactor + gMinLon;
                }
            });
        }
    };
    return moveNodes
}

function detachListener() {
    const element = document.getElementById("svgContainer");
    element.setAttribute("style", "cursor: default");
    element.onclick = null;
}

// Ignore drags, those should be handled by svg-panzoom.
function detectDrag(event) {
    return (gDownX !== event.clientX || gDownY !== event.clientY) ? true : false;
}

//**************************************************
// Initialization
//**************************************************

function createSingletons() {
    gOpacityManager = createOpacityManager();
    gAddManager = createAddManager();
    gSelection = createSelection();
}

function createInterface() {
    createViewport(gWriteFeeder.tree, document.getElementById("svgContainer"));
    gTree = createTree(gWriteFeeder.tree);
    const objects = Object.values(gTree.tree);
    insertCoordinates(objects, gMinLon, gMaxLat, (1000/gDrawScaleFactor) * .005);
    gViewport = document.getElementsByClassName("svg-pan-zoom_viewport")[0];
    createSingletons();
    createSvgData(Object.keys(gTree.tree)).quickDraw(gViewport);
}

/* TODO: fix this since jquery is never null */
function initializeJQuery() {
    if (window.jQuery != null) {
        applyJQueryStyles();
    }
    if (document.getElementById("panZoomInsert").textContent.trim() !== "") {
        disableJQueryFunctionality();
    }
}

function initializeFindModal() {
    const searchInput = document.getElementById("searchInput");
    searchInput.addEventListener("change", searchTerm);
    document.getElementById("searchExactString").addEventListener("change", function() {
        searchTerm.call(searchInput);
    });
    document.getElementById("searchSubstring").addEventListener("change", function() {
        searchTerm.call(searchInput);
    });
}

function initializeColorModal() {
    const colorModal = document.getElementById("colorModal");
    const colorManager = createColorManager();
    colorModal.querySelector("input[type=file]").addEventListener("change", async function() {
        await colorManager.buildHTML(this.files);
    });
    colorModal.querySelector("button[data-buttonfunction='reset']").addEventListener("click", () => {
        colorManager.removeColors();
    });
}

(function initialize() {
    //createSingletons();
    createInterface();
    attachHandlers();
    initializeJQuery();
    initializeFindModal();
    initializeColorModal();
    document.getElementById("loadingMessage").style.display = "none"
})();

    //buildFeeder();
    //const t0 = performance.now();

    /* 
    const t1 = performance.now();
    const time = t1 - t0;
    console.log(`Tree rendering time was ${time} ms`);
    */
    
    /*
    setTimeout(function() {
        const deleteSvgData = createDeletableSvgData(gTree.tree);
        deleteSvgData.deleteFrom(viewport);
    }, 2000);
    */

//ADD PROMPT TO SAVE CHANGES BEFORE EXIT
{% if showFileMenu %}
    // Browsers don't show custom 'beforeunload' messages anymore due to spamming users, so don't bother setting it
    window.onbeforeunload = function(event) {
        return "";
    }
{% endif %}
</script>
<!--<script type='text/javascript' src='/static/distDataValidation.js'></script>-->
{% if spec %}{{ spec | safe }}{% endif %}
