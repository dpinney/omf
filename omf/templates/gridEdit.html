<head>
	<title>Feeder #{{ feederNum }} from {{ modelName }}</title>
	<script type="text/javascript" src="/static/d3.v3.js"></script>
	<script type="text/javascript" src="/static/omf.js"></script>
	<script type="text/javascript" src="/static/jquery-1.9.1.js"></script>
	<link rel="stylesheet" href="/static/omf.css" />
	<link rel="shortcut icon" href="/static/favicon.ico" />
	<style>
		div#menuLeft{max-height:40px;float:left;font-size:medium;color:white;margin:-5px 0 0 15px;max-width:430px;}
		div#menuRight{height:40px;font-size:medium;color:white;float:right;}
		div#fileDiv{width:55px;padding:0 0.9em 0 0.9em;float:right;}
		table.importOptions {font-size:10pt;width:100%; text-align:left; margin-left:5px;display:inline;}
		table.importOptions tr td:first-child {width:40%;}
		table.importOptions td {border-bottom: none}
		select, input[type='text'], input[type='email'], input[type='file'], button {
			margin: -2px 0 -2px 0;font-size:small;}
		input[type='text'], input[type='file']{margin: -2px auto -2px auto;text-align:left;}
		input[type='submit'] {padding:4px 6px 4px; float:right;}
		div#layoutDiv{width:50px;padding:0 0.9em 0 0.9em;float:right;margin-right:5px;}
		div#findDiv{width:35px;padding:0 0.9em 0 0.9em;float:right;}
		div#foldDiv{width:60px;padding:0 0.9em 0 0.9em;float:right;}
		div#pinDiv{width:60px;padding:0 0.9em 0 0.9em;float:right}
		div#editDiv{width:35px;padding:0 0.9em 0 0.9em;float:right}
		div#addDiv{width:35px;padding:0 0.9em 0 0.9em;float:right}
		div#helpDiv{width:35px;padding:0 0.9em 0 0.9em;float:right}
		#helpButton{color: white;}
		select, button {width:initial;}
		td, th {padding:3px;text-align: left;}
		body {
			overflow: hidden;
			height: 100%;
			background: white;
		}
		/*other styles*/
		input#gridNameEdit {
			font-size: 28pt;
			line-height: 28pt;
			text-shadow: 0px 1px 1px #4d4d4d;
			height: 50px;
			color: gray;
			padding: 3px;
			margin-bottom: 5px;
			width: 85%;
		}
		button.smallButton {
			height: 20px;
			width: 20px;
			display: inline-block;
			float: right;
			padding: 2px;
			margin-left: 5px;
		}
		/* Edit object table style */
		button.deleteButton {
			width: 100%;
			float: right;
			background-color: #CC0000;
			color: white;
		}
		button.deleteButton:hover {
			background: #FF0000;
		}
		#selected {
			min-width: 350px;
			position: absolute;
			top: 90pt;
			left: 4pt;
			margin: -60px 0 0 800px;
		}
		#selected table{
			border: 1px solid black;
			border-bottom: 0px;
			display: none;
			width: 100%;
		}
		#selected button{
			width: 100%;
		}
		#selected #otherButtons{
			display: none;
		}
		#selHead tr td {
			background: black;
			color: white;
		}
		#selBody{
			max-height: 100%;
			max-width: 100%;
			overflow-y: auto;
		}
		#selected #selBody td {
			padding: 5px;
			border-bottom: 1px solid black;
		}
		#selected button{
			width: 100%;
		}
		#selBody td{
			word-break: break-all;
			max-width: 100px;
		}
		#selBody td, #daButtons td{
			background: white;
			color: black;
		}
		input {
			min-width: 100px;
		}
		/* Start graph elements. */
		.nodetext {
			pointer-events: none;
			z-index: 10;
			text-anchor: start;
			fill: #DDDDDD;
			stroke: #000000;
		}
		g.node {
			fill: gray;
			stroke: #fff;
		}
		line.link {
			stroke: black;
			stroke-opacity: 1;
			stroke-width: 6px;
		}
		line.parentChild {
			stroke-dasharray: 0.4,0.4;
		}
		line.selected {
			stroke: lime;
			stroke-width: 8px;
			stroke-opacity: 1.0;
		}
		g.selected {
			stroke: lime;
			stroke-width: 2px;
			stroke-opacity: 1.0;
		}
		g.multiselected {
			stroke: lime;
			stroke-width: 4px;
			stroke-opacity: 1.0;
			stroke-dasharray: 1,1;
		}
		g.house {
			fill: #3366FF;
		}
		g.load {
			fill: #3366FF;
		}
		g.ZIPload, g.waterheater {
			fill: #66CCFF;
		}
		g.triplex_meter {
			fill: #FF6600;
		}
		g.triplex_node {
			fill: #FFCC00;
		}
		g.gridNode {
			fill: #CC0000;
		}
		g.swingNode {
			fill: hotpink;
		}
		g text {
			fill: black;
			stroke: black;
			stroke-width: 0px;
			stroke-opacity: 1;
			font-size: 15;
			pointer-events: none;
		}
		circle.nodeIsPinned {
			fill: none;
			stroke: black;
			pointer-events: none;
		}
		circle.nodeNotPinned {
			fill: none;
			pointer-events: none;
		}
		.node:not(:hover) .nodetext{
			display: none;
		}
		.axis path,.axis line {
			fill: none;
			stroke: #ddd;
			stroke-width: 1px;
			shape-rendering: crispEdges
		}
		.axis text {
			font-family: sans-serif;
			font-size: 11px;
			text-anchor: middle;
		}
		text.markerText {
			fill: gray;
			font-size: 6px;
		}
		rect {
			fill: #fff;
		}
	</style>
</head>
<body onkeypress='hotkeys()' onload="showProgress();">
<div id="header">
	<div id="menuLeft">
		&nbsp;<span contenteditable="false" id='feederName' name='feederName' style="font-weight:bold;">{{ feederName }}</span>
		<br>
		&nbsp;from&#8220;<span id = 'modelNameHeader'>{{ modelName }}</span>&#8221;
	</div>
	<div id="menuRight">
		<div id="fileDiv">
			<div class='buttonGroup'>
				{% if is_admin or not public %}
				<button id="fileOps" class='pill' onclick='dropPill(this, "File")'>File ▾</button>
				<ul class='menu right'>						
					<li><a href='javascript:saveFeeder();'>Save</a></li>
					<li><a href='javascript:renameFeeder();'>Rename</a></li>
					<li><a href='javascript:showModal("loadModal");'>Load from Model...</a></li>
					<li><a href='javascript:showModal("blankFeederModal");'>New Blank Feeder...</a></li>
					<li><a href='javascript:showModal("milSoftModal");'>Windmil Conversion...</a></li>
					<li><a href='javascript:showModal("gridlabModal");'>GridLAB-D Conversion...</a></li>
					<li><a href='javascript:showModal("cymeModal");'>CYMDIST Conversion...</a></li>
				</ul>
				{% endif %}
			</div>
		</div>
		<div id="foldDiv">
			<div class="buttonGroup">
				<button id="foldingOps" class='pill' onclick='dropPill(this, "Folding");'>Folding ▾</button>
				<ul class='menu right'>
				<li><a href='javascript:foldOneLevel();unsavedChanges=true'>One Level Fold</a></li>
				<li><a href='javascript:unfoldOneLevel();unsavedChanges=true'>One Level Unfold</a></li>
				<li><a href='javascript:unfoldAll();unsavedChanges=true'>Unfold All</a></li>
				<li><a href='javascript:foldAtSelected();unsavedChanges=true'>Fold at Selected (f)</a></li>
				<li><a href='javascript:unfoldAtSelected();unsavedChanges=true'>Unfold at Selected (u)</a></li>
				</ul>
			</div>
		</div>
		<div id="pinDiv">
			<div class="buttonGroup">
				<button id="pinningOps" class='pill' onclick='dropPill(this, "Pinning");'>Pinning ▾</button>
				<ul class='menu right'>
				<li><a href='javascript:pinAll();unsavedChanges=true' id='pinUnpinAll'>Pin All</a></li>
				<li><a href='javascript:unPinAll();unsavedChanges=true'>Unpin All</a></li>
				<li><a href='javascript:toggleSelectedPin();unsavedChanges=true'>Toggle Selected Pin (p)</a></li>
				</ul>
			</div>
		</div>
		<div id="editDiv">
			<div class="buttonGroup">
				<button id="editOps" class='pill' onclick='dropPill(this, "Edit");'>Edit ▾</button>
				<ul class='menu right'>
					<li><a href="javascript:zoomToFit();">Zoom To Fit</a></li>
					<li><a href="javascript:zoomReset();">Zoom Reset</a></li>
					<li><a href="javascript:staticLoadsToHouses();unsavedChanges=true;">Static Loads to Houses</a></li>
					<li><a id='scadaLoad' href='javascript:showModal("scadaLoadshapes");'>Scada Loadshapes...</a></li>
					<li><a id='amiLoad' href='javascript:showModal("amiLoadshapes");'>Add AMI Profiles...</a></li>
					<li><a href='javascript:showModal("findModal");'>Find...</a></li>
					<li><a href='javascript:showModal("layoutModal");'>Layout...</a></li>
					<li><a href='javascript:showModal("massAddModal");getComponentsList("add");'>Mass Add...</a></li>
					<li><a href='javascript:clearTextBoxes();showModal("massEditModal");getComponentsList("edit");'>Mass Edit...</a></li>
					<li><a href='javascript:showModal("attachmentsModal");getAttachmentsList();'>Attachments...</a></li>
					<li><a href='javascript:showModal("climateModal");'>Climate...</a></li>
					<li><a href='javascript:showModal("anonymizeModal");'>Anonymization...</a></li>
				</ul>
			</div>
		</div>
		<div id="addDiv">
			<div class="buttonGroup">
				<button id="addOps" class='pill' onclick='dropPill(this, "Add");'>Add ▾</button>
				<ul id='newObjectMenu' class='menu right' style="">
			</div>
		</div>
		<div id="helpDiv">
			<div class="buttonGroup">
				<button id="addOps" class='pill' type = 'submit'><a id= 'helpButton' href = 'https://github.com/dpinney/omf/wiki/Tools-~-gridEdit' target = '_blank'>Help</a></button>
			</div>
		</div>
	</div>
	<div id="selected">
		<table id="selHead">
			<tr>
			<td id="objmod" colspan="2"></td>
			<td id="value" colspan="2"></td>
			</tr>
		</table>
		<table id="daButtons">
			<tr id="editButtonRow">
			<td colspan="4"><button id="editButton">Edit</button></td>
			</tr>
			<tr id="otherButtons">
			<td><button id="deleteObject" class="deleteButton">Delete</button></td>
			<td><button id="addAttribute">Add Attribute</button></td>
			<td><button id="saveObject" onclick="javascript:unsavedChanges=true">Save</button></td>
			<td><button id="cancelButton">Cancel</button></td>
			</tr>
		</table>
		<div id="selBody">
			<table id="body">
			</table>
		</div>
	</div>
</div>
<div id='scadaLoadshapes' class='modal'>
<!-- Turn below into a modal -->
	<div class='modalContent' style='width:350px'>
		<form onsubmit='scadaLoadshape();' action='/scadaLoadshape/{{owner}}/{{feederName}}' id='scadaLoadshape' enctype='multipart/form-data' method='post'>
			<input type='hidden' name='_csrf_token' value='{{csrf_token()}}'/>
			<input type='hidden' id='feederNum' name='feederNum' value='{{feederNum}}'/>
			<input type='hidden' id='modelName' name='modelName' value='{{modelName}}'/>
			<table class='importOptions'>
			<th>Scada Loadshapes</th><th style='float:right'><a href='https://github.com/dpinney/omf/wiki/Tools-~-gridEdit#scada-loadshapes' target='_blank'>Format Help</a></th>
				<tr>
					<td>File containing Scada load data (.csv)</td>
					<td><input type='file' id='scadaFile' name='scadaFile' accept='.csv' required/></td>
				</tr>
				<tr>
					<td colspan='100%'>Note: Model "Simulation Start Date" should lie within the Scada load's dates</td>
				</tr>
				<tr>
					<td><a id='modalCancel' href='#' onclick='closeModal("scadaLoadshapes")' style='text-align:center; font-size:10pt'>Cancel</a></td>
					<td><input type='submit' value='Import' style='min-width:45px'/></td>
				</tr>
			</table>
		</form>
		<iframe class='hide_me' id='take_the_reload' name='take_the_reload' style='width:0px; height:0px'></iframe>
	</div>
</div>
<div id='amiLoadshapes' class='modal'>
<!-- Turn below into a modal -->
	<div class='modalContent' style='width:350px'>
		<form onsubmit='loadModelingAmi();' action='/loadModelingAmi/{{owner}}/{{feederName}}' id='amiLoadshape' enctype='multipart/form-data' method='post'>
			<input type='hidden' name='_csrf_token' value='{{csrf_token()}}'/>
			<input type='hidden' id='feederNum' name='feederNum' value='{{feederNum}}'/>
			<input type='hidden' id='modelName' name='modelName' value='{{modelName}}'/>
			<table class='importOptions'>
			<th>AMI Profiles</th><th style='float:right''><a href='https://github.com/dpinney/omf/wiki/Tools-~-gridEdit' target='_blank'>Format Help</a></th>
				<tr>
					<td>File containing AMI load data (.csv)</td>
					<td><input type='file' id='amiFile' name='amiFile' accept='.csv' required/></td>
				</tr>
				<tr>
					<td colspan='100%'>Note: Model "Simulation Start Date" should lie within the AMI profiles's dates</td>
				</tr>
				<tr>
					<td><a id='modalCancel' href='#' onclick='closeModal("amiLoadshapes")' style='text-align:center; font-size:10pt'>Cancel</a></td>
					<td><input type='submit' value='Import' style='min-width:45px'/></td>
				</tr>
			</table>
		</form>
		<iframe class='hide_me' id='take_the_reload' name='take_the_reload' style='width:0px; height:0px'></iframe>
	</div>
</div>
<div id='blankFeederModal' class='modal'>
	<div class='modalContent' id='blankModal'>
		<form onsubmit='event.preventDefault();return startConversion("feederNameNew",1);' action='/newBlankFeeder/{{owner}}' id='newfeeder' enctype='multipart/form-data' method='post'>
			<input type='hidden' name='_csrf_token' value='{{csrf_token()}}'/>
			<input type='hidden' id='feederNum' name='feederNum' value='{{feederNum}}'/>
			<input type='hidden' id='modelName' name='modelName' value='{{modelName}}'/>
			<table class='importOptions'>
			<th>Blank Feeder</th>
				<tr>
					<td>Name</td>
					<td><input type='text' id='feederNameNew' name='feederNameNew' required/></td>
				</tr>
				<tr>
					<td><a id='modalCancel' href='#'' onclick='closeModal("blankFeederModal")' style='text-align:center; font-size:10pt'>Cancel</a></td>
					<td><input type='submit' value='Create' style='min-width:45px'/></td>
				</tr>
			</table>
		</form>
	</div>
</div>
<div id='milSoftModal' class='modal'>
	<div class='modalContent' id='milModal' style='width:350px'>
		<form onsubmit='event.preventDefault();return startConversion("feederNameM",2);' action='/milsoftImport/{{owner}}' id='milsoft' enctype='multipart/form-data' method='post'>
			<input type='hidden' name='_csrf_token' value='{{csrf_token()}}'/>
			<input type='hidden' id='feederNum' name='feederNum' value='{{feederNum}}'/>
			<input type='hidden' id='modelName' name='modelName' value='{{modelName}}'/>
			<table class='importOptions'>
			<th>Milsoft Conversion</th>
				<tr>
					<td>Name</td>
					<td><input type='text' id='feederNameM' name='feederNameM' required/></td>
				</tr>
				<tr>
					<td>Data File (.std)</td>
					<td><input type='file' name='stdFile' accept='.std' required/></td>
				</tr>
				<tr>
					<td>Equipment File (.seq)</td>
					<td><input type='file' name='seqFile' accept='.seq' required/></td>
				</tr>
				<tr>
					<td><a id='modalCancel' href='#' onclick='closeModal("milSoftModal")' style='text-align:center; font-size:10pt'>Cancel</a></td>
					<td><input type='submit' value='Import' style='min-width:45px'/></td>
				</tr>
			</table>
		</form>
		<iframe class='hide_me' id='take_the_reload' name='take_the_reload' style='width:0px; height:0px'></iframe>
	</div>
</div>
<div id='gridlabModal' class='modal'>
	<div class='modalContent' id='gridlabModal' style='width:350px'>
		<form onsubmit='event.preventDefault();return startConversion("feederNameG",3);' action='/gridlabdImport/{{owner}}' id='gridlabd' enctype='multipart/form-data' method='post'>
			<input type='hidden' name='_csrf_token' value='{{csrf_token()}}'/>
			<input type='hidden' id='feederNum' name='feederNum' value='{{feederNum}}'/>
			<input type='hidden' id='modelName' name='modelName' value='{{modelName}}'/>
			<table class='importOptions'>
			<th>GridLab-D Conversion</th>
				<tr>
					<td>Name</td>
					<td><input type='text' id='feederNameG' name='feederNameG' required/></td>
				</tr>
				<tr>
					<td>Data File (.glm)</td>
					<td><input type='file' id='csvFile' name='glmFile' accept = '.glm' required/></td>
				</tr>
				<tr>
					<td><a id='modalCancel' href='#'' onclick='closeModal("gridlabModal")' style='text-align:center; font-size:10pt'>Cancel</a></td>
					<td><input type='submit' value='Import' style='min-width:45px'/></td>
				</tr>
			</table>
		</form>
		<iframe class='hide_me' id='take_the_reload' name='take_the_reload' style='width:0px; height:0px'></iframe>
	</div>
</div>
<div id='cymeModal' class='modal'>
	<div class='modalContent' id='cymeModalContent' style='width:350px'>
		<form onsubmit='event.preventDefault();return startConversion("feederNameC",4);' action='/cymeImport/{{owner}}' id='cyme' enctype='multipart/form-data' method='post'>
			<input type='hidden' name='_csrf_token' value='{{csrf_token()}}'/>
			<input type='hidden' id='feederNum' name='feederNum' value='{{feederNum}}'/>
			<input type='hidden' id='modelName' name='modelName' value='{{modelName}}'/>
			<table class='importOptions'>
			<th>Cyme Conversion</th>
				<tr>
					<td>Name</td>
					<td><input type='text' id='feederNameC' name='feederNameC' required/></td>
				</tr>
				<tr>
					<td>Network File (.mdb)</td>
					<td><input type='file' name='mdbNetFile' accept='.mdb' required/></td>
				</tr>
				<tr>
					<td><a id='modalCancel' href='#' onclick='closeModal("cymeModal")' style='text-align:center; font-size:10pt'>Cancel</a></td>
					<td><input type='submit' value='Import' style='min-width:45px'/></td>
				</tr>
			</table>
		</form>
		<iframe class='hide_me' id='take_the_reload' name='take_the_reload' style='width:0px; height:0px'></iframe>
	</div>
</div>
<div id='loadModal' class='modal'>
	<div class='modalContent' id='loadModalContent' style='width:850px'>
		<table>
			<tr>
				<th>Public Feeders</th>
				<th>My Feeders</th>
			</tr>	
			<tr>
				<td style='width:425px; padding-bottom:10px'>
					<ul class='menu' style='position:relative; background-color:#fefefe; border:0px; box-shadow:0 0 0; -web-kit-box-shadow:0 0 0'>	
						<li><p style='font-weight:bold; margin:4px 0 0 20px'><a href='javascript:showDiv("pubFeeders","225px","20px")'>Public Feeders</a></p></li>
						<div id='pubFeeders'>
							<div style='overflow-y:auto; overflow-x:auto; max-height:250px'>
								{% for feeder in publicFeeders %}
									{% if feeder.name != feederName %}
										<li>
										<a href='#' onclick='loadFeeder("{{feeder.name}}","{{feeder.model}}","public")'>
										&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
										<strong>{{feeder.name}}</strong> from
										<br>
										&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
										&#8220;{{feeder.model}}&#8221;
										</a>
										</li>
									{% endif %}
								{% endfor %}
							</div>
						</div>
					</ul>
				</td>
				<td style='width:425px'>
					<ul class='menu' style='position:relative; background-color:#fefefe; border:0px; box-shadow:0 0 0; -web-kit-box-shadow:0 0 0'>	
						<div id='myFeeders'>
							<div style='overflow-y:auto; overflow-x:auto; max-height:250px'>
								{% for feeder in feeders %}
									{% if feeder.name != feederName %}
										<li>
										<a href='#' onclick='loadFeeder("{{feeder.name}}","{{feeder.model}}","{{owner}}")'>
										&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
										Model &nbsp; &#8220;{{feeder.model}}&#8221;
										<br>
										&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
										Feeder <strong>{{feeder.name}}</strong>
										</a>
										</li>
									{% endif %}
								{% endfor %}
							</div>
						</div>
					</ul>
				</td>
			</tr>
		</table>
		<a id='modalCancel' href='#' onclick='closeModal("loadModal")' style='text-align:center; font-size:10pt'>Cancel</a>
	</div>
</div>
<div id='findModal' class='modal'>
	<div class='modalContent' id='findModalContent' style='width:200px'>
		<table class='importOptions' style='padding:4px; word-wrap:break-word'>
			<tr>
				<td>Term</td>
				<td><input id='searchTerm' type='text'></td>
			</tr>
			<tr>
				<td><button style='width:75px' onclick='backButton()'>Back</button></td>
				<td id='searchHitCount' style='font-size:8pt; text-align:center'></td>
			</tr>
			<tr>
				<td><button style='width:75px' onclick='findPrevious()'>Previous</button></td>
				<td><button style='width:75px' onclick='findNext()'>Next</button></td>
			</tr>
			<tr>
				<td><button style='width:75px' onclick='closeModal("findModal")'>Cancel</button></td>
			</tr>
		</table>
	</div>
</div>
<div id='layoutModal' class ='modal'>
	<div class='modalContent' id='layoutModalContent' style='width:200px'>
		<table class='importOptions' style='padding:4px; word-wrap:break-word'>
			<tr>
				<td>GraphNodes</td>
				<td id='nodesBox'></td>
			</tr>
			<tr>
				<td colspan=2 style='padding:0px 0px 10px 0px'>
				<div id='nodesPercShown' style='background:black; width:30%; height:3px; display:inline-block'></div><div id='nodesPercHidden' style='background:gray; width:70%;height:3px; display:inline-block'></div>
				</td>
				<tr>
				<tr>
			<td>Gravity</td>
			<td><input id='gravityBox' type='text'></td>
				</tr>
				<tr>
			<td>Theta</td>
			<td><input id='thetaBox' type='text'></td>
				</tr>
				<tr>
			<td>Friction</td>
			<td><input id='frictionBox' type='text'></td>
				</tr>
				<tr>
			<td>Link Strength</td>
			<td><input id='linkStrengthBox' type='text'></td>
				</tr>
				<tr>
			<td>Link Distance</td>
			<td><input id='linkDistanceBox' type='text'></td>
				</tr>
				<tr>
			<td>Charge</td>
			<td><input id='chargeBox' type='text'></td>
				</tr>
				<tr>
			<td style='padding-top:10px'><button onclick='closeModal("layoutModal")'>Cancel</button></td>
			<td style='padding-top:10px'><button onclick='layoutMenuApply();unsavedChanges=true'>Apply</button></td>
				</tr>
		</table>
	</div>
</div>
<div id='massAddModal' class='modal'>
	<div class='modalContent' id='massAddModalContent' style='width:330px'>
		<table class='importOptions' style='width:330px'>
			<th>Mass Add</th>
			<tr>
				<td>Add component:</td>
				<td>
					<form method='post'>
						<select name='componentNameNew' id='componentNameNew'></select>
					</form>
				</td>
			</tr>
			<tr>
				<td>To each:</td>
				<td>
					<form method='post'>
						<select name='attachTypeNew' id='attachTypeNew'></select>
					</form>
				</td>
			</tr>
			<tr>
				<td>With probability for each attachment (float between 0.0 and 1.0):</td>
				<td><input type='text' id='percNew' name='percNew' pattern='^0\.\d+|1(\.0+)?$' value='1.0' required/></td>
			</tr>
			<tr>
				<td style='padding-top:10px'>
					<button onclick='closeModal("massAddModal")'>Cancel</button>
				</td>
				<td style='padding-top:10px'>
					<button onclick='addXatY();unsavedChanges=true;closeModal("massAddModal")'>Apply</button>
				</td>
			</tr>
		</table>
	</div>
</div>
<div id='massEditModal' class='modal'>
	<div class='modalContent' id='massEditModalContent' style='width:330px'>
		<table class='importOptions'>
			<th>Mass Edit</th>
			<tr>
				<td>For each object of type:</td>
				<td>
					<form method='post'>
						<select name='attachTypeNewEdit' id='attachTypeNewEdit'></select>
					</form>
				</td>
			</tr>
			<tr>
				<td>and attribute:</td>
				<td><input type='text' id='attributeEdit' name='attributeEdit' required></td>
			</tr>
			<tr>
				<form id='radioForm' action="">
					<td><input type="radio" name="attrEdit" value="addVal"> Add to value </td><td><input type='text' id='addValue' name='addValue' pattern='^0\.\d+|1(\.0+)?$' required/></td>
			</tr>
			<tr>
					<td><input type="radio" name="attrEdit" value="deleteAttr"> Delete Attribute </td>
			</tr>
					<td><input type="radio" name="attrEdit" value="changeTo"> Change To </td><td><input type='text' id='changeValue' name='changeValue' pattern='^0\.\d+|1(\.0+)?$' required/></td>
			<tr>		
					<td><input type="radio" name="attrEdit" value="multBy"> Multiply By </td><td><input type='text' id='multValue' name='multValue' pattern='^0\.\d+|1(\.0+)?$' required/></td>
			</tr>
			<tr>
					<td>and add</td><td><input type='text' id='addedVal' name='addedVal' pattern='^0\.\d+|1(\.0+)?$' required/></td>
			</tr>
			<tr>
					<td>Or</td>
			</tr>
			<tr>
				<td><input type="radio" name="attrEdit" value="addAttr"> Add attribute:</td>
				<td><input type='text' id='newAttr' name='newAttr' required></td>
			</tr>
			<tr>
				<td>With value:</td>
				<td><input type='text' id='newAttrVal' name='newAttrVal' pattern='^0\.\d+|1(\.0+)?$' required/></td>
			</tr>
				</form>
			
			<tr>
				<td style='padding-top:10px'>
					<button onclick='closeModal("massEditModal")'>Cancel</button>
				</td>
				<td style='padding-top:10px'>
					<button onclick='editObjects();unsavedChanges=true;closeModal("massEditModal")'>Apply</button>
				</td>
			</tr>
		</table>
	</div>
</div>
<div id='attachmentsModal' class='modal'>
	<div class='modalContent' id='attachmentsModalContent' style='width:250px'>
		<table class='importOptions'>
			<tr>
				<td>
					<form method='post'>
						<select name='attachmentsList' id='attachmentsList' style='width:230px'></select>
					</form>
				</td>
			</tr>
			<tr>
				<td style='padding-top:10px'>
					<button onclick='closeModal("attachmentsModal")'>Cancel</button>
					<button onclick='editAttachment();closeModal("attachmentsModal")'>Select</button>
				</td>
			</tr>
		</table>
	</div>
</div>
<div id='editAttachmentModal' class='modal'>
	<div class='modalContent' id='editAttachmentModalContent' style='width:500px'>
		<table class='importOptions' style='width:400px'>
			<tr>
				<td style='font-weight:bold; font-size:14pt' id='attachmentSelect'></td>
			</tr>
			<tr>
				<td>
					<textarea rows='25' cols='80' id='editAttachmentBox' name='editAttachmentBox' style='width:490px'></textarea>
				</td>
			</tr>
			<tr>
				<td style='padding-top:10px'>
					<button onclick='closeModal("editAttachmentModal")'>Cancel</button>
					<button onclick='saveAttachment();unsavedChanges=true;closeModal("editAttachmentModal")'>Save</button>
				</td>
			</tr>
		</table>
	</div>
</div>
<div id='climateModal' class='modal'>
	<div class='modalContent' id='climateModalContent' style='width:300px'>
		<div style='font-weight:bold; font-size:14pt'>Climate Change</div>
			<form onsubmit='climateChange();' action='/climateChange/{{owner}}/{{feederName}}' id='climateChange' enctype='multipart/form-data' method='post'>
				<input type='hidden' name='_csrf_token' value='{{csrf_token()}}'/>
				<input type='hidden' id='modelName' name='modelName' value='{{modelName}}'/>
				<table class='importOptions'>
					<th>
						<input type='radio' id='historicalOption' name='climateImportOption' value='historicalImport'>
						<label for='historicalImport'>Historical Weather</label>
					</th>
					<tr>
						<td style='width:175px'>
							<label for='startDate'>Start Date (YYYY-MM-DD):</label>	
						</td>
						<td>
							<input style='width:5px' type='text' id='startDate' name='startDate' pattern='^\d{4}-\d{2}-\d{2}$'>
						</td>
					</tr>
					<tr>
						<td style='width:175px'>
							<label for='endDate'>End Date (YYYY-MM-DD):</label>
						</td>
						<td>
							<input style='width:5px' type='text' id='endDate' name='endDate' pattern='^\d{4}-\d{2}-\d{2}$'>
						</td>
					</tr>
					<tr>
						<td style='width:175px'>
							<label for='airport'>Airport Code:</label>
						</td>
						<td>
							<input style='width:5px' type='text' id='airport' name='airport' pattern='^[A-Z]{3}$'>
						</td>
					</tr>
					<th>
						<input type='radio' id='tmyOption' name='climateImportOption' value='tmyImport'>
						<label for='tmyImport'>tmy Import</label>
					</th>
					<tr>
						<td style='width:175px'>
							<label for='zipcode'>Zip Code:</label>
						</td>
						<td>
							<input style='width:5px' type="text" id="zipCode" name="zipCode" pattern='^\d{5}$'>
						</td>
					</tr>
					<tr>
						<td style='width:175px'>
							<button onclick='event.preventDefault();closeModal("climateModal")'>Cancel</button>
						</td>
						<td>
							<input type='submit' value='Apply' style='min-width:45px'/>	
						</td>
					</tr>
				</table>
			</form>
		</div>
	</div>
</div>
<div id='anonymizeModal' class='modal'>
	<div class='modalContent' id='anonymizeModalContent' style='width:475px'>
		<div style='font-weight:bold; font-size:14pt'>Anonymization</div>
		<br>
		<form onsubmit='anonymize();' action='/anonymize/{{owner}}/{{feederName}}' id='anonymize' enctype='multipart/form-data' method='post'>
			<input type='hidden' name='_csrf_token' value='{{csrf_token()}}'/>
			<input type='hidden' id='modelName' name='modelName' value='{{modelName}}'/>
			<div id='anonymizeInputs' align='left'>
				<div style='font-weight:bold; font-size:12pt'>Names and Labels:</div>
				<input type='radio' id='noChange' name='anonymizeNameOption' value='noChange' checked>
				<label for='noChange'>No Change</label>
				<br>
				<input type='radio' id='pseudonymize' name='anonymizeNameOption' value='pseudonymize'>
				<label for='pseudonymize'>Pseudonymize</label>
				<br>
				<input type='radio' id='randomize' name='anonymizeNameOption' value='randomize'>
				<label for='randomize'>Randomize</label>
				<br>
				<br>
				<div style='font-weight:bold; font-size:12pt'>Locations:</div>
				<input type='radio' id='noChange' name='anonymizeLocationOption' value='noChange' checked>
				<label for='noChange'>No Change</label>
				<br>
				<input type='radio' id='translation' name='anonymizeLocationOption' value='translation'>
				<label for='translation'>Translate <input style='width:1px' type='text' id='translateRight' name='translateRight'>[ft] to right and <input style='width:1px' type='text' id='translateUp' name='translateUp'>[ft] up and Rotate <input style='width:1px' type='text' id='rotate' name='rotate'>[degrees]</label>
				<br>
				<input type='radio' id='randomize' name='anonymizeLocationOption' value='randomize'>
				<label for='randomize'>Random (Force Layout)</label>
				<br>
				<br>
				<div style='font-weight:bold; font-size:12pt'>Electrical Properties:</div>
				<input type='checkbox' id='modifyLengthSize' name='modifyLengthSize' value='modifyLengthSize'>
				<label for='modifyLengthSize'>Modify conductor length and cable size</label>
				<br>
				<input type='checkbox' id='smoothLoadGen' name='smoothLoadGen' value='smoothLoadGen'>
				<label for='smoothLoadGen'>Smooth loads and generators</label>
				<br>
				<input type='checkbox' id='shuffleLoadGen' name='shuffleLoadGen' value='shuffleLoadGen'>
				<label for='shuffleLoadGen'>Shuffle loads and generators <input style='width:1px' type='text' id='shufflePerc' name='shufflePerc'>[%]</label>
				<br>
				<input type='checkbox' id='addNoise' name='addNoise' value='addNoise'>
				<label for='addNoise'>Add Noise <input style='width:1px' type='text' id='noisePerc' name='noisePerc'>[%]</label>
				<br>
				<br>
				<button onclick='event.preventDefault();closeModal("anonymizeModal")'>Cancel</button>
				<input type='submit' value='Apply' style='min-width:45px'>
			</div>
		</form>
	</div>
</div>

<!-- ******** Javascript ******** -->

<script>clickCloseEvent("Add","addOps");</script>
<script>clickCloseEvent("Edit","editOps");</script>
<script>clickCloseEvent("Pinning","pinningOps");</script>
<script>clickCloseEvent("Folding","foldingOps");</script>
<script>clickCloseEvent("Find","findOps");</script>
<script>clickCloseEvent("Layout","layoutSelector");</script>
<script>clickCloseEvent("File","fileOps");</script>
<!-- Reposition the editor table based on window size.
Run it once then on all windoe resize events. -->
<script type="text/javascript">
var width = $(window).innerWidth();
$("#selected").css("marginLeft", width-370+"px");
window.onresize = function() {
var width = $(window).innerWidth();
if (width > 1000 ){$("#selected").css("marginLeft", width-370+"px");}
}

var unsavedChanges = false;
var lastFeederName = "{{ feederName }}";
var isChrome = navigator.userAgent.toLowerCase().indexOf('chrome') > -1;
if(!isChrome){alert("This editing interface is only supported in the Chrome browser. Proceed at your own risk.")}


// GLOBAL VARIABLES:

feeder = '{{ feederName }}'
var w = 1000
var h = 1000
var tree
var components
var zoomer = d3.behavior.zoom()
zoomer.scaleExtent([0.1, 30])
var conversion = '';

// Graph size global variable
var NODE_STROKE_WIDTH = 0.4
var LINE_LINK_STROKE_WIDTH = 3 /5
var LINE_PARENTCHILD_STROKE_WIDTH = 3/5
var LINE_SELECTED_STROKE_WIDTH = 3/5
var NODE_SELECTED_STROKE_WIDTH = 4/5
var NODE_CIRCLE_RADIUS = 3/5
var PINNED_NODE_STROKE_SIZE = 1/5
var PINNED_NODE_CIRCLE_RADIUS = 0.5/5
var UNPINNED_NODE_CIRCLE_RADIUS = 3/5
var TEXT_FONT_SIZE = 35

// SCALE DRAW GLOBAL LAYOUT VARIABLES
var xScale = 1, yScale = 1;
var width = window.screen.availWidth-45;
var height = window.screen.availHeight-100;

// CREATE LAYOUT
var body = d3.select('body')
	.append('svg:svg')
	.attr('id', 'graphSvg')
	.on('click', onSvgBlankCanvasClick)
	.attr('viewBox', '0 0 ' + window.innerWidth + ' ' + window.innerHeight)
	.attr("preserveAspectRatio", "xMinYMin meet")
	.call(zoomer.on('zoom', zoomRedraw));

// add powergrid to the upper layer
var vis = body.append('svg:g')
	.attr('id', 'powerGrid')
// add marker data
vis.append('svg:defs').selectAll('marker')
	.data(['transformerMarker', 'regulatorMarker', 'fuseMarker'])
	.enter().append('svg:marker')
	.attr('id', String)
	.attr('viewBox', '0 0 15 15')
	.attr('refX', -10)
	.attr('refY', 6)
	.attr('markerUnits','strokeWidth')
	.attr('markerWidth', 3)
	.attr('markerHeight', 3)
	.attr('stroke', 'gray')
	.attr('stroke-width', 1)
	.attr('fill', 'black')
	.attr('orient', 'auto')
	.append('svg:circle')
	.attr('r', 5)
	.attr('cx', 6)
	.attr('cy', 6);
vis.selectAll('marker')
	.append('svg:text')
	.attr('class','markerText')
	.attr('x',4)
	.attr('y',8)
	.text(function (d) {return d[0].toUpperCase()});
// add a layer to force the links to the bottom.
vis.append('svg:g').attr('id','linkLayer');
var force = d3.layout.force()
	.linkDistance(30)
	.size([w, h]);

// D3 FORCE GLOBAL VARIABLES.
var nodes = force.nodes();
var links = force.links();
var hiddenNodes = [];
var hiddenLinks = [];
// Public variables for global functions
var prevObjName;
// Public variable to hold the current search state. TODO: put in a closure.
var searchCursor;
var oldSearchTerm;

// INIT FUNCTIONS FOLLOW:
d3.json('/getComponents/', function (json){components=json;fillComponentMenu()})
var apiAddress = "/feederData/{{ owner }}/{{ modelName }}/{{ feederName }}/{{ modelFeeder }}"
d3.json(apiAddress, function (json) {
	tree = json['tree']
	attachments = json['attachments']
	// Regenerate the layout from the saved layout. For some insane reason, just cloning the list doesn't work.
	nodepop = json['nodes']
	while (nodepop.length != 0) {nodes.push(nodepop.pop())}
	linkpop = json['links']
	while (linkpop.length != 0) {links.push(linkpop.pop())}
	hiddenNodePop = json['hiddenNodes']
	while (hiddenNodePop.length != 0) {hiddenNodes.push(hiddenNodePop.pop())}
	hiddenLinkPop = json['hiddenLinks']
	while (hiddenLinkPop .length != 0) {hiddenLinks.push(hiddenLinkPop.pop())}
	//Gotta go through and make the links connect to their actual source and target objects. BAD DESIGN, D3!
	for (li=0;li<links.length;li++) {
		sourceName = links[li].source.name
		targetName = links[li].target.name
		links[li].source = nodes[findIndex(nodes,'name',sourceName)]
		links[li].target = nodes[findIndex(nodes,'name',targetName)]
	}
	for (li2=0;li2<hiddenLinks.length;li2++) {
		sourceName = hiddenLinks[li2].source.name
		targetName = hiddenLinks[li2].target.name
		realSource = nodes[findIndex(nodes,'name',sourceName)]
		realSourceHidden = hiddenNodes[findIndex(hiddenNodes,'name',sourceName)]
		realTarget = nodes[findIndex(nodes,'name',targetName)]
		realTargetHidden = hiddenNodes[findIndex(hiddenNodes,'name',targetName)]
		if (undefined == realSource) {hiddenLinks[li2].source = realSourceHidden} else {hiddenLinks[li2].source = realSource}
		if (undefined == realTarget) {hiddenLinks[li2].target = realTargetHidden} else {hiddenLinks[li2].target = realTarget}
	}
	// Regenerate the layout variables:
	// TODO: make this whole layout variables code much less hackish. We get/set like 5 different ways and times in this file.
	if (undefined != json['layoutVars']) {
		function safeSet(value) {
			if (json['layoutVars'].hasOwnProperty(value)) {force[value](json['layoutVars'][value])}
		}
		safeSet('gravity')
		safeSet('theta')
		safeSet('friction')
		safeSet('linkStrength')
		safeSet('linkDistance')
		safeSet('charge')
	}
	// set scale range
	options = {
		"xmax" : window.innerWidth / xScale,
		"xmin" : 0,
		"ymax" : window.innerHeight / yScale,
		"ymin" : 0,
	}
	// And go at it:
	unsavedChanges = draw()
	layoutMenuInit()
})

//**********************************************************
//******** ONLOAD CONVERSION/CALIBRATION CHECKING **********
//**********************************************************

function showProgress(){
	// Show loading progress.
	pinAll()
	showProgressDialog('spinner', 'Loading Feeder', 'loading');
	checkConv()
}

function checkConv(){
	$.ajax({
		url: '/checkConversion/{{modelName}}'
	}).done(function (data) {
		if (data.exists == true) {
			showProgressDialog('spinner', 'Converting Feeder', 'conversion');
			checkConversion()
		}
	})
}

function checkConversion() {
	var conversionStatus = 'converting'
	// Check every 5 seconds for a feeder & refresh.
	var setInterval = window.setInterval(function pingAPI() {
		$.ajax({
			url: '/checkConversion/{{modelName}}'
		}).done(function (data) {
			if (data.exists) {
				conversionStatus = 'converting'
			}
			else if (data == 'glmError') {
				alert('The glm file used is incorrectly formatted.')
				removeProgressDialog()
				conversionStatus = 'done'
				window.clearInterval(setInterval)
				return false;
			}
			else if (data == 'milError') {
				alert('The .std and .seq files used are incorrectly formatted.')
				removeProgressDialog()
				conversionStatus = 'done'
				window.clearInterval(setInterval)
				return false;
			}
			else {
				conversionStatus = 'done';
			}
		})
		if (conversionStatus == 'done') {
			alert('Conversion complete.')
			window.location.reload();
		}
		console.log('Converting...')
		return pingAPI;
	}, 5000);
}

function startProcess(startUrl) {
	// Start a long running process using startUrl.
	$.ajax({
		url: startUrl
	}).done(function (data) {
		console.log(data)
	})
}
function startCheck(checkUrl) {
	// Do get requests to checkUrl for long running process monitoring.
	window.setInterval(function checkAPI() {
		$.ajax({
			url: checkUrl
		}).done(function (data) {
			console.log(data)
			if (data.exists == true) {
				// Still processing.
			} else if (data.exists == false) {
				// Success processing.
				removeProgressDialog()
				window.location.reload();
			} else {
				// Error processing.
				alert(data)
				removeProgressDialog()
				window.location.reload();
			}
		})
	}, 5000)
}

function scadaLoadshape() {
	showProgressDialog('spinner', 'Calibrating Feeder', 'calibrating')
	startProcess('/scadaLoadshape/{{owner}}/{{feederName}}')
	startCheck('/checkScadaLoadshape/{{modelName}}')
}

function loadModelingAmi() {
	showProgressDialog('spinner', 'Loading Ami Data', 'calibrating')
	startProcess('/loadModelingAmi/{{owner}}/{{feederName}}')
	startCheck('/checkLoadModelingAmi/{{modelName}}')
}

function climateChange() {
	showProgressDialog('spinner', 'Adding climate data to model')
	startProcess('/climateChange/{{owner}}/{{feederName}}')
	startCheck('/checkClimateChange/{{owner}}/{{modelName}}')
}

function anonymize() {
	showProgressDialog('spinner', 'Anonymizing Feeder')
	startProcess('/anonymize/{{owner}}/{{feederName}}')
	startCheck('/checkAnonymize/{{owner}}/{{modelName}}')
}

function showProgressDialog(progressType, dialogMessage, cancelType) {
	// Make the elements.
	background = document.createElement('div')
	background.id = 'progressBackground'
	background.style.zIndex = '9998'
	progContent = document.createElement('div')
	progContent.id = 'progressContent'
	progContent.style.zIndex = '9999'
	progressText = document.createElement('h2')
	progressText.id = 'progressText'
	progressText.textContent = dialogMessage
	document.body.appendChild(background)
	document.body.appendChild(progContent)
	// If progressType type is spinner create and show the spinner
	if (progressType == 'spinner'){
		spinner = document.createElement('img')
		spinner.src = '/static/spinner.gif'
		progContent.appendChild(spinner)
		progContent.appendChild(progressText)
		var cancelBtn = document.createElement("BUTTON");
		var t = document.createTextNode("cancel");
		cancelBtn.style.marginTop = '5px';
		cancelBtn.style.background= 'crimson'
		cancelBtn.appendChild(t);
		progContent.appendChild(cancelBtn);
	}
	// If progressType type is bar create and show the bar
	else if (progressType == 'bar'){
		progBar = document.createElement('div')
		progBar.id = 'progBar'
		progColor = document.createElement('div')
		progColor.id = 'progColor'
		progBar.appendChild(progColor)
		progContent.appendChild(progBar)
		progContent.appendChild(progressText)
	}
	// If cancelType is not none, add an onclick even to the cancel button to cancel the calibration or conversion
	if (cancelType != 'none') {
		cancelType = (typeof cancelType === 'undefined') ? 'no' : cancelType;
		cancelBtn.onclick = function() {
			if (cancelType == 'conversion'){
				if (confirm('Are you sure you want to cancel the conversion?')) {
					newfeeder.submit();
				}
			}
			else if(cancelType == 'calibrating'){
				if (confirm('Are you sure you want to cancel the calibration?')){
					var modelName = gebi("modelNameHeader").innerHTML
					$.ajax({
							url: "/cancelScadaLoadshape/" + modelName
						}).done(function (data) {
							
						})
					removeProgressDialog()
				}
			}
			else if(cancelType == 'none'){
				cancelBtn.style.display = 'none'
			}
			else
			{
				// stop rendering feeder, show file menu, etc.y
				removeProgressDialog()
			}
		};
	}	
}

function removeProgressDialog() {
	if (gebi('progressBackground')!=null)
		document.body.removeChild(gebi('progressBackground'))
	if (gebi('progressContent')!=null)
		document.body.removeChild(gebi('progressContent'))
}

function importFiles(convMethod, feederNameID){
	gebi(convMethod).submit();
	showProgressDialog('spinner','Converting Feeder','conversion');
	setTimeout(checkConversion, 5000); // Set an initial delay because it takes time to create conversion files.
}

//*********************************************
// MODEL SAVING, LEFT TOOLBOX HANDLER FUNCTIONS
//*********************************************
/**
 * Post to new saved feeder.
 * @param  {string} name feeder name
 * @param  {string} user username
 */
function savePoster(name, modelName, user) {
	feederObject = {
		tree: tree,
		nodes: nodes,
		hiddenNodes: hiddenNodes,
		links: links,
		hiddenLinks: hiddenLinks,
		layoutVars: {
			'gravity': force.gravity(),
			'theta': force.theta(),
			'friction': force.friction(),
			'linkStrength': force.linkStrength(),
			'charge': force.charge(),
			'linkDistance': force.linkDistance()
		},
		attachments: attachments
	}
	payload = {
		'name': name,
		'feederObjectJson': JSON.stringify(feederObject),
		"_csrf_token": "{{ csrf_token() }}",
		ref: "{{ ref }}"
	}
	unsavedChanges=false
	post_to_url("/saveFeeder/" + user + "/" + modelName + "/" + name, payload)
}

/**
 * Save the modified feeder data, and cover the one already in filesystems.
 */
function saveFeeder() {
	gebi("fileOps").click();
	savePoster("{{ feederName }}", "{{ modelName }}", "{{ owner }}")
	alert("Data saved.")
}

/**
 * Rename the feeder.
 */
function renameFeeder() {
	if (unsavedChanges){
		alert('You have unsaved changes. Please save the feeder before proceeding.')
	}
	else{
		var newName = prompt("Rename the feeder to",lastFeederName)
		while (! /^[\w\s]+$/.test(newName) || /^\s+$/.test(newName)){
			newName = prompt("Only letters, digits and underscore are allowed.\nPlease enter a different name", "{{ feederName }}")
		}
		if (newName){
			checkFeederName(newName)
		}
	}
}

function checkFeederName(newName) {
	// Additional check, required for Safari browsers
	if (true) {
		var modelName = "{{ modelName }}"
		$.ajax({
			url: "/uniqObjName/Feeder/" + "{{ owner }}" + "/" + newName + "/" + modelName
		}).done(function (data) {
			if (data.exists) {
				alert("You already have a Feeder named '" + newName + "', please choose a different name.")
				renameFeeder()
			}
			else{
				gebi("fileOps").click();
				post_to_url("/renameFeeder/" + "{{ owner }}" + "/" + "{{ modelName }}" + "/" + lastFeederName + "/" + newName + "/" + "{{ feederNum }}")
				document.getElementById('feederName').innerHTML = newName;
				lastFeederName = newName; //permits multiple name changes without forcing page refresh.
				// Send updated name to model.
				window.opener.$(window.opener.document).trigger('mainWindow', "{{ modelName }};"+"feederName{{feederNum}};"+lastFeederName);			
			}
		})
	}
}

function startConversion(elementName, nextAction) {
	// Additional check, required for Safari browsers
	var newName = document.getElementById(elementName).value;
	if (true) {
		var modelName = "{{ modelName }}"
		$.ajax({
			url: "/uniqObjName/Feeder/" + "{{ owner }}" + "/" + newName + "/" + modelName
		}).done(function (data) {
			if (data.exists) {
				alert("You already have a Feeder named '" + newName + "', please choose a different name.")
			}
			else{
				if (nextAction == 1){newfeeder.submit()}
				else if (nextAction == 2){importFiles('milsoft','feederNameM')}
				else if (nextAction == 3){importFiles('gridlabd','feederNameG')}
				else if (nextAction == 4){importFiles('cyme','feederNameC')}
			}
		})
	}
}

function showModal(element){
	gebi(element).style.display = 'block'
}

function closeModal(element){
	gebi(element).style.display = 'none'
}

function showDiv(element,maxHeight, marginBot){
	gebi(element).style.visibility = 'visible';
	gebi(element).style.height = '100%';
	gebi(element).style.maxHeight = maxHeight;
	gebi(element).style.marginBottom = marginBot;
}

function closeDiv(element){
	gebi(element).style.visibility = 'hidden';
	gebi(element).style.height = '0';
	gebi(element).style.marginBottom = '0px';
}

function loadFeeder(fromfeederName, frommodelName, fromuser){
	var modelName = "{{ modelName }}"
	$.ajax({
		url: "/uniqObjName/Feeder/" + fromuser + "/" + fromfeederName + "/" + frommodelName
	}).done(function (data) {
		if (data.exists) {
			post_to_url("/loadFeeder/" + fromfeederName + "/" + frommodelName + "/" + "{{ modelName }}" + "/" + "{{ feederNum }}" + "/" + fromuser + "/" + "{{ owner }}")
		}
		else{
			alert('This feeder no longer exists. Please refresh the page, or select another one.')
		}
	})
}

function getComponentsList(type) {
	var attachList = []
	// Clearing each list so we dont get duplicates in the list
	document.getElementById('componentNameNew').innerHTML = "";
	document.getElementById('attachTypeNew').innerHTML = "";
	document.getElementById('attachTypeNewEdit').innerHTML = "";
	for (var component in components) {
		document.getElementById('componentNameNew').innerHTML += '<option value="'+component+'">'+component+'</option>'
	}
	for (var key in tree) {
		if ( (tree[key].hasOwnProperty('object')) && (tree[key]['object'] in components) ) {
			if ( !attachList.includes(tree[key]['object']) ) {
				attachList.push(tree[key]['object'])
				if (type == 'add'){
				document.getElementById('attachTypeNew').innerHTML += '<option value="'+tree[key]['object']+'">'+tree[key]['object']+'</option>'
				}
				else{
					document.getElementById('attachTypeNewEdit').innerHTML += '<option value="'+tree[key]['object']+'">'+tree[key]['object']+'</option>'
				}
			}
		}
	}
}

function getAttachmentsList() {
	document.getElementById('attachmentsList').innerHTML = ''
	for (var attachment in attachments) {
		document.getElementById('attachmentsList').innerHTML += '<option value="'+attachment+'">'+attachment+'</option>'
	}
}

function editAttachment(attachment) {
	document.body.style.cursor = 'wait'
	setTimeout(function(){
		showModal('editAttachmentModal')
		var attachment = document.getElementById('attachmentsList').value
		document.getElementById('attachmentSelect').innerHTML = attachment 
		document.getElementById('editAttachmentBox').innerHTML = attachments[attachment]
		document.body.style.cursor = 'auto'
	}, 100);
}

function saveAttachment(attachment) {
	var attachName = document.getElementById('attachmentSelect').innerHTML
	attachments[attachName] = document.getElementById('editAttachmentBox').value
}
// Mass Edit functions
function clearTextBoxes(){
	document.getElementById('attachTypeNewEdit').value = ''
	document.getElementById('attributeEdit').value = ''
	document.getElementById('addValue').value = ''
	document.getElementById('changeValue').value = ''
	document.getElementById('newAttr').value = ''
	document.getElementById('newAttrVal').value = ''
	document.getElementById('multValue').value = ''
	document.getElementById('addedVal').value = ''
}
function editObjects(){
	var objectType = document.getElementById('attachTypeNewEdit').value
	var attributeEdit = document.getElementById('attributeEdit').value
	var radios = document.getElementsByName('attrEdit');
	var objectsToEdit = []
	// Find all objects of selected type
	for (key in tree){
		if ((tree[key]['object']) === objectType && !objectsToEdit.includes(key)){
			objectsToEdit.push(key)
		}
	}
	// Determine selected radio button
	for (var i = 0, length = radios.length; i < length; i++) {
    if (radios[i].checked) {
        // do whatever you want with the checked radio
        radioVal = radios[i].value;

        // only one radio can be logically checked, don't check the rest
        break;
    	}
	}
	// Edit accoring to the radio button selected
	// Adding to attribute
	if(radioVal == 'addVal'){
		var addingVal = parseInt(document.getElementById('addValue').value)
		for (var obj in objectsToEdit){
			sum = parseInt(tree[objectsToEdit[obj]][attributeEdit]) +addingVal
			tree[objectsToEdit[obj]][attributeEdit] = sum.toString()
		}
	}
	// Deleting attribute
	else if (radioVal == 'deleteAttr'){
		for (var obj in objectsToEdit){
			delete tree[objectsToEdit[obj]][attributeEdit]
		}
	}
	// Setting value to attribute
	else if (radioVal == 'changeTo'){
		for (var obj in objectsToEdit){
			var newVal = document.getElementById('changeValue').value
			if (tree[objectsToEdit[obj]].hasOwnProperty(attributeEdit)){
				tree[objectsToEdit[obj]][attributeEdit] = newVal
			}
		}
	}
	// Adding new attribute
	else if (radioVal == 'addAttr'){
		for (var obj in objectsToEdit){
			var newAttr = document.getElementById('newAttr').value
			var newAttrVal = document.getElementById('newAttrVal').value
			tree[objectsToEdit[obj]][newAttr] = newAttrVal
		}	
	}
	// Scaling and adding to attribute
	else{
		var multValue = parseInt(document.getElementById('multValue').value)
		var addedVal = parseInt(document.getElementById('addedVal').value)
		if (isNaN(addedVal)){
			addedVal = 0
		}
		for (var obj in objectsToEdit){
			var product = parseInt(tree[objectsToEdit[obj]][attributeEdit]) * multValue
			var sumIt = product + addedVal
			tree[objectsToEdit[obj]][attributeEdit] = sumIt.toString()
		}
	}
}

//*********************************************
// FUNCTIONS FOR DRAWING:
//*********************************************
/**
 * Initial draw function, prepare grid data, and call redraw at the end.
 */
function draw() {
	// d3.js bookkeeping to set what happens on each time tick in the simulation:
	force.on('tick', function () {
		vis.selectAll('line.link')
			.attr('x1', function (d) {
				return d.source.x;
			})
			.attr('y1', function (d) {
				return d.source.y;
			})
			.attr('x2', function (d) {
				return d.target.x;
			})
			.attr('y2', function (d) {
				return d.target.y;
			});
		vis.selectAll('.node')
			.attr("fixed", function (d) {
				return d.fixed
			}) // fixed a node
		.attr("transform", function (d) {
			return "translate(" + d.x + "," + d.y + ")";
		});
	});
	var name2nodeIndex = {}
	if (nodes.length == 0) {
		// Go through the first time and set up the nodes with indices:
		for (x in tree) {
			if ((tree[x].name != undefined || tree[x].module != undefined) && tree[x].from == undefined) {
				nodeName = tree[x].name
				nodeObject = (tree[x].object == "node") ? "gridNode" : tree[x].object
				isfixed = (tree[x].latitude != undefined && tree[x].longitude != undefined) ? true : false
				// Hack to make sure electrical nodes are classed differently than graph nodes for coloring purposes:
				if (undefined != tree[x].bustype && tree[x].bustype == 'SWING')
					nodeObject += ' swingNode'
				nodeIndex = nodes.length
				nodes.push({
					name: nodeName,
					treeIndex: parseInt(x),
					objectType: nodeObject,
					chargeMultiple: 1,
					x: tree[x].latitude,
					y: tree[x].longitude,
					fixed: isfixed
				})
				name2nodeIndex[nodeName] = nodeIndex
			}
		}

		// Go through a second time and set up the links:
		for (x in tree) {
			if (tree[x].name != undefined) {
				if (tree[x].from != undefined && tree[x].to != undefined) {
					name2nodeIndex[tree[x].name] = links.length
					links.push({
						source: name2nodeIndex[tree[x].from],
						target: name2nodeIndex[tree[x].to],
						treeIndex: parseInt(x),
						objectType: 'fromTo'
					})
				} else if (tree[x].parent != undefined) {
					links.push({
						source: name2nodeIndex[tree[x].name],
						target: name2nodeIndex[tree[x].parent],
						objectType: 'parentChild'
					})
				}
			}
		}
	}
	// This makes a fancy fade-in.
	vis.style('opacity', 1e-6)
		.transition()
		.duration(1500)
		.style('opacity', 1);
	// Start the layout.
	force.start();

	// Feeder loading
	var interval = setInterval(function () {
		if (force.alpha() < 0.05) {
			setTimeout(pinAll,2000)
			removeProgressDialog()
			clearInterval(interval)
		} else if (nodes[parseInt(Math.random() * nodes.length)].fixed) {
			setTimeout(pinAll,2000)
			removeProgressDialog()
			clearInterval(interval)
		} else {
			// Run the layout in the background until performance is acceptable.
			for (i = 0; i < 10; ++i) force.tick()
		}
	}, 1000)

	// Start drawing.
	redraw()
}

/**
 * Draw svg elements. Start d3.force at the end. TODO: performance issue.
 */
function redraw() {
	link = d3.select('#linkLayer').selectAll('line.link')
		.data(links, function (d) {
			return d.source.treeIndex + '-' + d.target.treeIndex
		})

	link.enter().append('svg:line')
		.on('click', onCompClick)
		.attr('class', function (d) {
			return 'link ' + d.objectType
		})
		.attr('id', function (d) {
			return 'n' + d.treeIndex
		})
		.style('stroke-width', LINE_LINK_STROKE_WIDTH)
		.attr('marker-start',
			function (d) {
				// console.log(d);
				treeData = tree[d.treeIndex]
				if (d.objectType == 'fromTo') {
					if (treeData.object == "transformer") {
						return "url(#transformerMarker)"
					};
					if (treeData.object == "fuse") {
						return "url(#fuseMarker)"
					};
					if (treeData.object == "regulator") {
						return "url(#regulatorMarker)"
					};
				};
			})
	link.exit().remove()

	node = vis.selectAll('.node').data(nodes, function (d) {
		return d.treeIndex
	}).enter()
		.append("g")
		.call(force.drag)
		.attr('class', function (d) {
			return 'node ' + d.objectType
		})
		.attr('id', function (d) {
			return 'n' + d.treeIndex
		})
		.on('click', onCompClick)
	fontSizeRedraw(zoomer.scale());

	// Put the main circle on there, sized according to its size.
	node.append('svg:circle')
		.attr('id', function (d) {
			return 'circ' + d.treeIndex
		})
		.attr('class', 'nodeCircle')
		.attr('cx', 0)
		.attr('cy', 0)
		.attr('r', function (d) {
			return d.chargeMultiple * NODE_CIRCLE_RADIUS
		})
	// .attr("r", 100)
	.style('stroke-width', NODE_STROKE_WIDTH - 0.2);

	node.append('svg:circle')
		.attr('class', function (d) {
			if (d.fixed) {
				return 'nodeIsPinned'
			} else {
				return 'nodeNotPinned'
			}
		})

	node.selectAll('.nodeIsPinned')
		.attr('id', function (d) {
			return 'pin' + d.treeIndex
		})
	node.selectAll('.nodeNotPinned')
		.attr('id', function (d) {
			return 'pin' + d.treeIndex
		})

	node.append("svg:text")
		.attr("class", "nodetext")
	// Get rid of deleted nodes.
	vis.selectAll('.node').data(nodes, function (d) {
		return d.treeIndex
	}).exit().remove()

	d3.selectAll('.nodeIsPinned')
		.attr('cx', 0)
		.attr('cy', 0)
		.attr('r', PINNED_NODE_CIRCLE_RADIUS)
		.style('stroke-width', PINNED_NODE_STROKE_SIZE);
	d3.selectAll('.nodeNotPinned').attr('r', null)
	d3.selectAll('.node.selected').style('stroke-width', NODE_SELECTED_STROKE_WIDTH)

	// Updata sizes
	vis.selectAll('.nodeCircle').data(nodes, function (d) {
		return d.treeIndex
	})
		.attr('r', function (d) {
			return d.chargeMultiple * NODE_CIRCLE_RADIUS
		})

	// Show scalegrid.
	force.start()
}

/**
 * Redraw font text size when move over nodes.
 * @param {number} scale
 */
function fontSizeRedraw(scale) {
	d3.selectAll('.nodetext')
		.style('font-size', TEXT_FONT_SIZE / scale)
		.style("stroke-width", 1 / scale)
		.text(function (d) {
			if (d.chargeMultiple != 1) {
				return d.objectType + ' has hidden children'
			} else {
				return d.objectType
			}
		});

}

/**
 * Redraw after zoom level changes.
 */
function zoomRedraw() {
	var previourLevel = 1;
	// console.log(d3.event.scale, d3.event.translate)
	vis.attr('transform', 'translate(' + d3.event.translate + ')' + ' scale(' + d3.event.scale + ')')
	if (d3.event.scale < 1) {
		d3.selectAll('.link').style("stroke-width", LINE_LINK_STROKE_WIDTH / d3.event.scale);
	}
	fontSizeRedraw(d3.event.scale);
	previourLevel = d3.event.scale;
}

/**
 * Using zoomer to translate position(x, y) and set scale s
 * @param {number} x
 * @param {number} y
 * @param {number} s
 */
function zoom(x, y, s) {
	vis.transition().duration(1000).attr('transform', 'translate(' + x + ',' + y + ') scale(' + s + ')')
	// Set the behavior scale and translate to the current condition.
	zoomer.scale(s)
	zoomer.translate([x, y])
	// reset link width
	if (s < 1) {
		d3.selectAll('.link').style("stroke-width", LINE_LINK_STROKE_WIDTH / s);
	} else {
		d3.selectAll("line.link").style("stroke-width", LINE_LINK_STROKE_WIDTH);
	}

	// console.log(zoomer.scale(), s)
	// redraw font-size
	fontSizeRedraw(s)
}

/**
 * Reset zoom to level 1 and translate to (0, 0)
 */
function zoomReset() {
	// TODO: rework our algorithm so we can zoom to fill the screen with the graph, not just go back to zoom level zero.
	zoom(0, 0, 1);
}

/**
 * Zoom to fix window size
 */
function zoomToFit() {
	function fly(attr_func, comp_func) {
		var largest;
		var my_n;
		for (i = 0; i < nodes.length; i++) {
			if (nodes[i].fixed === true) {
				if (!largest || comp_func(attr_func(nodes[i]), largest)) {
					largest = attr_func(nodes[i])
					my_n = nodes[i]
				}
			}
		}
		return my_n;
	}

	function the_center(bounds, i) {
		return ((bounds[0][i] + bounds[1][i]) / 2)
	}

	function xcenter() {
		return the_center(get_bounds(), 0) * zoomer.scale()
	}

	function ycenter() {
		return the_center(get_bounds(), 1) * zoomer.scale()
	}

	function window_hoz_center() {
		return ($(window).width() / 2) / ($(window).width() / 1000);
	}

	function window_vert_center() {
		var extra = 66 + $("#header").outerHeight()
		var win_height = $(window).height() - extra
		return (win_height / 2 + extra) / ($(window).height() / 1000);
	}

	function center_feeder() {
		var trans_amt_x = window_hoz_center() - xcenter();
		var trans_amt_y = window_vert_center() - ycenter();
		zoom(trans_amt_x, trans_amt_y, zoomer.scale())
	}
	var rets_x = function (n) {
		return n.x;
	};
	var rets_y = function (n) {
		return n.y;
	};
	var lt = function (a, b) {
		return a < b;
	};
	var gt = function (a, b) {
		return a > b;
	};

	function get_bounds() {
		low_x = fly(rets_x, lt).x;
		high_x = fly(rets_x, gt).x;
		low_y = fly(rets_y, lt).y;
		high_y = fly(rets_y, gt).y;
		return [
			[low_x, low_y],
			[high_x, high_y]
		];
	}

	function win_h() {
		var extra = 66 + $("#header").outerHeight()
		var win_h = $(window).height() - extra
		return win_h / ($(window).height() / 1000)
	}

	function get_width(bounds, i) {
		return bounds[1][i] - bounds[0][i];
	}

	function xwidth() {
		return get_width(get_bounds(), 0)
	}

	function ywidth() {
		return get_width(get_bounds(), 1)
	}
	zoom(0, 0, win_h() / ywidth())
	center_feeder()
}

/**
 * Zoom to select element in the center of current window
 */
function zoomToSelection() {
	domTargets = document.getElementsByClassName('selected')
	if (domTargets.length != 1) {
		return false
	}
	if (domTargets[0].nodeName == 'line') {
		x = getSelectedLink()['source']['x']
		y = getSelectedLink()['source']['y']
	} else {
		x = getSelectedNode()['x']
		y = getSelectedNode()['y']
	}
	var scale = 15
	var xNew = -x * scale + graphSvg.clientWidth / 2
	var yNew = -y * scale + graphSvg.clientHeight / 2
		// Zooming to a node's coordinates
	zoom(xNew, yNew, scale)
}

/**
 * Get center coordinates based on zoomer's scale and translate position
 * @return {[number, number]} Coordinate|[0,0]
 */
function getCenterCoordinates() {
	try {
		x = zoomer.translate()[0]
		y = zoomer.translate()[1]
		s = 1/zoomer.scale()
		xMod = graphSvg.clientWidth/2
		yMod = graphSvg.clientHeight/2
		return [s*(xMod-x), s*(yMod-y)]
	} catch(err) {
		// Probably haven't transformed yet.
		return [0,0]
	}
}

//*********************************************
// EVENT HANDLER FUNCTIONS, SELECT AND SEARCH FUNCTIONS
//*********************************************
/**
 * Node or link click event handler function, also used in components search.
 * @param {Object} d
 * @param {number} i
 */
function onCompClick(d, i) {
	function classify(d, c) {
		svg = d3.select('#graphSvg')
		// turn off the old styled one, then style the new one
		svg.select('.' + c).classed(c, false);
		svg.select("#n" + d.treeIndex).classed(c, true);
	}
	// Start showing the table.
	// gebi('selected').className = ''
	// Abort if we try to select a parentChild relationship.
	if (d.objectType == 'parentChild') return false;
	// Multiselection case handled first:
	if (d3.event && d3.event.altKey) {
		classify(d, 'multiselected')
		return false
	}
	console.log(['treeIndex=' + d.treeIndex, 'name=' + d.name, 'obType=' + d.objectType])
	// Visually identify the selected node.
	classify(d, 'selected')
	// clear the selected table
	table = gebi('selected')
	table.setAttribute('keypress', "hotkeys()")
	tableClear(table)
	treeData = tree[d.treeIndex]
	ti = d.treeIndex;
	selectNode();
}

/**
 * Clear selected component either click in blank or delete that component
 */
function clearSelection() {
	try {
		svg.select('.selected').classed('selected', false)
		svg.select('.multiselected').classed('multiselected', false)
	} catch (err) {
		// ignore the error we get because we use svg before we define it--it'll be generated very fast after page load.
	}
	// deselect function inside tablescript.js
	deselect()
}

/**
 * Select component via tree index, when a list of components is found, use it to iterate next component.
 * @param  {number} treeIndex
 */
function selectViaTreeIndex(treeIndex) {
	if (tree[treeIndex].hasOwnProperty('from')) {
		// That particular tree item is a link:
		linkI = findIndex(links, 'treeIndex', treeIndex)
		onCompClick(links[linkI], linkI)
	} else if (tree[treeIndex].hasOwnProperty('object') && tree[treeIndex]['object'] != 'player') {
		// Or it's a node:
		nodeI = findIndex(nodes, 'treeIndex', treeIndex)
		onCompClick(nodes[nodeI], nodeI)
	} else {
		nodeI = findIndex(nodes, 'treeIndex', treeIndex)
		onCompClick(nodes[nodeI], nodeI)
		// Degenerate case: object without visual representation.
	}
}

/**
 * graphSvg click handler function, clear selected component.
 */
function onSvgBlankCanvasClick() {
	if (window.event.toElement.tagName == 'svg') {
		clearSelection()
	}
}

/**
 * Return a node object, if the node is selected.
 * @return {Object} node return single node object, if not find, return undefined.
 */
function getSelectedNode() {
	try {
		hits = document.getElementsByClassName('selected')
		nodeIndex = findIndex(nodes, 'treeIndex', hits[0]['id'].substr(1))
		return nodes[nodeIndex]
	} catch (err) {
		// We had no selection, or the selection wasn't in the links.
		return undefined
	}
}

/**
 * Return a node object, if multinodes selected.
 * @return {Object} node
 */
function getAltSelectedNode() {
	try {
		hits = document.getElementsByClassName('multiselected')
		nodeIndex = findIndex(nodes, 'treeIndex', hits[0]['id'].substr(1))
		return nodes[nodeIndex]
	} catch (err) {
		// We had no selection, or the selection wasn't in the links.
		return undefined
	}
}

/**
 * Return a link object, if the link is selected.
 * @return {Object} link return a single link object, if not find, return undefined.
 */
function getSelectedLink() {
	try {
		hits = document.getElementsByClassName('selected')
		linkIndex = findIndex(links, 'treeIndex', hits[0]['id'].substr(1))
		return links[linkIndex]
	} catch (err) {
		// We had no selection, or the selection wasn't in the links.
		return undefined
	}
}

/**
 * Hotkeys binding the page onkeypress event.
 */
function hotkeys() {
	// IE8 and earlier
	if (window.event) {
		x = event.keyCode
	}
	// IE9/Firefox/Chrome/Opera/Safari
	else if (event.which) {
		x = event.which
	}
	keychar = String.fromCharCode(x);
	if (event.target.type != 'text' && $("#otherButtons").css("display") == "none") {
		// Dispatch the key:
		if (keychar == 'p') {
			toggleSelectedPin()
		} else if (keychar == 'f') {
			foldAtSelected()
		} else if (keychar == 'u') {
			unfoldAtSelected()
		}
	}
}

//**************************************************
// ADDING COMPONENTS FUNCTIONS
//**************************************************
/**
 * Fill menu of "Add" button and its handler functions.
 */
function fillComponentMenu() {
	newObjectMenu = gebi('newObjectMenu')
	for (component in components) {
		if (undefined == components[component]['from'] && undefined == components[component]['parent']) {
			addingFunctionName = 'newNode'
		} else if (undefined == components[component]['from']) {
			addingFunctionName = 'newChildAtSelected'
		} else {
			addingFunctionName = 'newLink'
		}
		newObjectMenu.innerHTML += ('<li><a href="javascript:unsavedChanges=true;' + addingFunctionName + '(\'' + component + '\')">' + component + '</a></li>')
	}
}

/**
 * Add a new node based on the name of component. Set node attributes, and add to nodes list. Redraw the graph at the end.
 * @param  {string} componentName
 */
function newNode(componentName) {
	// Get the stuff we need.
	component = clone(components[componentName])
	treeNewIndex = nextTreeKey()
	// Put the component in the tree with a new name.
	tree[treeNewIndex] = component
	tree[treeNewIndex].name = componentName + String(treeNewIndex)
	// Add to the nodes.
	newType = component.object
	// Hack to make sure we color nodes correctly:
	if (newType == 'node') newType = 'gridNode'
	if (undefined != tree[treeNewIndex].bustype && tree[treeNewIndex].bustype == 'SWING') newType += ' swingNode'
	// Add the node to the center of the graph
	coords = getCenterCoordinates()
	nodeToAdd = {
		name: component.name,
		objectType: newType,
		treeIndex: treeNewIndex,
		chargeMultiple: 1,
		fixed: true,
		x: coords[0],
		y: coords[1],
		px: coords[0],
		py: coords[1]
	}
	nodes.push(nodeToAdd)
	redraw()
}

/**
 * Add a new link based on the name of component. Set link attributes, and add to nodes list. Redraw the graph at the end.
 * @param  {string} componentName
 */
function newLink(componentName) {
	// Fail if we have an incorrect selection.
	function alreadyLinked(nodeName1, nodeName2) {
		for (linkId in links) {
			sourceName = links[linkId].source.name
			targetName = links[linkId].target.name
			if ((nodeName1 == sourceName && nodeName2 == targetName) || (nodeName1 == targetName && nodeName2 == sourceName)) {
				return true
			}
		}
		return false
	}
	try {
		selectedName = getSelectedNode()['name']
		altSelectedName = getAltSelectedNode()['name']
	} catch (err) {
		// Key error!
		selectedName = undefined
		altSelectedName = undefined
	}
	// Check validation of a link
	if (undefined == selectedName || undefined == altSelectedName || selectedName == altSelectedName || alreadyLinked(selectedName, altSelectedName)) {
		alert('I am sorry, but we cannot insert a link there.')
		return false
	}
	// Get the stuff we need.
	component = clone(components[componentName])
	treeNewIndex = nextTreeKey()
	// Make sure component's to and from are set.
	component['from'] = selectedName
	component['to'] = altSelectedName
	// Put the component in the tree with a new name.
	tree[treeNewIndex] = component
	tree[treeNewIndex].name = componentName + String(treeNewIndex)
	// TODO: make absolutely sure we're not clobbering a name. We should just come up with a unique naming convention.
	// Add to the links.
	linkToAdd = {
		source: nodes[findIndex(nodes, 'name', selectedName)],
		target: nodes[findIndex(nodes, 'name', altSelectedName)],
		treeIndex: treeNewIndex,
		objectType: 'fromTo'
	}
	links.push(linkToAdd)
	redraw()
}

/**
 * Add a new child node at selected component
 * @param  {string} componentName
 */
function newChildAtSelected(componentName) {
	if (undefined == getSelectedNode()) {
		alert('I am sorry, but we cannot insert a child element there.')
		return false
	}
	// Get the stuff we need.
	component = clone(components[componentName])
	newChildAtLocation(component, getSelectedNode()['treeIndex'])
	redraw()
}

/**
 * Append a node to its parent's
 * @param  {Object} component
 * @param  {number} treeIndex
 * @return {Object} nodeToAdd
 */
function newChildAtLocation(component, treeIndex) {
	console.log(treeIndex)
	console.log(tree[treeIndex]['name'])
	var treeNewIndex = nextTreeKey()
	var newName = component['object'] + String(treeNewIndex)
	// Make sure component's parent is set.
	component['parent'] = tree[treeIndex]['name']
	// decide which attribute should be put into node and tree
	if (tree[treeIndex].latitude != undefined && tree[treeIndex].longitude != undefined) {
		component['latitude'] = parseFloat(tree[treeIndex].latitude) + Math.random() * 4 - 2
		component['longitude'] = parseFloat(tree[treeIndex].longitude) + Math.random() * 4 - 2
		// Put the component in the tree with a new name.
		tree[treeNewIndex] = component
		tree[treeNewIndex].name = newName
		// Add to the nodes.
		// TODO: when the previour graph is pinned, it should set fixed as false rather than true
		if (d3.selectAll('.node.gridNode').attr('fixed') == 'true') {
			isfixed = true
		} else {
			isfixed = false
		}
		nodeToAdd = {
			name: component.name,
			objectType: component.object,
			treeIndex: treeNewIndex,
			chargeMultiple: 1,
			x: component['latitude'],
			y: component['longitude'],
			fixed: isfixed
		}
		nodes.push(nodeToAdd)
	} else {
		if (d3.selectAll('.node.gridNode').attr('fixed') == 'true' && tree[treeIndex].latitude != undefined) {
			isfixed = true
		} else {
			isfixed = false
		}
		tree[treeNewIndex] = component
		tree[treeNewIndex].name = newName
		var nodeToAdd = {
			name: component.name,
			objectType: component.object,
			treeIndex: treeNewIndex,
			chargeMultiple: 1,
			fixed: isfixed
		}
		nodes.push(nodeToAdd)
	}
	// Add to the links.
	var linkToAdd = {
		source: nodes[findIndex(nodes, 'name', newName)],
		target: nodes[findIndex(nodes, 'name', tree[treeIndex]['name'])],
		objectType: 'parentChild'
	}
	links.push(linkToAdd)
	return nodeToAdd
}

//*********************************************
// EDITING FUNCTIONS
//*********************************************
/**
 * Handler function of adding static load to houses.
 */
function staticLoadsToHouses() {
	function randomHouse() {
		newHouse = {}
		newHouse['object'] = 'house'
		newHouse['air_temperature'] = '70'
		newHouse['cooling_COP'] = randomInt(25, 40) / 10.0 + ''
		newHouse['cooling_setpoint'] = 'cooling' + randomInt(1, 8) + '*1'
		newHouse['cooling_system_type'] = randomChoice(['ELECTRIC', 'HEAT_PUMP', 'NONE'])
		// House sizing distribution from http://www.census.gov/housing/ahs/
		// between 1100 and 3000. Probably needs a normal distribution.
		area = 1800 + 500 * randomGaussian()
		if (area < 500) {
			area = 500
		}
		area = area.toPrecision(2) * 1.0 + ''
		newHouse['floor_area'] = area
		newHouse['heating_COP'] = randomInt(20, 35) / 10.0 + ''
		newHouse['heating_setpoint'] = 'heating' + randomInt(1, 8) + '*1'
		newHouse['heating_system_type'] = randomChoice(['RESISTANCE', 'HEAT_PUMP', 'GAS'])
		newHouse['mass_temperature'] = '70'
		skew = 1200 * randomGaussian()
		skew = skew.toPrecision(3) * 1.0 + ''
		newHouse['schedule_skew'] = skew
		newHouse['thermal_integrity_level'] = randomChoice([1, 2, 2, 2, 3, 3, 3, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 6, 6, 6]) + ''
		treeNewIndex = nextTreeKey()
		newHouse['name'] = 'synhouse' + treeNewIndex
		return newHouse
	}

	function randomLights() {
		newLights = {}
		newLights['object'] = 'ZIPload'
		newLights['power_fraction'] = '0.400000'
		newLights['current_fraction'] = '0.300000'
		newLights['impedance_pf'] = '1.000'
		newLights['current_pf'] = '1.000'
		newLights['power_pf'] = '1.000'
		newLights['impedance_fraction'] = '0.300000'
		newLights['heatgain_fraction'] = '0.9'
		power = 1.2 + randomGaussian()
		if (power < 0) {
			power = -1 * power
		}
		power = power.toPrecision(3) * 1.0 + ''
		newLights['base_power'] = 'LIGHTS*' + 1.33
		skew = 2000 * randomGaussian()
		skew = skew.toPrecision(3) * 1.0 + ''
		newLights['schedule_skew'] = skew
		treeNewIndex = nextTreeKey()
		newLights['name'] = 'synLights' + treeNewIndex
		return newLights
	}

	function randomWaterHeater() {
		newHeater = {}
		if (randomChoice([1, 2, 3]) == 3) {
			return false
		}
		// Static properties.
		newHeater['object'] = 'waterheater'
		newHeater['temperature'] = '135'
		newHeater['tank_volume'] = '50'
		newHeater['location'] = 'INSIDE'
		// Uniformly distributed properties.
		newHeater['heating_element_capacity'] = randomInt(37, 53) / 10.0 + ''
		newHeater['thermostat_deadband'] = randomInt(20, 60) / 10.0 + ''
		newHeater['demand'] = 'water' + randomInt(1, 20) + '*1'
		newHeater['tank_UA'] = randomInt(20, 40) / 10.0 + ''
		// Gaussian properties.
		skew = 2000 * randomGaussian()
		skew = skew.toPrecision(3) * 1.0 + ''
		newHeater['schedule_skew'] = skew
		newHeater['tank_setpoint'] = (randomGaussian() * 2 + 130).toPrecision(3) + ''
		// between 1100 and 3000. Probably needs a normal distribution.
		treeNewIndex = nextTreeKey()
		newHeater['name'] = 'synwaterheater' + treeNewIndex
		return newHeater
	}

	function replaceAllHouses() {
		progressBarUpdate(percentage)
		if (i < tkeys.length && !in_use && percentage != 100) {
			in_use = true
			var limit = i + 100
			for (; i < tkeys.length && i < limit; i++) {
				index = tkeys[i]
				if (tree[index].hasOwnProperty('object') && tree[index].hasOwnProperty('parent') && tree[index]['object'] == 'triplex_node') {
					//get the parent index in tree, actually it is triplex_meter index
					parentIndex = findIndex(tree, 'name', tree[index]['parent'])
					// delete the triplex_node
					deleteObject(index)
					// create a new node which parent is
					newHouse = randomHouse()
					newLights = randomLights()
					newHeater = randomWaterHeater()
					newChildAtLocation(newHouse, parentIndex)
					houseIndex = findIndex(tree, 'name', newHouse['name'])
					newChildAtLocation(newLights, houseIndex)
					if (newHeater != false) {
						newChildAtLocation(newHeater, houseIndex)
					}
				}
				percentage = Math.round(i / tkeys.length * 100).toFixed(2)
			}
			in_use = false
		} else {
			redraw()
			removeProgressDialog()
			in_use = false;
			clearInterval(inter)
		}
	}

	function progressBarUpdate(percentage) {
		if (document.getElementById('progBar') != undefined)
			document.getElementById('progColor').style.width = percentage + '%'
	}

	function noTriplexNode() {
		for (x in hiddenNodes) {
			if (hiddenNodes[x].objectType != undefined && hiddenNodes[x].objectType == 'triplex_node')
				return true
		}
		return false
	}

	i = 0
	percentage = 0
	in_use = false;
	// TODO: for secondary system has 'load', replace it with triplex_meter and triplex_node
	tkeys = Object.keys(tree)
	if (noTriplexNode()) {
		alert('TRIPLEX NODES have been hidden by the layout, please unfold them first.')
	} else {
		showProgressDialog('bar','Please wait. Houses are being generated.','none')
		// set interval function to run replaceAllHouses every 10 ms, if it is running, will put one request in the queue.
		inter = setInterval(replaceAllHouses, 10)
	}
}

/**
 * UNKNOWN
 */
function replaceLoadWithTriplex() {
	var tkeys = Object.keys(tree);
	var count = tkeys.length;
	// TODO: performance issue here, same with staticLoadsToHouses()
	for (var i = count - 1; i >= 0; i--) {
		if (tree[tkeys[i]].object != undefined && tree[tkeys[i]].object == 'load') {
			// Add triplex_meter
			parentIndex = findIndex(tree, 'name', tree[tkeys[i]]['parent'])
			triName = 'tri' + tree[tkeys[i]].name
			triPhases = tree[tkeys[i]].phases
			triObject = 'triplex_meter'
			triVol = tree[tkeys[i]].nominal_voltage
			triMeter = {
				'name': triName,
				'phases': triPhases,
				'object': triObject,
				'nominal_voltage': triVol
			}
			newNode = newChildAtLocation(triMeter, parentIndex)
			// Add triplex_node
			parentIndex = findIndex(tree, 'name', newNode.name)
			triNodeName = 'triNode' + newNode.name
			triNodeParents = newNode.name
			triNodePower = Math.max(parseFloat(tree[tkeys[i]].constant_power_A), parseFloat(tree[tkeys[i]].constant_power_B), parseFloat(tree[tkeys[i]].constant_power_C))
			triNodePhases = tree[tkeys[i]].phases
			triNodeVol = tree[tkeys[i]].nominal_voltage
			triNode = {
				'name': triNodeName,
				'phases': triNodePhases,
				'power_12': triNodePower,
				'object': 'triplex_node',
				'nominal_voltage': triNodeVol
			}
			newChildAtLocation(triNode, parentIndex)
			// delete load object
			deleteObject(tkeys[i])
		}
	}
}
/*
 * General Function to Add Components 'inverter', 'triplex_meter', PERC
 */
function addXatY(componentName, attachType, perc) {
	var componentName = document.getElementById('componentNameNew').value
	var attachType = document.getElementById('attachTypeNew').value
	var perc = document.getElementById('percNew').value
	var objectsAdded = 0
	if ( components.hasOwnProperty(componentName) ) {
		for (var key in tree) {
			if (tree[key].hasOwnProperty('object') && tree[key]['object'] == attachType) {
				if (Math.random() < perc) {
					var newComp = JSON.parse(JSON.stringify(components[componentName]))
					newChildAtLocation(newComp, key)
					objectsAdded += 1
				}
			}
		}
		redraw()
		alert(objectsAdded + ' ' + componentName + ' objects added to the feeder')
	} 
	else {
		return
	}
}

//*********************************************
// PINNING FUNCTIONS
//*********************************************
/**
 * Set all nodes to be pinned, including nodes and hiddenNodes.
 */
function pinAll() {
	for (node in nodes) {
		gebi('pin' + nodes[node].treeIndex).setAttribute('class', 'nodeIsPinned')
		nodes[node].fixed = true
	}
	for (hNode in hiddenNodes) {
		gebi('pin' + hiddenNodes[hNode].treeIndex).setAttribute('class', 'nodeIsPinned')
		hiddenNodes[hNode].fixed = true
	}
	redraw()
}

/**
 * Unpin all nodes, including nodes and hiddenNodes.
 */
function unPinAll() {
	for (node in nodes) {
		gebi('pin' + nodes[node].treeIndex).setAttribute('class', 'nodeNotPinned')
		nodes[node].fixed = false
	}
	for (hNode in hiddenNodes) {
		gebi('pin' + hiddenNodes[hNode].treeIndex).setAttribute('class', 'nodeNotPinned')
		hiddenNodes[hNode].fixed = false
	}
	redraw()
}

/**
 * Toggle function at selected nodes.
 */
function toggleSelectedPin() {
	selNode = getSelectedNode()
	pinCircle = gebi('pin' + selNode.treeIndex)
	if (pinCircle.getAttribute('class') == 'nodeIsPinned') {
		pinCircle.setAttribute('class', 'nodeNotPinned')
		selNode.fixed = false
	} else {
		pinCircle.setAttribute('class', 'nodeIsPinned')
		selNode.fixed = true
	}
	redraw()
}

//*********************************************
// FINDING TOOLBAR FUNCTIONS
//*********************************************
/**
 * Find elements through input string, iterate every elements in tree to find out all matched elements.
 * @param  {string} inString
 * @return {Object[]} results
 */
function findElementsViaString(inString) {
	results = []
	for (key in tree) {
		subIndex = JSON.stringify(tree[key]).indexOf(inString)
		if (subIndex != -1 && tree[key]['object'] != 'player' && (tree[key].hasOwnProperty('object') || tree[key].hasOwnProperty('module'))) {
			results.push(key)
		}
	}
	return results
}

/**
 * Handler function of "Back" button, find the previours string input.
 */
function backButton() {
	if (!prevObjName) {
		console.log("There is no previous object")
		return
	}
	$("#searchTerm").val("\"name\":\"" + prevObjName + "\"")
	findNext()
}

/**
 * Handler function of "Next" button in "Find" toolbox.
 * If objects are found, zoom to the first object in the list.
 *
 */
function findNext() {
	if ($(".selected").length && treeData.object.indexOf("configuration") < 0) {
		// We don't want to store configuration objects in the history, right?
		prevObjName = treeData.name
	} else {
		prevObjName = undefined
	}

	term = gebi('searchTerm').value
	if (oldSearchTerm != term) {
		oldSearchTerm = term
		searchCursor = undefined
	}
	hits = findElementsViaString(term)
	// TODO: What if it is hidden(folded).
	gebi('searchHitCount').innerHTML = hits.length + ' Hits'
	try {
		if (hits.length == 0) {
			return false
		}
		if (searchCursor == undefined) {
			selectViaTreeIndex(hits[0])
			searchCursor = 0
		} else {
			searchCursor++
			if (searchCursor == hits.length) {
				searchCursor = 0
			}
			if (searchCursor == -1) {
				searchCursor = hits.length - 2
			}
			selectViaTreeIndex(hits[searchCursor])
		}
		zoomToSelection()
	} catch (err) {
		alert('Objects have been hidden in the layout, please unfold them first.\n' + err.message)
	}
}

/**
 * Handler function of "Previous" botton in "Find" toolbox, find previous object in a matched list.
 */
function findPrevious() {
	if (searchCursor == undefined) {
		findNext()
	} else {
		searchCursor -= 2
		findNext()
	}
}

/**
 * Delete object by its tree index. Clear selected object, and redraw after deleting object in tree.
 * @param  {number} treeIndex
 */
function deleteObject(treeIndex) {
	// Figure out whether we have a node or an link:
	var isNode = true
	for (prop in tree[treeIndex])
		if (prop == 'from') isNode = false
	if (isNode) {
		// Check for connections and abort if we have them.
		nodeName = tree[treeIndex].name
		for (indexVar in tree) {
			if (tree[indexVar].from == nodeName || tree[indexVar].to == nodeName || tree[indexVar].parent == nodeName) {
				alert('We can only delete nodes that aren\'t connected')
				return false
			}
		}
		// No connection, so delete the node:
		var nodeIndex
		for (x = 0; x < nodes.length; x++) {
			if (nodes[x].treeIndex == treeIndex) nodeIndex = x
		}
		nodes.splice(nodeIndex, 1)
		// If we have a parent child situation, delete the link:
		if (tree[treeIndex].parent != undefined) {
			var linkIndex
			for (x = 0; x < links.length; x++) {
				if (links[x].source.name == nodeName) linkIndex = x
			}
			links.splice(linkIndex, 1)
		}
	} else {
		// Delete link:
		var linkIndex
		for (x = 0; x < links.length; x++) {
			if (links[x].treeIndex == treeIndex) linkIndex = x
		}
		links.splice(linkIndex, 1)
	}
	// Delete tree object:
	delete tree[treeIndex]
	clearSelection()
	redraw()
	
}

/**
 * Return a maximum key value which has not been used in tree object.
 * @return {number} key
 */
function nextTreeKey() {
	keyList = Object.keys(tree)
	max = 0
	for (x in keyList) {
		intKey = parseInt(keyList[x]);
		if (intKey > max)
			max = intKey
	}
	return max + 1
}

/**
 * Find the index of an object based on it attribute value. If not find, return ""
 * @param  {object} inOb
 * @param  {string|number} field
 * @param  {string|number} val
 * @return {number} key|""
 */
function findIndex(inOb, field, val) {
	for (key in inOb) {
		if (inOb[key][field] == val) {
			return key
		}
	}
	return ''
}

//*********************************************
// LAYOUT MENU FUNCTIONS
//*********************************************
/**
 * Get d3.force layout variables.
 */
function layoutMenuInit() {
	nodeCount = nodes.length + hiddenNodes.length
	gebi('nodesBox').innerHTML = nodeCount
	gebi('nodesPercShown').style.width = nodes.length * 100 / nodeCount + '%'
	gebi('nodesPercHidden').style.width = hiddenNodes.length * 100 / nodeCount + '%'
	gebi('gravityBox').value = force.gravity()
	gebi('thetaBox').value = force.theta()
	gebi('frictionBox').value = force.friction()
	gebi('linkStrengthBox').value = force.linkStrength()
	gebi('linkDistanceBox').value = force.linkDistance()
	gebi('chargeBox').value = force.charge()
}

/**
 * Apply changes in d3.force layout variables
 */
function layoutMenuApply() {
	force.gravity(gebi('gravityBox').value)
	force.theta(gebi('thetaBox').value)
	force.friction(gebi('frictionBox').value)
	force.linkStrength(gebi('linkStrengthBox').value)
	force.linkDistance(gebi('linkDistanceBox').value)
	force.charge(gebi('chargeBox').value)
	force.start()
}

//*********************************************
// FUNCTIONS FOR GRAPH FOLDING:
//*********************************************
/**
 * Hide one node, and change its parent's chargemultiple to 1.5
 * @param  {object} node
 */
function hideNode(node) {
	// helper function to hide links:
	function hideLink(link) {
		hiddenLinks.push(links.splice(links.indexOf(link), 1)[0])
	}
	// Pop the node of the nodes list and push it onto the hiddenNodes list:
	hiddenNodes.push(nodes.splice(nodes.indexOf(node), 1)[0])
	// Pop/push any connected Links:
	toHideLinks = links.filter(function (lin) {
		return node.name == lin.source.name || node.name == lin.target.name
	})
	toHideLinks.map(hideLink)
	// Make the parents big!
	linkedNames = toHideLinks.map(function (x) {
		return x.source.name
	}).concat(toHideLinks.map(function (y) {
		return y.target.name
	}))
	toGrow = nodes.filter(function (thisNode) {
		return linkedNames.indexOf(thisNode.name) != -1
	})
	toGrow.map(function (d) {
		d.chargeMultiple = 1.5
	})
}

/**
 * Find node in hiddenNodes, and reveal it.
 * @param  {object} node
 */
function showNode(node) {
	toInsert = hiddenNodes.splice(hiddenNodes.indexOf(node), 1)[0]
	nodes.push(toInsert)
}

/**
 * Find link in hiddenLinks, and reveal it.
 * @param  {object} link
 */
function showLink(link) {
	toInsert = hiddenLinks.splice(hiddenLinks.indexOf(link), 1)[0]
	links.push(toInsert)
}

/**
 * Update hidden nodes percentages
 */
function updateHiddenPerc() {
	gebi('nodesPercShown').style.width = nodes.length * 100 / nodeCount + '%'
	gebi('nodesPercHidden').style.width = hiddenNodes.length * 100 / nodeCount + '%'
}

/**
 * Fold leaves of tree
 */
function foldOneLevel() {
	function isChild(node) {
		// We can apply the property of node in D3: weight, indicate number of links associated with it.
		if (node.weight == 1)
			return true
		else
			return false
	}
	// Find all the children:
	toHide = nodes.filter(isChild)
	// Hide them:
	toHide.map(hideNode)
	updateHiddenPerc()
	redraw()
}

/**
 * Unfold leaves of tree.
 */
function unfoldOneLevel() {
	// Find the hidden links that are connected to visible nodes:
	function attachedToVizNode(link) {
		return nodes.some(function (d) {
			return d.name == link.source.name || d.name == link.target.name
		})
	}
	linksToReveal = hiddenLinks.filter(attachedToVizNode)
	// Find the nodes that are attached to the revealed links:
	function attachedToRevealed(node) {
		return linksToReveal.some(function (d) {
			return node.name == d.source.name || node.name == d.target.name
		})
	}
	// Size the parents of revealed elements correctly.
	nodesToResize = nodes.filter(attachedToRevealed)
	nodesToResize.map(function (d) {
		d.chargeMultiple = 1
	})
	// Actually do the revealing.
	nodesToReveal = hiddenNodes.filter(attachedToRevealed)
	linksToReveal.map(showLink)
	nodesToReveal.map(showNode)
	updateHiddenPerc()
	redraw()
	d3.selectAll('.node').attr('stroke-width', function (d) {
		return d.chargeMultiple * NODE_STROKE_WIDTH
	})
}

/**
 * Unfold all nodes
 */
function unfoldAll() {
	while (hiddenLinks.length != 0) {
		links.push(hiddenLinks.pop())
	}
	while (hiddenNodes.length != 0) {
		nodes.push(hiddenNodes.pop())
	}
	nodes.map(function (d) {
		d.chargeMultiple = 1
	})
	updateHiddenPerc()
	redraw()
}

/**
 * Unfold at selected nodes, reveal its child nodes and associated links.
 */
function unfoldAtSelected() {
	selNode = getSelectedNode()
	function attachedToSelected(link) {
		return selNode.name == link.source.name || selNode.name == link.target.name
	}
	linksToReveal = hiddenLinks.filter(attachedToSelected)
	// Find the nodes that are attached to the revealed links:
	function attachedToRevealed(node) {
		return linksToReveal.some(function (d) {
			return node.name == d.source.name || node.name == d.target.name
		})
	}
	nodesToReveal = hiddenNodes.filter(attachedToRevealed)
	// Size the parents of revealed elements correctly.
	nodesToResize = nodes.filter(attachedToRevealed)
	nodesToResize.map(function (d) {
		d.chargeMultiple = 1
	})
	// Actually do the revealing.
	linksToReveal.map(showLink)
	nodesToReveal.map(showNode)
	updateHiddenPerc()
	redraw()
}

/**
 * Fold at selected nodes, put its child nodes into hidden nodes, and their associated links.
 */
function foldAtSelected() {
	selNode = getSelectedNode()
	function attachedToSelected(link) {
		return selNode.name == link.source.name || selNode.name == link.target.name
	}
	linksToHide = links.filter(attachedToSelected)
	// Find the nodes that are attached to the revealed links:
	function attachedToRevealed(node) {
		return linksToHide.some(function (d) {
			return node.name == d.source.name || node.name == d.target.name
		})
	}
	attachedNodes = nodes.filter(attachedToRevealed)
	nodesToHide = attachedNodes.filter(function (node) {
		return node.weight == 1 && node.name != selNode.name
	})
	// Size the parent correctly.
	if (nodesToHide.length > 0) {
		selNode.chargeMultiple = 1
	}
	// Actually do the hiding.
	nodesToHide.map(hideNode)
	updateHiddenPerc()
	redraw()
}

/**
 * Fold Secondary system. Fold all nodes after triplex_meters. Also fold their associated links.
 */
function foldSecSys() {
	// filter out all links in secondary system, put them into hiddenLinks
	secLinks = links.filter(function (link) {
		if (link.objectType == 'parentChild') {
			hiddenLinks.push(link)
			nodes[link.target.index].chargeMultiple = 1.5
			return true;
		} else if (link.target.objectType == 'triplex_meter' && link.source.objectType == 'gridNode') {
			hiddenLinks.push(link)
			nodes[link.source.index].chargeMultiple = 1.5
			return true;
		} else if (link.target.objectType == 'triplex_meter' && link.source.objectType == 'triplex_meter') {
			hiddenLinks.push(link)
			nodes[link.source.index].chargeMultiple = 1.5
			return true
		} else if (link.target.objectType == 'triplex_meter' && link.source.objectType == 'triplex_node') {
			hiddenLinks.push(link)
			nodes[link.source.index].chargeMultiple = 1.5
			return true
		} else if (link.target.objectType == 'triplex_node' && link.source.objectType == 'gridNode') {
			hiddenLinks.push(link)
			nodes[link.target.index].chargeMultiple = 1.5
			return true
		} else return false;
	})
	// remove secLinks from links and its nodes from nodes
	// TODO: bugs with handling secLinks
	for (var i = links.length - 1; i >= 0; i--) {
		if (links[i].objectType == 'parentChild') {
			links.splice(i, 1)
		} else if (links[i].target.objectType == 'triplex_meter' && links[i].source.objectType == 'gridNode') {
			links.splice(i, 1)
		} else if (links[i].target.objectType == 'triplex_meter' && links[i].source.objectType == 'triplex_meter') {
			links.splice(i, 1)
		} else if (links[i].target.objectType == 'triplex_meter' && links[i].source.objectType == 'triplex_node') {
			links.splice(i, 1)
		} else if (links[i].target.objectType == 'triplex_node' && links[i].source.objectType == 'gridNode') {
			links.splice(i, 1)
		}
	}
	// put nodes into hiddenNodes
	secLinks.filter(function (link) {
		if (!hiddenNodes.some(function (d) {
			return (d.index == link.target.index)
		})) {
			hiddenNodes.push(link.target);
		}

		if (!hiddenNodes.some(function (d) {
			return (d.index == link.source.index)
		}))
			if (link.source.objectType != 'gridNode')
				hiddenNodes.push(link.source);
	})
	// remove nodes in secondary system
	// TODO: bugs with handling hiddenNodes
	for (var i = nodes.length - 1; i >= 0; i--) {
		if (nodes[i].objectType == 'triplex_meter' || nodes[i].objectType == 'triplex_node' || nodes[i].objectType == 'ZIPload' || nodes[i].objectType == 'waterheater' || nodes[i].objectType == 'inverter' || nodes[i].objectType == 'solar' || nodes[i].objectType == 'house' || nodes.objectType == 'capacitor')
			nodes.splice(nodes[i].index, 1)
	}
	redraw()
}

//**************************************************
// TABLE EDITTING FUNCTIONS TODO: huge improvement, rename functions
//**************************************************
/**
 * Fit table according to window size.
 */
function fit_table() {
	var raw_height = $("#selBody").height() + $("#daButtons").height() + $("#selHead").height();
	var win_height = window.innerHeight * 0.8;
	$("#selected").css("height", win_height > raw_height ? raw_height : win_height)
}

$(window).resize(fit_table);

/**
 * Create table for selected node
 */
function create_table() {
	deselect();
	for (prop in treeData) {
		if (prop == "object" || prop == "module") {
			$("#objmod").html(prop)
			$("#value").html(treeData[prop])
		} else if (prop != 'from' && prop != 'to' && prop != 'parent' && prop != 'file') { // Avoid editing machine-written properties!
			var valueEl;
			if (prop == "configuration") {
				valueEl = $("<a>").html(treeData[prop]).attr("href", "#").click(function (e) {
					var myname = $(this).html()
					$("#searchTerm").val("\"name\":\"" + myname + "\"")
					findNext()
					var theButton = $.makeArray($("button")).filter(function (b) {
						return $(b).html().indexOf("Find") > -1
					})[0]
					var dispStatus = theButton.nextSibling.nextSibling.style.display
					if (dispStatus == "" || dispStatus == "none")
						dropPill(theButton, "Find")
					e.preventDefault()
					return false
				})
			} else
				valueEl = treeData[prop]
			$("#body").append($("<tr>")
				.append($("<td>").html(prop))
				.append($("<td>").html(valueEl)))
		}

	}
}

/**
 * Show selected node and its table.
 */
function selectNode() {
	create_table();
	$("#selected").show();
	$("#selected table").show()
	$("#selected").css("display", "inline-block");
	$("#selected").css("max-width", "150px");
	$("#table").css("display", "inline-block");
	$("#table").css("max-width", "150px");
	fit_table();
}

/**
 * Deselect node and its table.
 * @return {[type]}
 */
function deselect() {
	$("#objmod, #value, #body").html("")
	$("#selected").css("height", "auto");
	$("#editButtonRow").show()
	$("#otherButtons").hide();
	$("#selected table").hide()
	$("#selected").hide();
}

/**
 * Validate about edit fields. Check validation on selected components, and its function.
 * 		If not valid, return true.
 * @param  {string} selector
 * @param  {function} testfunc
 * @param  {string} error_msg
 * @return {boolean} invalid
 */
function validation(selector, testfunc, error_msg) {
	var invalid = false;
	$.makeArray($(selector)).forEach(function (e) {
		if (testfunc(e)) {
			$(e).css("border", "1px solid red");
			if (!invalid)
				$(e).focus();
			invalid = true;
		}
	})
	if (invalid) {
		alert(error_msg);
	}
	return invalid;
}

/**
 * Validate blanks, if invalid return true
 * @param  {string} selector
 * @return {boolean}
 */
function validate_blanks(selector) {
	return validation(selector, function (e) {
		return $(e).val().trim() == "";
	})
}

/**
 * Validate name, if invalid return true
 * @param  {string} selector
 * @return {boolean}
 */
function validate_name(selector) {
	return validation(selector, function (e) {
		var m = $(e).val().match(/[A-z0-9_]+/);
		return m == null || m != $(e).val();
	}, "Invalid field values.  Letters, numbers, underscores, no spaces.")
}

$(function () {
	var delete_prop_button = $("<button>")
		.addClass("deleteButton")
		.addClass("deleteProperty")
		.html("╳")

	$("#selected").hide();
	$("#editButton").click(function (e) {
		$("#editButtonRow").hide();
		$("#otherButtons").show();
		$("#body").html("")
		for (prop in treeData) {
			if (prop != "object" && prop != "module") {
				var tr = $("<tr>")
					.append($("<td>").addClass("propertyName").html(prop))
					.append($("<td>")
						.append($("<input>")
							.val(treeData[prop])
							.attr("name", prop)
							.attr("type", "text")))
				if (prop != "name")
					tr.prepend($("<td>")
						.append(delete_prop_button.clone()))
				else
					tr.prepend($("<td>"))
				$("#body").append(tr);
			}
		}
		console.log(treeData);
	})
	$("#cancelButton").click(function (e) {
		$("#editButtonRow").show();
		$("#otherButtons").hide();
		$("#body").html("");
		selectNode();
	})
	$("#saveObject").click(function (e) {
		if (validate_blanks("#body input"))
			return;
		if (validate_name(".newPropertyName"))
			return;

		function isNameAlreadyUsed(testValue) {
			// Helper function to make sure we don't make non-unique names.
			for (leaf in tree) {
				for (attrKey in tree[leaf]) {
					if (attrKey == 'name' && tree[leaf][attrKey] == testValue) {
						return true
					}
				}
			}
			return false
		}
		var propNames = $("#body td.propertyName");
		for (i = 0; i < propNames.length; i++) {
			var key = propNames[i].innerHTML;
			var newValue = $("#body input[name=" + key + "]").val();
			var oldValue = treeData[key];
			if (key == 'name') {
				// 1. If the name is already the name of something else, skip the renaming.
				if (isNameAlreadyUsed(newValue) && oldValue != newValue) {
					// cell.innerHTML = oldValue
					$("#body input[name=name]").val(oldValue);
					alert('Please choose a unique name.');
				} else {
					treeData[key] = newValue
					// cell.innerHTML = newValue
					// k.innerHTML = key
					// 2. If the name is unique, go through EVERY attribute in the tree and replace the old name with the new one.

					for (leaf in tree) {
						for (attrKey in tree[leaf]) {
							if (oldValue == tree[leaf][attrKey]) {
								console.log(tree[leaf]);
								tree[leaf][attrKey] = newValue
							}
						}
					}
					// 3. Go through the nodes and replace the name there too. UGH!
					nodeIndex = findIndex(nodes, 'name', oldValue)
					if (nodeIndex != "") {
						nodes[nodeIndex]['name'] = newValue
					}
				}
			} else {
				treeData[key] = newValue;
			}
		}
		Object.keys(treeData).filter(function (e) {
			return $.makeArray(propNames).map(function (x) {
				return x.innerHTML;
			}).indexOf(e) == -1;
		}).forEach(function (e) {
			if (e != "object" && e != "module")
				delete treeData[e];
		})
		$.makeArray($("#body input.newPropertyName")).map(function (e) {
			return e.value;
		}).forEach(function (e, i) {
			if (e.trim() != "")
				treeData[e] = $("#body input.newPropertyValue")[i].value;
		})
		$("#otherButtons").hide();
		$("#editButtonRow").show();
		selectNode();
	})
	$(document).on("click", ".deleteProperty", function (e) {
		$(this).parent().parent().remove();
	})
	$("#addAttribute").click(function (e) {
		if (validate_blanks(".newPropertyName, .newPropertyValue"))
			return;
		var new_name = $("<input>")
			.addClass("newPropertyName")
			.attr("type", "text");

		$("#body").append($("<tr>")
			.append($("<td>")
				.append(delete_prop_button.clone()))
			.append($("<td>")
				.append(new_name))
			.append($("<td>")
				.append($("<input>")
					.addClass("newPropertyValue")
					.attr("type", "text"))));
		fit_table();
		new_name.focus();
	})
	$("#deleteObject").click(function (e) {
		deleteObject(ti);
	})
})

//ADD PROMPT TO SAVE CHANGES BEFORE EXIT
{% if is_admin or not public %}
	window.onbeforeunload = function(e) {
		var confirmationMessage = 'It looks like you have been editing something. ';
		confirmationMessage += 'If you leave before saving, your changes will be lost.';
		if (unsavedChanges) return confirmationMessage;
	};
{% endif %}
</script>
</body>
